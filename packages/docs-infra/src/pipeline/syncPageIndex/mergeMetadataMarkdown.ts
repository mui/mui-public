import {
  markdownToMetadata,
  metadataToMarkdown,
  type MetadataToMarkdownOptions,
  type PagesMetadata,
  type PageMetadata,
} from './metadataToMarkdown';

/**
 * Options for mergeMetadataMarkdown
 */
export interface MergeMetadataMarkdownOptions
  extends Omit<MetadataToMarkdownOptions, 'editableMarker' | 'indexWrapperComponent'> {
  /** If true, pages in existing markdown that aren't in newMetadata will be preserved. If false (default), they are removed. */
  preserveUnlisted?: boolean;
  /**
   * Component name to wrap the autogenerated content.
   * - `undefined`: preserve existing wrapper (if any)
   * - `null`: explicitly remove the wrapper
   * - `string`: use this component name
   */
  indexWrapperComponent?: string | null;
  /**
   * The path to the file being generated. Used in autogenerated comments to help
   * users validate the file.
   */
  path?: string;
}

/**
 * Merges new page metadata with existing markdown content, preserving the order
 * of pages from the existing markdown when available, unless the file contains
 * only the autogeneration marker (no editable section), in which case pages are
 * sorted alphabetically by title.
 *
 * Pages are matched by their `path` property (e.g., './button/page.mdx'), not by slug.
 * This allows multiple pages to have the same slug (anchor) while still being treated
 * as distinct pages.
 *
 * @param existingMarkdown - The existing markdown content (or undefined if none exists)
 * @param newMetadata - The new metadata to merge in
 * @param options - Optional configuration
 * @param options.preserveUnlisted - If true, pages in existing markdown that aren't in newMetadata will be preserved. If false (default), they are removed.
 * @param options.indexWrapperComponent - Optional component name to wrap the autogenerated content (e.g., 'PagesIndex')
 * @returns The updated markdown content with merged metadata
 *
 * @example
 * ```ts
 * const existingMarkdown = `# Components
 * - [Button](#button) - [Full Docs](./button/page.mdx) - A button
 * - [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx) - A checkbox
 * `;
 *
 * const newMetadata = {
 *   title: 'Components',
 *   pages: [
 *     { slug: 'checkbox', path: './checkbox/page.mdx', title: 'Checkbox', description: 'Updated checkbox' },
 *     { slug: 'button', path: './button/page.mdx', title: 'Button', description: 'Updated button' },
 *     { slug: 'input', path: './input/page.mdx', title: 'Input', description: 'New input' },
 *   ],
 * };
 *
 * const result = await mergeMetadataMarkdown(existingMarkdown, newMetadata);
 * // Result preserves Button, Checkbox order from existing markdown, adds Input at the end
 * ```
 */
export async function mergeMetadataMarkdown(
  existingMarkdown: string | undefined,
  newMetadata: PagesMetadata,
  options: MergeMetadataMarkdownOptions = {},
): Promise<string> {
  const { indexWrapperComponent, path } = options;

  // If no existing markdown, just convert the new metadata
  // Use the provided wrapper unless it's null (which means remove)
  if (!existingMarkdown) {
    return metadataToMarkdown(newMetadata, {
      indexWrapperComponent: indexWrapperComponent === null ? undefined : indexWrapperComponent,
      path,
    });
  }

  // Parse the existing markdown to get the current order
  const existingMetadata = await markdownToMetadata(existingMarkdown);

  // If parsing failed, just use the new metadata
  if (!existingMetadata) {
    return metadataToMarkdown(newMetadata, {
      indexWrapperComponent: indexWrapperComponent === null ? undefined : indexWrapperComponent,
      path,
    });
  }

  // Determine effective wrapper component:
  // - undefined: preserve existing
  // - null: explicitly remove
  // - string: use provided value
  let effectiveWrapper: string | undefined;
  if (indexWrapperComponent === undefined) {
    effectiveWrapper = existingMetadata.indexWrapperComponent;
  } else if (indexWrapperComponent === null) {
    effectiveWrapper = undefined;
  } else {
    effectiveWrapper = indexWrapperComponent;
  }

  // Create a map of new pages by path for quick lookup
  const newPagesMap = new Map<string, PageMetadata>();
  for (const page of newMetadata.pages) {
    newPagesMap.set(page.path, page);
  }

  // Build the merged pages array, preserving order from existing markdown
  let pages: PageMetadata[] = [];
  const addedPaths = new Set<string>();

  // First, add all pages that exist in the existing markdown, in their original order
  for (const existingPage of existingMetadata.pages) {
    const newPage = newPagesMap.get(existingPage.path);
    if (newPage) {
      // Page exists in both - merge the metadata, preferring new values
      // Only exclude descriptionMarkdown if newPage provides a new description
      const { descriptionMarkdown, ...existingPageWithoutDescriptionMarkdown } = existingPage;
      const merged = {
        ...(newPage.description ? existingPageWithoutDescriptionMarkdown : existingPage),
        ...newPage,
        // Preserve tags from existing (user-managed, program should never delete tags)
        tags: existingPage.tags,
        // Preserve skipDetailSection from existing (user-managed for external links)
        skipDetailSection: existingPage.skipDetailSection,
        // Preserve sections from existing if new doesn't have them
        sections: newPage.sections || existingPage.sections,
        // Merge openGraph, but ensure description comes from newPage if it has one
        openGraph:
          newPage.openGraph ??
          (newPage.description
            ? { ...existingPage.openGraph, description: newPage.description }
            : existingPage.openGraph),
      };
      pages.push(merged);
      addedPaths.add(newPage.path);
    }
    // If page doesn't exist in new metadata, it's been removed - don't include it
  }

  // Then, add any new pages that weren't in the existing markdown
  for (const newPage of newMetadata.pages) {
    if (!addedPaths.has(newPage.path)) {
      // This is a new page - automatically add the [New] tag
      const pageWithTag = {
        ...newPage,
        tags: newPage.tags ? [...newPage.tags, 'New'] : ['New'],
      };
      pages.push(pageWithTag);
      addedPaths.add(newPage.path);
    }
  }

  // If alphabetical sorting is requested, sort pages alphabetically by title
  const alphabeticalSortMarker =
    "[//]: # 'This file is autogenerated, but the following list can be modified. Automatically sorted alphabetically.'";
  const requestsAlphabeticalSort = existingMarkdown.includes(alphabeticalSortMarker);

  if (requestsAlphabeticalSort) {
    pages = pages.sort((a, b) => {
      const titleA = a.title || a.slug;
      const titleB = b.title || b.slug;
      return titleA.localeCompare(titleB);
    });
  }

  // Create the final metadata with merged pages
  const mergedMetadata: PagesMetadata = {
    title: newMetadata.title, // Always use the new title
    pages,
  };

  // Preserve the alphabetical sorting marker if it was present
  return metadataToMarkdown(mergedMetadata, {
    editableMarker: requestsAlphabeticalSort ? alphabeticalSortMarker : undefined,
    indexWrapperComponent: effectiveWrapper,
    path,
  });
}
