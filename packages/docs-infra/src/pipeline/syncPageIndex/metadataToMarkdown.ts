import { unified } from 'unified';
import remarkParse from 'remark-parse';
import { visit } from 'unist-util-visit';
import type { Heading, Paragraph, Image, Link, Root, Code } from 'mdast';
import type { ExtractedMetadata, HeadingHierarchy } from '../transformMarkdownMetadata/types';
import { heading, paragraph, text, link, comment } from './createMarkdownNodes';

type HeadingNode = Heading;
type ParagraphNode = Paragraph;
type ImageNode = Image;
type LinkNode = Link;
type CodeNode = Code;

// Definition nodes are used for markdown-style comments like [//]: # "Comment text"
interface DefinitionNode {
  type: 'definition';
  identifier: string;
  label: string;
  title?: string;
  url: string;
}

/**
 * Converts AST nodes (from heading.children) back to markdown string
 */
function astNodesToMarkdown(nodes: any[]): string {
  let result = '';
  for (const node of nodes) {
    if (node.type === 'text') {
      result += node.value;
    } else if (node.type === 'inlineCode') {
      result += `\`${node.value}\``;
    } else if (node.type === 'emphasis') {
      result += `*${astNodesToMarkdown(node.children)}*`;
    } else if (node.type === 'strong') {
      result += `**${astNodesToMarkdown(node.children)}**`;
    } else if (node.type === 'link') {
      result += `[${astNodesToMarkdown(node.children)}](${node.url})`;
    } else if ('children' in node) {
      result += astNodesToMarkdown(node.children);
    }
  }
  return result;
}

export interface PageMetadata extends ExtractedMetadata {
  /** The slug/path for this page (e.g., 'button', 'checkbox') */
  slug: string;
  /** The relative path to the page's MDX file */
  path: string;
  /** Tags for this entry (e.g., 'New', 'Hot', 'Beta') */
  tags?: string[];
  /** Skip generating detail section for this entry (for external links) */
  skipDetailSection?: boolean;
  /** Component parts with their API metadata (for multi-part components) */
  parts?: Record<
    string,
    {
      props?: string[];
      dataAttributes?: string[];
      cssVariables?: string[];
    }
  >;
  /** Component exports with their API metadata (used for both single and multi-part components) */
  exports?: Record<
    string,
    {
      props?: string[];
      dataAttributes?: string[];
      cssVariables?: string[];
    }
  >;
}

export interface PagesMetadata {
  /** The main title for the pages index */
  title: string;
  /** Description below the title (editable, persisted) */
  description?: string;
  /** Array of page metadata */
  pages: PageMetadata[];
  /** Page-level metadata for export (e.g., robots, etc.) */
  pageMetadata?: Record<string, unknown>;
  /** Name of a React component that wraps the autogenerated index content */
  indexWrapperComponent?: string;
}

/**
 * Options for metadataToMarkdown and metadataToMarkdownAst functions
 */
export interface MetadataToMarkdownOptions {
  /**
   * Custom editable section marker comment.
   * If not provided, uses the default marker.
   */
  editableMarker?: string;
  /**
   * Name of a React component to wrap around the autogenerated index content.
   * If provided, the generated markdown will wrap the page list and detail sections
   * in this component (e.g., `<PagesIndex>...</PagesIndex>`).
   * @example 'PagesIndex'
   */
  indexWrapperComponent?: string;
  /**
   * The path to the file being generated. Used in autogenerated comments to help
   * users validate the file.
   */
  path?: string;
}

/**
 * Converts a HeadingHierarchy into markdown list format
 */
function headingHierarchyToMarkdown(
  hierarchy: HeadingHierarchy,
  basePath: string,
  depth: number = 0,
): string {
  let result = '';
  const indent = '  '.repeat(depth);

  for (const node of Object.values(hierarchy)) {
    const { titleMarkdown, children } = node;
    // Convert AST nodes back to markdown string with preserved formatting
    let titleString = astNodesToMarkdown(titleMarkdown);

    // Escape numbered list syntax (e.g., "1. Text" -> "1\. Text")
    // This prevents markdown from treating "- 1. Text" as a nested ordered list
    titleString = titleString.replace(/^(\d+)\.\s/, '$1\\. ');

    result += `${indent}- ${titleString}\n`;
    if (Object.keys(children).length > 0) {
      result += headingHierarchyToMarkdown(children, basePath, depth + 1);
    }
  }

  return result;
}

/**
 * Converts a HeadingHierarchy into markdown AST list nodes
 */
function headingHierarchyToListNodes(hierarchy: HeadingHierarchy, basePath: string): any[] {
  const listItems: any[] = [];

  for (const node of Object.values(hierarchy)) {
    const { titleMarkdown, children } = node;

    const listItem: any = {
      type: 'listItem',
      children: [
        {
          type: 'paragraph',
          children: titleMarkdown, // Use the preserved AST nodes directly
        },
      ],
    };

    // Add nested children if they exist
    if (Object.keys(children).length > 0) {
      const nestedList = {
        type: 'list',
        ordered: false,
        children: headingHierarchyToListNodes(children, basePath),
      };
      listItem.children.push(nestedList);
    }

    listItems.push(listItem);
  }

  return listItems;
}

/**
 * Strips position metadata from AST nodes recursively
 */
function stripPositions(nodes: any[]): any[] {
  return nodes.map((node) => {
    const { position, ...rest } = node;
    if (rest.children) {
      rest.children = stripPositions(rest.children);
    }
    return rest;
  });
}

/**
 * Parses exports metadata from a nested list structure
 * Expects format:
 * - Exports:
 *   - ComponentName - PartName
 *     - Props: a, b, c
 *     - Data Attributes: x, y
 *     - CSS Variables: --var1, --var2
 */
function parseExportsFromListItem(listItem: any): {
  exports?: PageMetadata['exports'];
  parts?: PageMetadata['parts'];
} {
  const exports: PageMetadata['exports'] = {};
  const parts: PageMetadata['parts'] = {};

  // Find the nested list within this list item
  const nestedList = listItem.children?.find((child: any) => child.type === 'list');

  if (!nestedList?.children) {
    return { exports };
  }

  // Parse each export/part item from the nested list
  for (const exportListItem of nestedList.children) {
    if (exportListItem.type !== 'listItem') {
      continue;
    }

    // Find the paragraph with the export/part name
    const exportParagraph = exportListItem.children?.find(
      (child: any) => child.type === 'paragraph',
    );
    if (!exportParagraph) {
      continue;
    }

    // Extract the name from the text node
    const textNode = exportParagraph.children?.find((child: any) => child.type === 'text');
    if (!textNode) {
      continue;
    }

    const fullName = textNode.value || '';

    // Check if this is a part (has dash) or export (no dash)
    const hasDash = fullName.includes(' - ');

    // Find the nested list with props/dataAttributes/cssVariables
    const metadataList = exportListItem.children?.find((child: any) => child.type === 'list');

    // Initialize the metadata (only add properties that have content)
    const metadata: {
      props?: string[];
      dataAttributes?: string[];
      cssVariables?: string[];
    } = {};

    if (metadataList) {
      // Parse each metadata item
      for (const metadataItem of metadataList.children) {
        if (metadataItem.type !== 'listItem') {
          continue;
        }

        const metadataParagraph = metadataItem.children?.find(
          (child: any) => child.type === 'paragraph',
        );
        if (!metadataParagraph) {
          continue;
        }

        const metadataText = extractPlainTextFromNode(metadataParagraph);

        if (metadataText.startsWith('Props:')) {
          const propsText = metadataText.replace('Props:', '').trim();
          if (propsText) {
            metadata.props = propsText.split(',').map((p) => p.trim());
          }
        } else if (metadataText.startsWith('Data Attributes:')) {
          const dataAttributesText = metadataText.replace('Data Attributes:', '').trim();
          if (dataAttributesText) {
            metadata.dataAttributes = dataAttributesText.split(',').map((attr) => attr.trim());
          }
        } else if (metadataText.startsWith('CSS Variables:')) {
          const cssVariablesText = metadataText.replace('CSS Variables:', '').trim();
          if (cssVariablesText) {
            metadata.cssVariables = cssVariablesText.split(',').map((cssVar) => cssVar.trim());
          }
        }
      }
    }

    if (hasDash) {
      // This is a part name (e.g., "ComponentName - PartName")
      const partName = fullName.split(' - ').pop() || fullName;
      // Always add the part, even if it has no properties
      parts[partName] = metadata;
    } else {
      // This is an export name (no dash)
      const exportName = fullName;
      // Always add the export, even if it has no properties
      exports[exportName] = metadata;
    }
  }

  return {
    exports: Object.keys(exports).length > 0 ? exports : undefined,
    parts: Object.keys(parts).length > 0 ? parts : undefined,
  };
}

/**
 * Parses a list of section links back into a HeadingHierarchy structure
 * Expects list items with links in the format: [Title](path#slug)
 * OR plain text in the format: Title
 */
function parseHeadingSections(listNode: any): HeadingHierarchy {
  const hierarchy: HeadingHierarchy = {};
  const stack: Array<{ depth: number; node: HeadingHierarchy }> = [{ depth: -1, node: hierarchy }];

  // Helper to calculate depth from list nesting
  function processListItems(
    items: any[],
    baseDepth: number,
    parentIsOrdered: boolean = false,
    startIndex: number = 1,
  ) {
    for (let i = 0; i < items.length; i += 1) {
      const item = items[i];
      if (item.type !== 'listItem') {
        continue;
      }

      // Find the paragraph content
      const itemParagraph = item.children?.find((child: any) => child.type === 'paragraph');
      if (!itemParagraph) {
        continue;
      }

      // Try to find a link first (linked format)
      const itemLink = itemParagraph?.children?.find((child: any) => child.type === 'link');

      let title = '';
      let titleMarkdown: any[] = [];
      let slug = '';

      if (itemLink) {
        // Linked format: [Title](path#slug)
        title = itemLink.children?.[0]?.value || '';
        // Strip position metadata from titleMarkdown
        titleMarkdown = stripPositions(itemLink.children || []);
        const url = itemLink.url || '';
        slug = url.split('#')[1] || '';
      } else {
        // Plain text format: extract all children (preserves formatting)
        // Strip position metadata from titleMarkdown
        titleMarkdown = stripPositions(itemParagraph.children || []);

        // Extract plain text for slug generation
        let rawTitle = itemParagraph.children
          .map((child: any) => {
            if (child.type === 'text') {
              return child.value;
            }
            if (child.type === 'inlineCode') {
              return child.value;
            }
            if ('children' in child) {
              // Recursively extract text from nested nodes
              return astNodesToMarkdown(child.children).replace(/[*`_]/g, '');
            }
            return '';
          })
          .join('')
          .trim();

        // Unescape numbered list syntax (e.g., "1\. Text" -> "1. Text")
        // This handles titles that were escaped during serialization
        rawTitle = rawTitle.replace(/^(\d+)\\\.\s/, '$1. ');

        // If this is from an ordered list, prepend the number
        if (parentIsOrdered) {
          const itemNumber = startIndex + i;
          title = `${itemNumber}. ${rawTitle}`;
          // Update titleMarkdown to include the number
          titleMarkdown = [{ type: 'text', value: title }];
        } else {
          title = rawTitle;
        }

        // Generate slug from the title (with number if applicable)
        slug = title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '');
      }

      if (title && slug && titleMarkdown.length > 0) {
        // Pop stack until we find the parent at the right depth
        while (stack.length > 0 && stack[stack.length - 1].depth >= baseDepth) {
          stack.pop();
        }

        const parent = stack[stack.length - 1].node;
        const newNode = {
          title,
          titleMarkdown,
          children: {} as HeadingHierarchy,
        };
        parent[slug] = newNode;
        stack.push({ depth: baseDepth, node: newNode.children });

        // Check for nested lists (can be ordered or unordered)
        const nestedLists = item.children?.filter((child: any) => child.type === 'list');
        for (const nestedList of nestedLists || []) {
          if (nestedList.children) {
            const nestedIsOrdered = nestedList.ordered === true;
            const nestedStart = nestedList.start || 1;
            // Always increment depth for true nesting
            processListItems(nestedList.children, baseDepth + 1, nestedIsOrdered, nestedStart);
          }
        }
      }
    }
  }

  if (listNode?.type === 'list' && listNode.children) {
    processListItems(listNode.children, 0);
  }

  return hierarchy;
} /**
 * Converts an array of page metadata into a markdown AST
 */
export function metadataToMarkdownAst(
  data: PagesMetadata,
  options: MetadataToMarkdownOptions = {},
): Root {
  const { editableMarker, indexWrapperComponent, path } = options;
  const { title: mainTitle, description: mainDescription, pages, pageMetadata } = data;
  const children: Root['children'] = [];

  // Add main title
  children.push(heading(1, mainTitle));

  // Add description if provided (editable section)
  if (mainDescription) {
    children.push(paragraph(mainDescription));
  }

  // Add editable section marker
  // Extract just the comment text from the marker (strip [//]: # 'text' wrapper)
  const defaultMarkerText = 'This file is autogenerated, but the following list can be modified.';
  let markerText = defaultMarkerText;
  if (editableMarker) {
    // Extract text between single quotes: [//]: # 'text'
    const match = editableMarker.match(/\[\/\/\]: # '(.+)'/);
    markerText = match ? match[1] : defaultMarkerText;
  }
  children.push(comment(markerText) as any);

  // Open wrapper component if provided
  if (indexWrapperComponent) {
    children.push({
      type: 'html',
      value: `<${indexWrapperComponent}>`,
    } as any);
  }

  // Add page list (editable section) as proper list items
  const listItems: any[] = [];
  for (const page of pages) {
    const pageTitle = page.title || page.slug;

    // Check if this is a single-link entry (external link or no detail section)
    const isSingleLink = page.skipDetailSection || false;

    let paragraphChildren: any[];
    if (isSingleLink) {
      // Format: - [Title](./path) [Tag1] [Tag2]
      paragraphChildren = [link(page.path, pageTitle)];

      // Add tags if present (directly after link)
      if (page.tags && page.tags.length > 0) {
        for (const tag of page.tags) {
          paragraphChildren.push(text(` [${tag}]`));
        }
      }
    } else {
      // Format: - [Title](#slug) [Tag1] [Tag2] - [Full Docs](./path/page.mdx)
      paragraphChildren = [link(`#${page.slug}`, pageTitle)];

      // Add tags if present (directly after component name)
      if (page.tags && page.tags.length > 0) {
        for (const tag of page.tags) {
          paragraphChildren.push(text(` [${tag}]`));
        }
      }

      // Add separator and Full Docs link
      paragraphChildren.push(text(' - '));
      paragraphChildren.push(link(page.path, 'Full Docs'));
    }

    listItems.push({
      type: 'listItem',
      spread: false,
      children: [paragraph(paragraphChildren)],
    });
  }

  // Add the list to children
  children.push({
    type: 'list',
    ordered: false,
    spread: false,
    children: listItems,
  } as any);

  // Add non-editable section marker
  // Trim common prefixes and suffixes from path, quote if contains parentheses for shell safety
  const normalizedPath = typeof path === 'string' ? path.replace(/\\/g, '/') : undefined;
  const trimmedPath = normalizedPath
    ?.replace(/^(src\/app\/|app\/)/, '')
    .replace(/\/page\.mdx$/, '');
  const quotedPath = trimmedPath && /[()]/.test(trimmedPath) ? `"${trimmedPath}"` : trimmedPath;
  const doNotEditComment = quotedPath
    ? `This file is autogenerated, DO NOT EDIT AFTER THIS LINE, run: pnpm docs:validate ${quotedPath}`
    : 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE';
  children.push(comment(doNotEditComment) as any);

  // Add detailed page sections (non-editable)
  for (const page of pages) {
    const pageTitle = page.title || page.slug;
    // Note: We don't replace newlines here to allow natural line breaks in detailed sections
    const description = page.description || 'No description available';
    const keywords = page.keywords || [];
    const image = page.image;

    // Add page heading
    children.push(heading(2, pageTitle));

    // Add description
    children.push(paragraph(description));

    // Add image if available
    if (image) {
      children.push({
        type: 'paragraph',
        children: [
          {
            type: 'image',
            url: image.url,
            alt: image.alt || pageTitle,
          },
        ],
      } as any);
    }

    // Add metadata list (keywords, sections, parts, and exports combined)
    const hasKeywords = keywords.length > 0;
    const hasSections = page.sections && Object.keys(page.sections).length > 0;
    const hasParts = page.parts && Object.keys(page.parts).length > 0;
    const hasExports = page.exports && Object.keys(page.exports).length > 0;

    if (hasKeywords || hasSections || hasParts || hasExports) {
      const metadataListItems: any[] = [];

      if (hasKeywords) {
        metadataListItems.push({
          type: 'listItem',
          children: [paragraph(`Keywords: ${keywords.join(', ')}`)],
        });
      }

      if (hasSections && page.sections) {
        const sectionListItems = headingHierarchyToListNodes(page.sections, page.path);
        metadataListItems.push({
          type: 'listItem',
          children: [
            paragraph('Sections:'),
            {
              type: 'list',
              ordered: false,
              children: sectionListItems,
            },
          ],
        });
      }

      if (hasParts || hasExports) {
        const exportsListItems: any[] = [];

        // First, add all parts with their metadata (use dash format)
        if (hasParts && page.parts) {
          for (const [partName, partMetadata] of Object.entries(page.parts)) {
            const partListItems: any[] = [];

            if (partMetadata.props && partMetadata.props.length > 0) {
              partListItems.push({
                type: 'listItem',
                children: [paragraph(`Props: ${partMetadata.props.join(', ')}`)],
              });
            }

            if (partMetadata.dataAttributes && partMetadata.dataAttributes.length > 0) {
              partListItems.push({
                type: 'listItem',
                children: [paragraph(`Data Attributes: ${partMetadata.dataAttributes.join(', ')}`)],
              });
            }

            if (partMetadata.cssVariables && partMetadata.cssVariables.length > 0) {
              partListItems.push({
                type: 'listItem',
                children: [paragraph(`CSS Variables: ${partMetadata.cssVariables.join(', ')}`)],
              });
            }

            // Add the part with dash separator
            if (partListItems.length > 0) {
              exportsListItems.push({
                type: 'listItem',
                children: [
                  {
                    type: 'paragraph',
                    children: [{ type: 'text', value: `${page.title} - ${partName}` }],
                  },
                  {
                    type: 'list',
                    ordered: false,
                    children: partListItems,
                  },
                ],
              });
            } else {
              // Part with no properties - just add the part name with dash
              exportsListItems.push({
                type: 'listItem',
                children: [
                  {
                    type: 'paragraph',
                    children: [{ type: 'text', value: `${page.title} - ${partName}` }],
                  },
                ],
              });
            }
          }
        }

        // Then add all exports with their metadata (no dash format)
        if (hasExports && page.exports) {
          for (const [exportName, exportMetadata] of Object.entries(page.exports)) {
            const exportListItems: any[] = [];

            if (exportMetadata.props && exportMetadata.props.length > 0) {
              exportListItems.push({
                type: 'listItem',
                children: [paragraph(`Props: ${exportMetadata.props.join(', ')}`)],
              });
            }

            if (exportMetadata.dataAttributes && exportMetadata.dataAttributes.length > 0) {
              exportListItems.push({
                type: 'listItem',
                children: [
                  paragraph(`Data Attributes: ${exportMetadata.dataAttributes.join(', ')}`),
                ],
              });
            }

            if (exportMetadata.cssVariables && exportMetadata.cssVariables.length > 0) {
              exportListItems.push({
                type: 'listItem',
                children: [paragraph(`CSS Variables: ${exportMetadata.cssVariables.join(', ')}`)],
              });
            }

            // Always add the export, even if it has no properties
            if (exportListItems.length > 0) {
              exportsListItems.push({
                type: 'listItem',
                children: [
                  {
                    type: 'paragraph',
                    children: [{ type: 'text', value: exportName }],
                  },
                  {
                    type: 'list',
                    ordered: false,
                    children: exportListItems,
                  },
                ],
              });
            } else {
              // Export with no properties - just add the export name
              exportsListItems.push({
                type: 'listItem',
                children: [
                  {
                    type: 'paragraph',
                    children: [{ type: 'text', value: exportName }],
                  },
                ],
              });
            }
          }
        }

        if (exportsListItems.length > 0) {
          metadataListItems.push({
            type: 'listItem',
            children: [
              paragraph('Exports:'),
              {
                type: 'list',
                ordered: false,
                children: exportsListItems,
              },
            ],
          });
        }
      }

      // Wrap metadata in details/summary tags
      children.push({
        type: 'html',
        value: '<details>',
      } as any);
      children.push(paragraph(''));
      children.push({
        type: 'html',
        value: '<summary>Outline</summary>',
      } as any);
      children.push(paragraph(''));
      children.push({
        type: 'list',
        ordered: false,
        children: metadataListItems,
      } as any);
      children.push(paragraph(''));
      children.push({
        type: 'html',
        value: '</details>',
      } as any);
    }

    // Add embeddings as a comment if available
    if (page.embeddings && page.embeddings.length > 0) {
      children.push(comment(`Embeddings: ${JSON.stringify(page.embeddings)}`));
    }

    // Add read more link
    children.push(paragraph([link(page.path, 'Read more')]));
  }

  // Close wrapper component if provided
  if (indexWrapperComponent) {
    children.push({
      type: 'html',
      value: `</${indexWrapperComponent}>`,
    } as any);
  }

  // Add metadata export at the end
  children.push(
    comment('This file is autogenerated, but the following metadata can be modified.') as any,
  );

  let metadataCode: string;
  if (pageMetadata && Object.keys(pageMetadata).length > 0) {
    metadataCode = `export const metadata = ${JSON.stringify(pageMetadata, null, 2)};`;
  } else {
    // Default metadata with robots noindex
    metadataCode = `export const metadata = {
  robots: {
    index: false,
  },
};`;
  }
  // Output as raw MDX/JSX code (mdxjsEsm node type)
  children.push({
    type: 'mdxjsEsm',
    value: metadataCode,
  } as any);

  return {
    type: 'root',
    children,
  };
}

/**
 * Converts an array of page metadata into the markdown format (string)
 */
export function metadataToMarkdown(
  data: PagesMetadata,
  options: MetadataToMarkdownOptions | string = {},
): string {
  // Support legacy signature where second param was editableMarker string
  const normalizedOptions: MetadataToMarkdownOptions =
    typeof options === 'string' ? { editableMarker: options } : options;
  const { editableMarker, indexWrapperComponent, path } = normalizedOptions;

  const { title, description, pages, pageMetadata } = data;
  const lines: string[] = [];

  // Add main title
  lines.push(`# ${title}`);
  lines.push('');

  // Add description if provided (editable section)
  if (description) {
    lines.push(description);
    lines.push('');
  }

  // Add editable section marker
  const marker =
    editableMarker ??
    "[//]: # 'This file is autogenerated, but the following list can be modified.'";
  lines.push(marker);
  lines.push('');

  // Open wrapper component if provided
  if (indexWrapperComponent) {
    lines.push(`<${indexWrapperComponent}>`);
    lines.push('');
  }

  // Add page list (editable section)
  for (const page of pages) {
    const pageTitle = page.title || page.slug;

    // Check if this is a single-link entry (external link or no detail section)
    const isSingleLink = page.skipDetailSection || false;

    let line: string;
    if (isSingleLink) {
      // Format: - [Title](./path) [Tag1] [Tag2]
      line = `- [${pageTitle}](${page.path})`;

      // Add tags if present (directly after link)
      if (page.tags && page.tags.length > 0) {
        for (const tag of page.tags) {
          line += ` [${tag}]`;
        }
      }
    } else {
      // Format: - [Title](#slug) [Tag1] [Tag2] - [Full Docs](./path/page.mdx)
      line = `- [${pageTitle}](#${page.slug})`;

      // Add tags if present (directly after component name)
      if (page.tags && page.tags.length > 0) {
        for (const tag of page.tags) {
          line += ` [${tag}]`;
        }
      }

      // Add separator and Full Docs link
      line += ` - [Full Docs](${page.path})`;
    }

    lines.push(line);
  }

  lines.push('');

  // Add non-editable section marker
  // Trim common prefixes and suffixes from path, quote if contains parentheses for shell safety
  const normalizedPath = typeof path === 'string' ? path.replace(/\\/g, '/') : undefined;
  const trimmedPath = normalizedPath
    ?.replace(/^(src\/app\/|app\/)/, '')
    .replace(/\/page\.mdx$/, '');
  const quotedPath = trimmedPath && /[()]/.test(trimmedPath) ? `"${trimmedPath}"` : trimmedPath;
  const doNotEditMarker = quotedPath
    ? `[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE, run: pnpm docs:validate ${quotedPath}'`
    : "[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'";
  lines.push(doNotEditMarker);
  lines.push('');

  // Add detailed page sections (non-editable)
  for (const page of pages) {
    // Skip detail section for single-link entries (external links)
    if (page.skipDetailSection) {
      continue;
    }

    const pageTitle = page.title || page.slug;
    // Use descriptionMarkdown to preserve formatting if available
    // Note: We don't replace newlines here to allow natural line breaks in detailed sections
    let pageDescription: string;
    if (page.descriptionMarkdown && page.descriptionMarkdown.length > 0) {
      pageDescription = astNodesToMarkdown(page.descriptionMarkdown);
    } else {
      pageDescription = page.description || 'No description available';
    }
    const keywords = page.keywords || [];
    const image = page.image;

    // Add page heading
    lines.push(`## ${pageTitle}`);
    lines.push('');

    // Add description
    lines.push(pageDescription);
    lines.push('');

    // Add image if available
    if (image) {
      lines.push(`![${image.alt || pageTitle}](${image.url})`);
      lines.push('');
    }

    // Add metadata list (keywords, sections, parts, and exports)
    const hasKeywords = keywords.length > 0;
    const hasSections = page.sections && Object.keys(page.sections).length > 0;
    const hasParts = page.parts && Object.keys(page.parts).length > 0;
    const hasExports = page.exports && Object.keys(page.exports).length > 0;

    // Track if we actually add any metadata content
    let hasMetadataContent = false;

    if (hasKeywords || hasSections || hasParts || hasExports) {
      lines.push('<details>');
      lines.push('');
      lines.push('<summary>Outline</summary>');
      lines.push('');
      if (hasKeywords) {
        lines.push(`- Keywords: ${keywords.join(', ')}`);
        hasMetadataContent = true;
      }
      if (hasSections && page.sections) {
        const sectionLines = headingHierarchyToMarkdown(page.sections, page.path, 1); // Start at depth 1 for indentation
        lines.push('- Sections:');
        lines.push(sectionLines.trimEnd());
        hasMetadataContent = true;
      }
      // Handle both parts and exports
      // Parts and exports are combined into a single "Exports:" section
      // Parts use format "ComponentName - PartName" (written with dash)
      // Exports use just "ExportName" (written without dash)
      if (hasParts || hasExports) {
        lines.push('- Exports:');

        // First, list all parts with their metadata (use dash format)
        if (hasParts && page.parts) {
          for (const [partName, partMetadata] of Object.entries(page.parts)) {
            const hasProps = partMetadata.props && partMetadata.props.length > 0;
            const hasDataAttributes =
              partMetadata.dataAttributes && partMetadata.dataAttributes.length > 0;
            const hasCssVariables =
              partMetadata.cssVariables && partMetadata.cssVariables.length > 0;

            lines.push(`  - ${page.title} - ${partName}`);

            if (hasProps) {
              lines.push(`    - Props: ${partMetadata.props!.join(', ')}`);
            }
            if (hasDataAttributes) {
              lines.push(`    - Data Attributes: ${partMetadata.dataAttributes!.join(', ')}`);
            }
            if (hasCssVariables) {
              lines.push(`    - CSS Variables: ${partMetadata.cssVariables!.join(', ')}`);
            }
          }
        }

        // Then list all exports with their metadata (no dash format)
        if (hasExports && page.exports) {
          for (const [exportName, exportMetadata] of Object.entries(page.exports)) {
            const hasProps = exportMetadata.props && exportMetadata.props.length > 0;
            const hasDataAttributes =
              exportMetadata.dataAttributes && exportMetadata.dataAttributes.length > 0;
            const hasCssVariables =
              exportMetadata.cssVariables && exportMetadata.cssVariables.length > 0;

            lines.push(`  - ${exportName}`);

            if (hasProps) {
              lines.push(`    - Props: ${exportMetadata.props!.join(', ')}`);
            }
            if (hasDataAttributes) {
              lines.push(`    - Data Attributes: ${exportMetadata.dataAttributes!.join(', ')}`);
            }
            if (hasCssVariables) {
              lines.push(`    - CSS Variables: ${exportMetadata.cssVariables!.join(', ')}`);
            }
          }
        }
        hasMetadataContent = true;
      }
      lines.push('');
      lines.push('</details>');
      // Only add blank line if we actually added metadata content
      if (hasMetadataContent) {
        lines.push('');
      }
    }

    // Add embeddings as a comment if available
    if (page.embeddings && page.embeddings.length > 0) {
      lines.push(`[//]: # 'Embeddings: ${JSON.stringify(page.embeddings)}'`);
      lines.push('');
    }

    // Add read more link
    lines.push(`[Read more](${page.path})`);
    lines.push('');
  }

  // Close wrapper component if provided
  if (indexWrapperComponent) {
    lines.push(`</${indexWrapperComponent}>`);
    lines.push('');
  }

  // Add metadata export at the end
  lines.push("[//]: # 'This file is autogenerated, but the following metadata can be modified.'");
  lines.push('');
  if (pageMetadata && Object.keys(pageMetadata).length > 0) {
    lines.push(`export const metadata = ${JSON.stringify(pageMetadata, null, 2)};`);
  } else {
    // Default metadata with robots noindex
    lines.push(`export const metadata = {
  robots: {
    index: false,
  },
};`);
  }
  lines.push('');

  // Remove trailing empty line
  return `${lines.join('\n').trimEnd()}\n`;
}

/**
 * Parses markdown content and extracts page metadata using unified
 */
export async function markdownToMetadata(markdown: string): Promise<PagesMetadata | null> {
  const tree = unified().use(remarkParse).parse(markdown);

  let title: string | null = null;
  let description: string | undefined;
  let pageMetadata: Record<string, unknown> | undefined;
  let indexWrapperComponent: string | undefined;
  const pages: PageMetadata[] = [];
  let currentSection: 'header' | 'editable' | 'details' | 'metadata' = 'header';
  let currentPage: Partial<PageMetadata> | null = null;

  // Visit all nodes in the AST
  visit(tree, (node, index, parent) => {
    // Track sections based on definition nodes (HTML-style comments)
    if (node.type === 'definition') {
      const defNode = node as DefinitionNode;
      if (defNode.title?.includes('following list can be modified')) {
        currentSection = 'editable';
        return;
      }
      if (defNode.title?.includes('DO NOT EDIT AFTER THIS LINE')) {
        currentSection = 'details';
        return;
      }
      if (defNode.title?.includes('following metadata can be modified')) {
        currentSection = 'metadata';
        return;
      }
      // Parse embeddings from comment
      if (currentPage && defNode.title?.includes('Embeddings:')) {
        const embeddingsText = defNode.title.replace('Embeddings:', '').trim();
        try {
          currentPage.embeddings = JSON.parse(embeddingsText);
        } catch (error) {
          console.error('Failed to parse embeddings:', error);
        }
        return;
      }
    }

    // Extract wrapper component from HTML nodes (e.g., <PagesIndex>)
    if (node.type === 'html' && !indexWrapperComponent) {
      const htmlNode = node as { type: 'html'; value: string };
      // Match opening tag like <PagesIndex> or <ComponentsIndex>
      const openingTagMatch = htmlNode.value.match(/^<([A-Z][a-zA-Z0-9]*)>$/);
      if (openingTagMatch) {
        indexWrapperComponent = openingTagMatch[1];
      }
    }

    // Extract main title (H1)
    if (node.type === 'heading') {
      const headingNode = node as HeadingNode;
      if (headingNode.depth === 1) {
        title = extractPlainTextFromNode(headingNode);
        currentSection = 'header';
        return;
      }
    }

    // Parse description in header section (paragraph after H1, before editable marker)
    if (currentSection === 'header' && node.type === 'paragraph' && parent?.type === 'root') {
      const paragraphNode = node as ParagraphNode;
      const paragraphText = extractPlainTextFromNode(paragraphNode);
      if (paragraphText && !description) {
        description = paragraphText;
      }
      return;
    }

    // Parse editable list items - check if we're in a paragraph that's a child of a listItem
    if (currentSection === 'editable' && node.type === 'paragraph' && parent?.type === 'listItem') {
      const paragraphNode = node as ParagraphNode;
      if (paragraphNode.children) {
        // Look for links in the paragraph
        const links = paragraphNode.children.filter(
          (child: any) => child.type === 'link',
        ) as LinkNode[];

        if (links.length === 0) {
          // No links found, skip this item
          return;
        }

        if (links.length === 1) {
          // Single link format: - [Title](./path) [Tag1] [Tag2]
          // This is for external links or pages that don't have detail sections
          const singleLink = links[0];
          const pageTitle = extractPlainTextFromNode(singleLink);
          const path = singleLink.url;

          // Generate slug from title for consistency
          const slug = titleToSlug(pageTitle);

          // Extract tags from text nodes after the link
          // Tags are in the format [Tag] where Tag can be New, Hot, Beta, External, etc.
          const tags: string[] = [];
          let foundLink = false;
          for (const child of paragraphNode.children) {
            if (child === singleLink) {
              foundLink = true;
              continue;
            }
            if (foundLink && child.type === 'text') {
              // Match [Tag] patterns in the text
              const tagRegex = /\[(\w+)\]/g;
              let match = tagRegex.exec(child.value);
              while (match !== null) {
                tags.push(match[1]);
                match = tagRegex.exec(child.value);
              }
            }
          }

          // These entries are preserved as-is in the editable section
          // They won't have detail sections generated
          pages.push({
            slug,
            path,
            title: pageTitle,
            description: 'No description available',
            tags: tags.length > 0 ? tags : undefined,
            skipDetailSection: true, // Mark as external/single-link entry
          });
        } else if (links.length >= 2) {
          // Two-link format: - [Title](#slug) [Tag1] [Tag2] - [Full Docs](./path/page.mdx)
          const sectionLink = links[0];
          const docsLink = links[1];

          const pageTitle = extractPlainTextFromNode(sectionLink);
          const slug = sectionLink.url.replace('#', ''); // Extract slug from #slug
          const path = docsLink.url; // Get path from full docs link

          // Extract tags from text nodes between the section link and full docs link
          // Tags are in the format [Tag] where Tag can be New, Hot, Beta, etc.
          const tags: string[] = [];
          let foundSectionLink = false;
          let foundDocsLink = false;
          for (const child of paragraphNode.children) {
            if (child === sectionLink) {
              foundSectionLink = true;
              continue;
            }
            if (child === docsLink) {
              foundDocsLink = true;
              break;
            }
            if (foundSectionLink && !foundDocsLink && child.type === 'text') {
              // Match [Tag] patterns in the text
              const tagRegex = /\[(\w+)\]/g;
              let match = tagRegex.exec(child.value);
              while (match !== null) {
                tags.push(match[1]);
                match = tagRegex.exec(child.value);
              }
            }
          }

          // Only extract slug, path, title, and tags from the editable list
          // The description will be filled in from the details section
          pages.push({
            slug,
            path,
            title: pageTitle,
            description: 'No description available', // Will be updated from details section
            tags: tags.length > 0 ? tags : undefined,
          });
        }
      }
      return;
    }

    // Parse detail sections
    if (currentSection === 'details') {
      // Start of a new page section (H2)
      if (node.type === 'heading') {
        const headingNode = node as HeadingNode;
        if (headingNode.depth === 2) {
          // Save previous page if exists
          if (currentPage?.slug) {
            const savedSlug = currentPage.slug;
            const foundIndex = pages.findIndex((c) => c.slug === savedSlug);
            if (foundIndex !== -1) {
              pages[foundIndex] = {
                ...pages[foundIndex],
                ...currentPage,
              } as PageMetadata;
            }
          }

          const pageTitle = extractPlainTextFromNode(headingNode);
          // Find the page in the existing pages array by matching the title
          const existingPage = pages.find((p) => p.title === pageTitle);
          if (existingPage) {
            // Start updating this existing page
            currentPage = { slug: existingPage.slug, title: pageTitle };
          } else {
            // If no matching page found, create a new one with slug from title
            const slug = titleToSlug(pageTitle);
            currentPage = { slug, title: pageTitle };
          }
          return;
        }
      }

      // Parse description (first paragraph after title) and keywords/sections
      if (currentPage && node.type === 'paragraph') {
        const paragraphNode = node as ParagraphNode;
        const paragraphText = extractTextFromNode(paragraphNode);

        // Check if we're in a list item
        if (parent?.type === 'listItem') {
          // Parse keywords
          if (paragraphText.startsWith('Keywords:')) {
            const keywordsText = paragraphText.replace('Keywords:', '').trim();
            currentPage.keywords = keywordsText.split(',').map((k) => k.trim());
            return;
          }

          // Parse exports - they're in a nested list within the same parent list item
          if (paragraphText.startsWith('Exports:')) {
            const result = parseExportsFromListItem(parent as any);
            if (result.exports) {
              currentPage.exports = result.exports;
            }
            if (result.parts) {
              currentPage.parts = result.parts;
            }
            return;
          }

          // Parse sections - now they're in a nested list within the same parent list item
          if (paragraphText.startsWith('Sections:')) {
            // Find the nested list within this list item
            const listItem = parent as any;
            const nestedList = listItem.children?.find((child: any) => child.type === 'list');

            if (nestedList && nestedList.children) {
              currentPage.sections = parseHeadingSections(nestedList);
            } else {
              currentPage.sections = {};
            }
            return;
          }
        }

        // Skip read more links
        if (paragraphText.startsWith('[Read more]')) {
          return;
        }

        // Parse description (first paragraph after title, not in a list)
        if (!currentPage.description && parent?.type !== 'listItem') {
          currentPage.description = paragraphText;
          // Store the AST nodes with position info stripped for clean serialization
          if (paragraphNode.children) {
            currentPage.descriptionMarkdown = stripPositions(paragraphNode.children);
          }
          return;
        }
      }

      // Parse image
      if (currentPage && node.type === 'image') {
        const imageNode = node as ImageNode;
        currentPage.image = {
          url: imageNode.url,
          alt: imageNode.alt || currentPage.title || currentPage.slug || '',
        };
        return;
      }
    }

    // Parse metadata export section (code block or raw export statement after metadata comment)
    if (currentSection === 'metadata' && node.type === 'code') {
      const codeNode = node as CodeNode;
      const codeValue = codeNode.value;
      // Parse the export const metadata = { ... } statement
      const metadataMatch = codeValue.match(/export\s+const\s+metadata\s*=\s*(\{[\s\S]*\})/);
      if (metadataMatch) {
        try {
          // Use Function constructor to safely parse the object literal
          // eslint-disable-next-line no-new-func
          pageMetadata = new Function(`return ${metadataMatch[1]}`)();
        } catch (error) {
          console.error('Failed to parse page metadata:', error);
        }
      }
      return;
    }
  });

  // Also try to parse metadata from raw export statement in the markdown
  // This handles MDX files where the export is not in a code block
  const metadataExportMatch = markdown.match(
    /\[\/\/\]: # 'This file is autogenerated, but the following metadata can be modified\.'\s*\n\s*\n\s*export\s+const\s+metadata\s*=\s*(\{[\s\S]*?\n\})/,
  );
  if (metadataExportMatch && !pageMetadata) {
    try {
      // eslint-disable-next-line no-new-func
      pageMetadata = new Function(`return ${metadataExportMatch[1]}`)();
    } catch (error) {
      console.error('Failed to parse page metadata from raw export:', error);
    }
  }

  // Save last page if exists
  if (currentPage) {
    const partialPage = currentPage as Partial<PageMetadata>;
    if (partialPage.slug) {
      const foundIndex = pages.findIndex((c) => c.slug === partialPage.slug);
      if (foundIndex !== -1) {
        pages[foundIndex] = {
          ...pages[foundIndex],
          ...partialPage,
        } as PageMetadata;
      }
    }
  }

  if (!title) {
    return null;
  }

  return {
    title,
    description,
    pages,
    pageMetadata,
    indexWrapperComponent,
  };
}

/**
 * Extracts plain text content from any mdast node without markdown formatting
 * Used for titles and other places where we don't want markdown syntax
 */
function extractPlainTextFromNode(node: any): string {
  if (node.type === 'text') {
    return node.value;
  }
  if (node.type === 'inlineCode') {
    return node.value;
  }
  if (node.children) {
    const extractedText = node.children
      .map((child: any) => extractPlainTextFromNode(child))
      .join('');
    // For paragraph nodes, replace sequences of regular whitespace (spaces, tabs, newlines)
    // with a single space, but preserve non-breaking spaces and other special whitespace
    if (node.type === 'paragraph') {
      return extractedText.replace(/[ \t\n\r]+/g, ' ').trim();
    }
    return extractedText;
  }
  return '';
}

/**
 * Extracts text content from any mdast node
 * Preserves markdown formatting like inline code and links
 */
function extractTextFromNode(node: any): string {
  if (node.type === 'text') {
    return node.value;
  }
  if (node.type === 'inlineCode') {
    return `\`${node.value}\``;
  }
  if (node.type === 'link') {
    const linkText = node.children.map((child: any) => extractTextFromNode(child)).join('');
    return `[${linkText}](${node.url})`;
  }
  if (node.type === 'emphasis') {
    const emphasisText = node.children.map((child: any) => extractTextFromNode(child)).join('');
    return `*${emphasisText}*`;
  }
  if (node.type === 'strong') {
    const strongText = node.children.map((child: any) => extractTextFromNode(child)).join('');
    return `**${strongText}**`;
  }
  if (node.children) {
    const extractedText = node.children.map((child: any) => extractTextFromNode(child)).join('');
    // For paragraph nodes, replace sequences of regular whitespace (spaces, tabs, newlines)
    // with a single space, but preserve non-breaking spaces and other special whitespace
    if (node.type === 'paragraph') {
      return extractedText.replace(/[ \t\n\r]+/g, ' ').trim();
    }
    return extractedText;
  }
  return '';
}

/**
 * Converts a title to a slug (simple version)
 */
function titleToSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}
