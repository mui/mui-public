import { describe, it, expect } from 'vitest';
import {
  metadataToMarkdown,
  metadataToMarkdownAst,
  markdownToMetadata,
} from './metadataToMarkdown';
import type { PagesMetadata } from './metadataToMarkdown';

describe('metadataToMarkdown', () => {
  it('should convert page metadata to markdown string', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          embeddings: [0.1, 0.2, 0.3],
          image: {
            url: 'https://example.com/button.png',
            alt: 'A simple button',
          },
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      ![A simple button](https://example.com/button.png)

      <details>

      <summary>Outline</summary>

      - Keywords: interactive, input

      </details>

      [//]: # 'Embeddings: [0.1,0.2,0.3]'

      [Read more](./button/page.mdx)

      [//]: # 'This file is autogenerated, but the following metadata can be modified.'

      export const metadata = {
        robots: {
          index: false,
        },
      };
      "
    `);
  });

  it('should handle multiple pages', () => {
    const data: PagesMetadata = {
      title: 'UI Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [Button](#button) - [Full Docs](./button/page.mdx)');
    expect(result).toContain('- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)');
    expect(result).toContain('## Button');
    expect(result).toContain('## Checkbox');
  });

  it('should use fallback description when not provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [button](#button) - [Full Docs](./button/page.mdx)');
  });

  it('should handle pages without images', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('![');
    expect(result).toContain('## Button');
    expect(result).toContain('A button component.');
  });

  it('should handle pages without keywords', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('Keywords:');
  });

  it('should include description below title', () => {
    const data: PagesMetadata = {
      title: 'Components',
      description: 'A collection of reusable UI components.',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('# Components\n\nA collection of reusable UI components.');
  });

  it('should include default metadata export at the end', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain(
      "[//]: # 'This file is autogenerated, but the following metadata can be modified.'",
    );
    expect(result).toContain('export const metadata = {\n  robots: {\n    index: false,\n  },\n}');
  });

  it('should include custom metadata export when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
      pageMetadata: {
        robots: {
          index: true,
        },
        customField: 'customValue',
      },
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('export const metadata = {');
    expect(result).toContain('"robots"');
    expect(result).toContain('"index": true');
    expect(result).toContain('"customField": "customValue"');
  });

  it('should wrap content in component when indexWrapperComponent is provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data, { indexWrapperComponent: 'PagesIndex' });

    expect(result).toContain('<PagesIndex>');
    expect(result).toContain('</PagesIndex>');
    // Ensure wrapper is around the content (between editable marker and metadata marker)
    const openingTagIndex = result.indexOf('<PagesIndex>');
    const closingTagIndex = result.indexOf('</PagesIndex>');
    const metadataMarkerIndex = result.indexOf('following metadata can be modified');
    expect(openingTagIndex).toBeLessThan(closingTagIndex);
    expect(closingTagIndex).toBeLessThan(metadataMarkerIndex);
  });

  it('should not include wrapper component when indexWrapperComponent is not provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('<PagesIndex>');
    expect(result).not.toContain('</PagesIndex>');
  });
});

describe('metadataToMarkdownAst', () => {
  it('should convert page metadata to markdown AST', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    expect(result.type).toBe('root');
    expect(result.children).toHaveLength(9); // H1, comment, list, comment, H2, description, read more, comment, metadata

    // Check H1
    expect(result.children[0]).toMatchObject({
      type: 'heading',
      depth: 1,
      children: [{ type: 'text', value: 'Components' }],
    });

    // Check list - new format: - [Title](#slug) - [Full Docs](./path)
    const list = result.children[2] as any;
    expect(list.type).toBe('list');
    expect(list.ordered).toBe(false);
    expect(list.children).toHaveLength(1); // One list item

    const listItem = list.children[0];
    expect(listItem.type).toBe('listItem');
    expect(listItem.children).toHaveLength(1); // One paragraph in the list item

    const paragraph = listItem.children[0];
    expect(paragraph.type).toBe('paragraph');
    expect(paragraph.children[0].type).toBe('link');
    expect(paragraph.children[0].url).toBe('#button'); // Link to section
    expect(paragraph.children[0].children[0].value).toBe('Button'); // Link text
    expect(paragraph.children[1].value).toBe(' - '); // Separator
    expect(paragraph.children[2].type).toBe('link');
    expect(paragraph.children[2].url).toBe('./button/page.mdx'); // Link to full docs
    expect(paragraph.children[2].children[0].value).toBe('Full Docs'); // Link text

    // Check H2
    const h2 = result.children[4] as any;
    expect(h2.type).toBe('heading');
    expect(h2.depth).toBe(2);
  });

  it('should include images in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          image: {
            url: 'https://example.com/button.png',
            alt: 'Button image',
          },
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the image node
    const imageNode = result.children.find(
      (child: any) =>
        child.type === 'paragraph' &&
        child.children &&
        child.children.some((c: any) => c.type === 'image'),
    ) as any;

    expect(imageNode).toBeDefined();
    expect(imageNode.children[0].type).toBe('image');
    expect(imageNode.children[0].url).toBe('https://example.com/button.png');
    expect(imageNode.children[0].alt).toBe('Button image');
  });

  it('should include keywords in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input', 'form'],
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the metadata list containing keywords (this is the second list in the document)
    const allLists = result.children.filter((child: any) => child.type === 'list') as any[];
    const metadataList = allLists[1]; // The first list is the editable page list, the second is the detail metadata

    expect(metadataList).toBeDefined();

    // Find the keywords list item
    const keywordItem = metadataList.children.find(
      (item: any) =>
        item.type === 'listItem' && item.children[0]?.children[0]?.value?.includes('Keywords:'),
    ) as any;

    expect(keywordItem).toBeDefined();
    expect(keywordItem.children[0].children[0].value).toContain('interactive, input, form');
  });
});

describe('markdownToMetadata', () => {
  it('should parse markdown string back to metadata', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

![A simple button](https://example.com/button.png)

<details>

<summary>Outline</summary>

- Keywords: interactive, input

</details>

[//]: # 'Embeddings: [0.1,0.2,0.3]'

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.title).toBe('Components');
    expect(result?.pages).toHaveLength(1);

    const page = result?.pages[0];
    expect(page?.slug).toBe('button');
    expect(page?.path).toBe('./button/page.mdx');
    expect(page?.title).toBe('Button');
    expect(page?.description).toBe('A button component.');
    expect(page?.keywords).toEqual(['interactive', 'input']);
    expect(page?.embeddings).toEqual([0.1, 0.2, 0.3]);
    expect(page?.image?.url).toBe('https://example.com/button.png');
    expect(page?.image?.alt).toBe('A simple button');
  });

  it('should parse multiple pages', async () => {
    const markdown = `# UI Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)
- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);
    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('checkbox');
  });

  it('should handle pages without images', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0]?.image).toBeUndefined();
  });

  it('should handle pages without keywords', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].keywords).toBeUndefined();
  });

  it('should return null when no title is found', async () => {
    const markdown = `
- [Button](#button) - [Full Docs](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeNull();
  });

  it('should extract slug from path correctly', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)
- [Nested Component](#nested-component) - [Full Docs](./nested/component/page.mdx)
- [Simple](#simple) - [Full Docs](./simple.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Nested Component

A nested component.

[Read more](./nested/component/page.mdx)

## Simple

Simple component.

[Read more](./simple.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('nested-component');
    expect(result?.pages[2].slug).toBe('simple');
  });

  it('should generate slugs that preserve camelCase as lowercase', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#myfunction) - [Full Docs](./my-function/page.mdx)
- [My Component](#my-component) - [Full Docs](./my-component/page.mdx)
- [Product\u00a0Name](#productname) - [Full Docs](./product-name/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

A simple function utility.

[Read more](./my-function/page.mdx)

## My Component

A multi-word component.

[Read more](./my-component/page.mdx)

## Product\u00a0Name

A title with non-breaking space.

[Read more](./product-name/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    // camelCase titles should become all lowercase (no hyphens inserted)
    expect(result?.pages[0].slug).toBe('myfunction');
    expect(result?.pages[0].title).toBe('myFunction');

    // Multi-word titles with regular spaces should use hyphens
    expect(result?.pages[1].slug).toBe('my-component');
    expect(result?.pages[1].title).toBe('My Component');

    // Titles with non-breaking spaces should have them removed (not converted to hyphens)
    expect(result?.pages[2].slug).toBe('productname');
    expect(result?.pages[2].title).toBe('Product\u00a0Name');
  });
  it('should merge data from editable and detail sections', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A more detailed button component description.

![Button image](https://example.com/button.png)

<details>

<summary>Outline</summary>

- Keywords: interactive, clickable

</details>

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    const page = result?.pages[0];
    // Detail section should override editable section
    expect(page?.description).toBe('A more detailed button component description.');
    expect(page?.keywords).toEqual(['interactive', 'clickable']);
    expect(page?.image?.url).toBe('https://example.com/button.png');
  });

  it('should correctly parse actual generated markdown format', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#my-function) - [Full Docs](./my-function/page.mdx)
- [anotherFunction](#another-function) - [Full Docs](./another-function/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function that provides essential functionality for the application.

[Read more](./my-function/page.mdx)

## anotherFunction

The anotherFunction utility handles data processing with advanced features.

[Read more](./another-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);

    const firstPage = result?.pages[0];
    expect(firstPage?.slug).toBe('my-function');
    expect(firstPage?.title).toBe('myFunction');
    expect(firstPage?.description).toBe(
      'The myFunction utility is a helper function that provides essential functionality for the application.',
    );

    const secondPage = result?.pages[1];
    expect(secondPage?.slug).toBe('another-function');
    expect(secondPage?.title).toBe('anotherFunction');
    expect(secondPage?.description).toBe(
      'The anotherFunction utility handles data processing with advanced features.',
    );
  });

  it('should handle titles with inline code formatting', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#my-function) - [Full Docs](./my-function/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function.

[Read more](./my-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('my-function');
    expect(page?.title).toBe('myFunction');
    expect(page?.description).toBe('The myFunction utility is a helper function.');
  });

  it('should replace newlines with spaces in descriptions', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Example Component](#example-component) - [Full Docs](./example-component/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Example Component

The Example Component provides a powerful and
flexible way to display content with multiple features and options.
It supports both basic usage and advanced scenarios with custom configurations.

[Read more](./example-component/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('example-component');
    expect(page?.title).toBe('Example Component');
    // Newlines should be replaced with spaces
    expect(page?.description).toBe(
      'The Example Component provides a powerful and flexible way to display content with multiple features and options. It supports both basic usage and advanced scenarios with custom configurations.',
    );
  });

  it('should preserve non-breaking spaces in descriptions', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Base UI](#base-ui) - [Full Docs](./base-ui/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Base UI

Base\u00a0UI is a library of unstyled React components.

[Read more](./base-ui/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    // Non-breaking spaces should be preserved in descriptions
    expect(page?.description).toBe('Base\u00a0UI is a library of unstyled React components.');
  });

  it('should preserve inline code in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Code Highlighter](#code-highlighter) - [Full Docs](./code-highlighter/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Code Highlighter

The \`CodeHighlighter\` component provides syntax highlighting.

[Read more](./code-highlighter/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve inline code
    expect(page?.description).toBe('The `CodeHighlighter` component provides syntax highlighting.');

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toEqual([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'CodeHighlighter' },
      { type: 'text', value: ' component provides syntax highlighting.' },
    ]);
  });

  it('should preserve links in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [useErrors](#use-errors) - [Full Docs](./use-errors/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## useErrors

The \`useErrors\` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.

[Read more](./use-errors/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve links and inline code
    expect(page?.description).toBe(
      'The `useErrors` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.',
    );

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toMatchObject([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'useErrors' },
      { type: 'text', value: ' hook implements the ' },
      {
        type: 'link',
        url: '../../patterns/props-context-layering/page.mdx',
        children: [{ type: 'text', value: 'Props Context Layering pattern' }],
      },
      { type: 'text', value: ' for error handling.' },
    ]);
  });

  it('should preserve formatting through round-trip with inline code', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'code-highlighter',
          path: './code-highlighter/page.mdx',
          title: 'Code Highlighter',
          description: 'The `CodeHighlighter` component provides syntax highlighting.',
          descriptionMarkdown: [
            { type: 'text', value: 'The ' },
            { type: 'inlineCode', value: 'CodeHighlighter' },
            { type: 'text', value: ' component provides syntax highlighting.' },
          ],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);

    // The markdown should contain backticks
    expect(markdown).toContain('The `CodeHighlighter` component provides syntax highlighting.');

    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].descriptionMarkdown).toEqual(original.pages[0].descriptionMarkdown);
  });

  it('should parse description below title', async () => {
    const markdown = `# Components

A collection of reusable UI components.

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

[//]: # 'This file is autogenerated, but the following metadata can be modified.'

export const metadata = {
  robots: {
    index: false,
  },
}
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.title).toBe('Components');
    expect(result?.description).toBe('A collection of reusable UI components.');
  });

  it('should parse custom metadata export', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

[//]: # 'This file is autogenerated, but the following metadata can be modified.'

export const metadata = {
  robots: {
    index: true,
  },
  customField: "customValue",
}
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.pageMetadata).toBeDefined();
    expect(result?.pageMetadata?.robots).toEqual({ index: true });
    expect(result?.pageMetadata?.customField).toBe('customValue');
  });

  it('should parse default metadata export', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

[//]: # 'This file is autogenerated, but the following metadata can be modified.'

export const metadata = {
  robots: {
    index: false,
  },
}
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.pageMetadata).toBeDefined();
    expect(result?.pageMetadata?.robots).toEqual({ index: false });
  });

  it('should parse indexWrapperComponent from HTML tags', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

<PagesIndex>

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

</PagesIndex>

[//]: # 'This file is autogenerated, but the following metadata can be modified.'

export const metadata = {
  robots: {
    index: false,
  },
}
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.indexWrapperComponent).toBe('PagesIndex');
  });

  it('should return undefined indexWrapperComponent when no wrapper exists', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

[//]: # 'This file is autogenerated, but the following metadata can be modified.'

export const metadata = {
  robots: {
    index: false,
  },
}
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.indexWrapperComponent).toBeUndefined();
  });
});

describe('round-trip conversion', () => {
  it('should maintain data integrity through conversion cycle', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          embeddings: [0.1, 0.2, 0.3, 0.4, 0.5],
          image: {
            url: 'https://example.com/button.png',
            alt: 'Button image',
          },
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
          keywords: ['form', 'input'],
          embeddings: [0.6, 0.7, 0.8],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toHaveLength(original.pages.length);

    // Check first component
    expect(parsed?.pages[0].slug).toBe(original.pages[0].slug);
    expect(parsed?.pages[0].path).toBe(original.pages[0].path);
    expect(parsed?.pages[0].title).toBe(original.pages[0].title);
    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].keywords).toEqual(original.pages[0].keywords);
    expect(parsed?.pages[0].embeddings).toEqual(original.pages[0].embeddings);
    expect(parsed?.pages[0].image?.url).toBe(original.pages[0].image?.url);

    // Check second component
    expect(parsed?.pages[1].slug).toBe(original.pages[1].slug);
    expect(parsed?.pages[1].keywords).toEqual(original.pages[1].keywords);
    expect(parsed?.pages[1].embeddings).toEqual(original.pages[1].embeddings);
  });

  it('should preserve description and pageMetadata through round-trip', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      description: 'A collection of reusable UI components.',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
      pageMetadata: {
        robots: {
          index: true,
        },
        customField: 'customValue',
      },
    };

    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.title).toBe(original.title);
    expect(parsed?.description).toBe(original.description);
    expect(parsed?.pageMetadata).toEqual(original.pageMetadata);
  });

  it('should handle empty pages array', async () => {
    const original: PagesMetadata = {
      title: 'Empty Components',
      pages: [],
    };

    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toEqual([]);
  });

  it('should preserve sections through round-trip conversion', async () => {
    const original: PagesMetadata = {
      title: 'Functions',
      pages: [
        {
          slug: 'my-function',
          path: './my-function/page.mdx',
          title: 'My Function',
          description: 'An example function.',
          sections: {
            overview: {
              title: 'Overview',
              titleMarkdown: [{ type: 'text', value: 'Overview' }],
              children: {},
            },
            api: {
              title: 'API',
              titleMarkdown: [{ type: 'text', value: 'API' }],
              children: {
                parameters: {
                  title: 'Parameters',
                  titleMarkdown: [{ type: 'text', value: 'Parameters' }],
                  children: {},
                },
                'return-value': {
                  title: 'Return Value',
                  titleMarkdown: [{ type: 'text', value: 'Return Value' }],
                  children: {},
                },
              },
            },
            examples: {
              title: 'Examples',
              titleMarkdown: [{ type: 'text', value: 'Examples' }],
              children: {
                'basic-usage': {
                  title: 'Basic Usage',
                  titleMarkdown: [{ type: 'text', value: 'Basic Usage' }],
                  children: {},
                },
              },
            },
          },
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.pages).toHaveLength(1);
    expect(parsed?.pages[0].sections).toBeDefined();
    expect(parsed?.pages[0].sections).toEqual(original.pages[0].sections);
  });

  it('should handle sections with numbered titles correctly', async () => {
    const markdown = `# Patterns

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Props Context Layering](#props-context-layering) - [Full Docs](./props-context-layering/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Props Context Layering

A pattern for isomorphic components.

<details>

<summary>Outline</summary>

- Sections:
  - Server-Client Boundary Constraints
  - 1\\. Early rendering with fallback values
  - 2\\. Conditional async operations
  - 3\\. Props-first, context-enhanced hooks
  - 4\\. Lazy-load heavy functions
  - Implementation Checklist
  - Real-World Usage

</details>

[Read more](./props-context-layering/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.sections).toBeDefined();

    // Should have all 7 sections
    expect(Object.keys(page?.sections || {})).toEqual([
      'server-client-boundary-constraints',
      '1-early-rendering-with-fallback-values',
      '2-conditional-async-operations',
      '3-props-first-context-enhanced-hooks',
      '4-lazy-load-heavy-functions',
      'implementation-checklist',
      'real-world-usage',
    ]);

    // Check that numbered sections are properly parsed
    expect(page?.sections?.['1-early-rendering-with-fallback-values']).toEqual({
      title: '1. Early rendering with fallback values',
      titleMarkdown: [{ type: 'text', value: '1. Early rendering with fallback values' }],
      children: {},
    });

    expect(page?.sections?.['2-conditional-async-operations']).toEqual({
      title: '2. Conditional async operations',
      titleMarkdown: [{ type: 'text', value: '2. Conditional async operations' }],
      children: {},
    });
  });

  describe('tags support', () => {
    it('should serialize tags after Full Docs link', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
            tags: ['New', 'Hot'],
          },
          {
            slug: 'checkbox',
            path: './checkbox/page.mdx',
            title: 'Checkbox',
            description: 'A checkbox component.',
            tags: ['Beta'],
          },
        ],
      };

      const result = metadataToMarkdown(data);

      expect(result).toContain('- [Button](#button) [New] [Hot] - [Full Docs](./button/page.mdx)');
      expect(result).toContain('- [Checkbox](#checkbox) [Beta] - [Full Docs](./checkbox/page.mdx)');
    });

    it('should parse tags from markdown', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) [New] [Hot] - [Full Docs](./button/page.mdx)
- [Checkbox](#checkbox) [Beta] - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages[0].tags).toEqual(['New', 'Hot']);
      expect(result?.pages[1].tags).toEqual(['Beta']);
    });

    it('should handle pages without tags', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
          },
          {
            slug: 'checkbox',
            path: './checkbox/page.mdx',
            title: 'Checkbox',
            description: 'A checkbox component.',
            tags: ['New'],
          },
        ],
      };

      const result = metadataToMarkdown(data);

      expect(result).toContain('- [Button](#button) - [Full Docs](./button/page.mdx)\n');
      expect(result).toContain('- [Checkbox](#checkbox) [New] - [Full Docs](./checkbox/page.mdx)');
    });

    it('should serialize tags in AST format', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
            tags: ['New', 'Hot'],
          },
        ],
      };

      const ast = metadataToMarkdownAst(data);

      // Find the list
      const list = ast.children.find((node) => node.type === 'list');
      expect(list).toBeDefined();

      // Check the list item
      const listItem = (list as any).children[0];
      const paragraph = listItem.children[0];

      // Should have: link (title), text (' [New]'), text (' [Hot]'), text (' - '), link (full docs)
      expect(paragraph.children.length).toBe(5);
      expect(paragraph.children[0].type).toBe('link'); // Title link
      expect(paragraph.children[1].type).toBe('text');
      expect(paragraph.children[1].value).toBe(' [New]');
      expect(paragraph.children[2].type).toBe('text');
      expect(paragraph.children[2].value).toBe(' [Hot]');
      expect(paragraph.children[3].type).toBe('text');
      expect(paragraph.children[3].value).toBe(' - ');
      expect(paragraph.children[4].type).toBe('link'); // Full Docs link
    });

    it('should parse multiple tags from a single text node', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) [New] [Hot] [Beta] - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages[0].tags).toEqual(['New', 'Hot', 'Beta']);
    });

    it('should ignore tags in the detailed section', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) [New] - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component. [Hot] [Beta]

[Read more](./button/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      // Should only parse tags from the editable list, not from descriptions
      expect(result?.pages[0].tags).toEqual(['New']);
    });

    it('should handle single-link entries (external links)', async () => {
      const markdown = `# Handbook

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Forms](#forms) - [Full Docs](./forms/page.mdx)
- [llms.txt](/llms.txt)
- [TypeScript](#typescript) - [Full Docs](./typescript/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Forms

A guide to building forms.

[Read more](./forms/page.mdx)

## TypeScript

A guide to using TypeScript.

[Read more](./typescript/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages).toHaveLength(3);

      // First entry is a regular page
      expect(result?.pages[0].slug).toBe('forms');
      expect(result?.pages[0].skipDetailSection).toBeUndefined();

      // Second entry is a single-link (external)
      expect(result?.pages[1].title).toBe('llms.txt');
      expect(result?.pages[1].path).toBe('/llms.txt');
      expect(result?.pages[1].slug).toBe('llms-txt'); // Dots are converted to hyphens
      expect(result?.pages[1].skipDetailSection).toBe(true);

      // Third entry is a regular page
      expect(result?.pages[2].slug).toBe('typescript');
      expect(result?.pages[2].skipDetailSection).toBeUndefined();
    });

    it('should serialize single-link entries without detail sections', () => {
      const data: PagesMetadata = {
        title: 'Handbook',
        pages: [
          {
            slug: 'forms',
            path: './forms/page.mdx',
            title: 'Forms',
            description: 'A guide to building forms.',
          },
          {
            slug: 'llms-txt', // Dots are converted to hyphens
            path: '/llms.txt',
            title: 'llms.txt',
            description: 'No description available',
            skipDetailSection: true,
          },
          {
            slug: 'typescript',
            path: './typescript/page.mdx',
            title: 'TypeScript',
            description: 'A guide to using TypeScript.',
          },
        ],
      };

      const result = metadataToMarkdown(data);

      // Single-link entry should be serialized as: - [Title](./path)
      expect(result).toContain('- [llms.txt](/llms.txt)');
      // Regular entries should have both links
      expect(result).toContain('- [Forms](#forms) - [Full Docs](./forms/page.mdx)');
      expect(result).toContain('- [TypeScript](#typescript) - [Full Docs](./typescript/page.mdx)');

      // Single-link entry should NOT have a detail section
      expect(result).not.toContain('## llms.txt');
      // Regular entries should have detail sections
      expect(result).toContain('## Forms');
      expect(result).toContain('## TypeScript');
    });

    it('should handle tags in single-link entries', async () => {
      const markdown = `# Handbook

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Forms](#forms) - [Full Docs](./forms/page.mdx)
- [llms.txt](/llms.txt) [External]
- [API Reference](/api) [External] [New]

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Forms

A guide to building forms.

[Read more](./forms/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages).toHaveLength(3);

      // First entry is a regular page with no tags
      expect(result?.pages[0].slug).toBe('forms');
      expect(result?.pages[0].tags).toBeUndefined();
      expect(result?.pages[0].skipDetailSection).toBeUndefined();

      // Second entry is a single-link with one tag
      expect(result?.pages[1].title).toBe('llms.txt');
      expect(result?.pages[1].path).toBe('/llms.txt');
      expect(result?.pages[1].tags).toEqual(['External']);
      expect(result?.pages[1].skipDetailSection).toBe(true);

      // Third entry is a single-link with multiple tags
      expect(result?.pages[2].title).toBe('API Reference');
      expect(result?.pages[2].path).toBe('/api');
      expect(result?.pages[2].tags).toEqual(['External', 'New']);
      expect(result?.pages[2].skipDetailSection).toBe(true);
    });

    it('should serialize single-link entries with tags', () => {
      const data: PagesMetadata = {
        title: 'Handbook',
        pages: [
          {
            slug: 'forms',
            path: './forms/page.mdx',
            title: 'Forms',
            description: 'A guide to building forms.',
          },
          {
            slug: 'llms-txt',
            path: '/llms.txt',
            title: 'llms.txt',
            description: 'No description available',
            tags: ['External'],
            skipDetailSection: true,
          },
          {
            slug: 'api-reference',
            path: '/api',
            title: 'API Reference',
            description: 'No description available',
            tags: ['External', 'New'],
            skipDetailSection: true,
          },
        ],
      };

      const result = metadataToMarkdown(data);

      // Single-link entries should be serialized with tags: - [Title](./path) [Tag1] [Tag2]
      expect(result).toContain('- [llms.txt](/llms.txt) [External]');
      expect(result).toContain('- [API Reference](/api) [External] [New]');
      // Regular entry should have both links but no tags
      expect(result).toContain('- [Forms](#forms) - [Full Docs](./forms/page.mdx)');

      // Single-link entries should NOT have detail sections
      expect(result).not.toContain('## llms.txt');
      expect(result).not.toContain('## API Reference');
      // Regular entry should have detail section
      expect(result).toContain('## Forms');
    });
  });

  describe('exports support', () => {
    it('should serialize exports with all properties', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
            parts: {
              Root: {
                props: ['className', 'disabled', 'onClick'],
                dataAttributes: ['data-active', 'data-disabled'],
                cssVariables: ['--button-bg', '--button-color'],
              },
              Icon: {
                props: ['size', 'color'],
              },
            },
          },
        ],
      };

      const result = metadataToMarkdown(data);

      // Check that exports are listed with dash separator
      expect(result).toContain('- Exports:');
      expect(result).toContain('  - Button - Root');
      expect(result).toContain('    - Props: className, disabled, onClick');
      expect(result).toContain('    - Data Attributes: data-active, data-disabled');
      expect(result).toContain('    - CSS Variables: --button-bg, --button-color');
      expect(result).toContain('  - Button - Icon');
      expect(result).toContain('    - Props: size, color');
    });

    it('should serialize exports with only some properties', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'checkbox',
            path: './checkbox/page.mdx',
            title: 'Checkbox',
            description: 'A checkbox component.',
            parts: {
              Root: {
                props: ['checked', 'onChange'],
                dataAttributes: ['data-checked'],
              },
              Indicator: {
                cssVariables: ['--indicator-size'],
              },
            },
          },
        ],
      };

      const result = metadataToMarkdown(data);

      expect(result).toContain('- Exports:');
      expect(result).toContain('  - Checkbox - Root');
      expect(result).toContain('    - Props: checked, onChange');
      expect(result).toContain('    - Data Attributes: data-checked');
      // Root should not have CSS Variables line
      const lines = result.split('\n');
      const rootIndex = lines.findIndex((l) => l.includes('Checkbox - Root'));
      const indicatorIndex = lines.findIndex((l) => l.includes('Checkbox - Indicator'));
      const rootSection = lines.slice(rootIndex, indicatorIndex).join('\n');
      expect(rootSection).not.toContain('CSS Variables');
      // Indicator should have CSS Variables
      expect(result).toContain('  - Checkbox - Indicator');
      expect(result).toContain('    - CSS Variables: --indicator-size');
      // Indicator should not have Props or Data Attributes
      const indicatorSection = lines.slice(indicatorIndex, indicatorIndex + 3).join('\n');
      expect(indicatorSection).not.toContain('Props:');
      expect(indicatorSection).not.toContain('Data Attributes:');
    });

    it('should parse exports from markdown with all properties', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

<details>

<summary>Outline</summary>

- Exports:
  - Button - Root
    - Props: className, disabled, onClick
    - Data Attributes: data-active, data-disabled
    - CSS Variables: --button-bg, --button-color
  - Button - Icon
    - Props: size, color

</details>

[Read more](./button/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages).toHaveLength(1);
      expect(result?.pages[0].parts).toBeDefined();
      expect(result?.pages[0].parts).toEqual({
        Root: {
          props: ['className', 'disabled', 'onClick'],
          dataAttributes: ['data-active', 'data-disabled'],
          cssVariables: ['--button-bg', '--button-color'],
        },
        Icon: {
          props: ['size', 'color'],
        },
      });
    });

    it('should parse exports with only some properties', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

<details>

<summary>Outline</summary>

- Exports:
  - Checkbox - Root
    - Props: checked, onChange
    - Data Attributes: data-checked
  - Checkbox - Indicator
    - CSS Variables: --indicator-size

</details>

[Read more](./checkbox/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      expect(result?.pages[0].parts).toEqual({
        Root: {
          props: ['checked', 'onChange'],
          dataAttributes: ['data-checked'],
        },
        Indicator: {
          cssVariables: ['--indicator-size'],
        },
      });
    });

    it('should handle exports alongside sections and keywords', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Accordion](#accordion) - [Full Docs](./accordion/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Accordion

An accordion component.

<details>

<summary>Outline</summary>

- Keywords: collapsible, expandable
- Sections:
  - Overview
  - Examples
- Exports:
  - Accordion - Root
    - Props: defaultValue, multiple
  - Accordion - Item
    - Props: value, disabled

</details>

[Read more](./accordion/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      const page = result?.pages[0];
      expect(page?.keywords).toEqual(['collapsible', 'expandable']);
      expect(page?.sections).toBeDefined();
      expect(Object.keys(page?.sections || {})).toEqual(['overview', 'examples']);
      expect(page?.parts).toEqual({
        Root: {
          props: ['defaultValue', 'multiple'],
        },
        Item: {
          props: ['value', 'disabled'],
        },
      });
    });

    it('should preserve exports through round-trip conversion', async () => {
      const original: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'dialog',
            path: './dialog/page.mdx',
            title: 'Dialog',
            description: 'A dialog component.',
            parts: {
              Root: {
                props: ['open', 'onOpenChange'],
              },
              Trigger: {
                props: ['disabled'],
                dataAttributes: ['data-state'],
              },
              Portal: {
                props: ['container'],
              },
              Backdrop: {
                cssVariables: ['--backdrop-opacity'],
              },
            },
          },
        ],
      };

      const markdown = metadataToMarkdown(original);
      const parsed = await markdownToMetadata(markdown);

      expect(parsed?.pages[0].exports).toEqual(original.pages[0].exports);
    });

    it('should not include empty properties in serialized output', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
            parts: {
              Root: {
                props: ['className'],
              },
            },
          },
        ],
      };

      const result = metadataToMarkdown(data);

      // Should only show Props, not Data Attributes or CSS Variables
      expect(result).toContain('  - Button - Root');
      expect(result).toContain('    - Props: className');
      expect(result).not.toContain('Data Attributes:');
      expect(result).not.toContain('CSS Variables:');
    });

    it('should handle multiple parts with varying properties', async () => {
      const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Menu](#menu) - [Full Docs](./menu/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Menu

A menu component.

<details>

<summary>Outline</summary>

- Exports:
  - Menu - Root
    - Props: open, onOpenChange
  - Menu - Item
    - Props: disabled, onClick
    - Data Attributes: data-highlighted
  - Menu - Separator
  - Menu - Arrow
    - CSS Variables: --arrow-size

</details>

[Read more](./menu/page.mdx)
`;

      const result = await markdownToMetadata(markdown);

      expect(result).not.toBeNull();
      // Parts with no properties (like Separator) are preserved
      expect(result?.pages[0].parts).toEqual({
        Root: {
          props: ['open', 'onOpenChange'],
        },
        Item: {
          props: ['disabled', 'onClick'],
          dataAttributes: ['data-highlighted'],
        },
        Arrow: {
          cssVariables: ['--arrow-size'],
        },
        Separator: {},
      });
    });

    it('should serialize exports in AST format with dash separator', () => {
      const data: PagesMetadata = {
        title: 'Components',
        pages: [
          {
            slug: 'button',
            path: './button/page.mdx',
            title: 'Button',
            description: 'A button component.',
            parts: {
              Root: {
                props: ['className', 'disabled'],
              },
            },
          },
        ],
      };

      const ast = metadataToMarkdownAst(data);

      // Find the exports list in the detail section
      const lists = ast.children.filter((node) => node.type === 'list') as any[];
      const metadataList = lists[1]; // The second list should be the metadata list

      expect(metadataList).toBeDefined();

      // Find the exports list item
      const exportsItem = metadataList.children.find(
        (item: any) =>
          item.type === 'listItem' && item.children[0]?.children[0]?.value?.includes('Exports:'),
      ) as any;

      expect(exportsItem).toBeDefined();

      // Check the nested exports list
      const exportsList = exportsItem.children.find((child: any) => child.type === 'list');
      expect(exportsList).toBeDefined();

      // Check the part name uses dash separator
      const partItem = exportsList.children[0];
      const partParagraph = partItem.children[0];
      expect(partParagraph.type).toBe('paragraph');
      expect(partParagraph.children[0].type).toBe('text');
      expect(partParagraph.children[0].value).toBe('Button - Root');
    });

    describe('exports field (without component prefix)', () => {
      it('should serialize exports field with just export names', () => {
        const data: PagesMetadata = {
          title: 'Components',
          pages: [
            {
              slug: 'checkbox',
              path: './checkbox/page.mdx',
              title: 'Checkbox',
              description: 'A checkbox component.',
              exports: {
                Root: {
                  props: ['checked', 'className', 'disabled'],
                  dataAttributes: ['data-checked', 'data-disabled'],
                },
                Indicator: {
                  props: ['className'],
                  dataAttributes: ['data-checked'],
                },
              },
            },
          ],
        };

        const result = metadataToMarkdown(data);

        // Check that exports are listed without component name prefix
        expect(result).toContain('- Exports:');
        expect(result).toContain('  - Root');
        expect(result).toContain('    - Props: checked, className, disabled');
        expect(result).toContain('    - Data Attributes: data-checked, data-disabled');
        expect(result).toContain('  - Indicator');
        expect(result).toContain('    - Props: className');
        expect(result).toContain('    - Data Attributes: data-checked');
      });

      it('should serialize parts and exports separately', () => {
        const data: PagesMetadata = {
          title: 'Components',
          pages: [
            {
              slug: 'checkbox',
              path: './checkbox/page.mdx',
              title: 'Checkbox',
              description: 'A checkbox component.',
              parts: {
                Root: {
                  props: ['checked', 'onChange'],
                  dataAttributes: ['data-checked'],
                },
                Indicator: {
                  cssVariables: ['--indicator-size'],
                },
              },
              exports: {
                Checkbox: {
                  props: ['className', 'disabled'],
                  dataAttributes: ['data-disabled'],
                },
              },
            },
          ],
        };

        const result = metadataToMarkdown(data);

        // Parts should be listed with component name prefix and metadata
        expect(result).toContain('- Exports:');
        expect(result).toContain('  - Checkbox - Root');
        expect(result).toContain('    - Props: checked, onChange');
        expect(result).toContain('    - Data Attributes: data-checked');
        expect(result).toContain('  - Checkbox - Indicator');
        expect(result).toContain('    - CSS Variables: --indicator-size');
        // Exports should be listed with just the export name (no prefix)
        expect(result).toContain('  - Checkbox');
        expect(result).toContain('    - Props: className, disabled');
        expect(result).toContain('    - Data Attributes: data-disabled');
      });

      it('should parse exports field from markdown', async () => {
        const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

<details>

<summary>Outline</summary>

- Exports:
  - Root
    - Props: checked, onChange
    - Data Attributes: data-checked
  - Indicator
    - CSS Variables: --indicator-size

</details>

[Read more](./checkbox/page.mdx)
`;

        const result = await markdownToMetadata(markdown);

        expect(result).not.toBeNull();
        expect(result?.pages[0].exports).toEqual({
          Root: {
            props: ['checked', 'onChange'],
            dataAttributes: ['data-checked'],
          },
          Indicator: {
            cssVariables: ['--indicator-size'],
          },
        });
      });

      it('should parse combined parts and exports from markdown', async () => {
        const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

<details>

<summary>Outline</summary>

- Exports:
  - Checkbox - Root
    - Props: checked, onChange
    - Data Attributes: data-checked
  - Checkbox - Indicator
    - CSS Variables: --indicator-size
  - Checkbox
    - Props: className, disabled
    - Data Attributes: data-disabled

</details>

[Read more](./checkbox/page.mdx)
`;

        const result = await markdownToMetadata(markdown);

        expect(result).not.toBeNull();
        expect(result?.pages[0].parts).toEqual({
          Root: {
            props: ['checked', 'onChange'],
            dataAttributes: ['data-checked'],
          },
          Indicator: {
            cssVariables: ['--indicator-size'],
          },
        });
        expect(result?.pages[0].exports).toEqual({
          Checkbox: {
            props: ['className', 'disabled'],
            dataAttributes: ['data-disabled'],
          },
        });
      });

      it('should preserve exports through round-trip conversion', async () => {
        const original: PagesMetadata = {
          title: 'Components',
          pages: [
            {
              slug: 'button',
              path: './button/page.mdx',
              title: 'Button',
              description: 'A button component.',
              exports: {
                Root: {
                  props: ['className', 'disabled'],
                  dataAttributes: ['data-active'],
                },
                Icon: {
                  props: ['size'],
                },
              },
            },
          ],
        };

        const markdown = metadataToMarkdown(original);
        const parsed = await markdownToMetadata(markdown);

        expect(parsed?.pages[0].exports).toEqual(original.pages[0].exports);
      });

      it('should handle exports in AST format', () => {
        const data: PagesMetadata = {
          title: 'Components',
          pages: [
            {
              slug: 'button',
              path: './button/page.mdx',
              title: 'Button',
              description: 'A button component.',
              exports: {
                Root: {
                  props: ['className', 'disabled'],
                },
              },
            },
          ],
        };

        const ast = metadataToMarkdownAst(data);

        // Find the exports list in the detail section
        const lists = ast.children.filter((node) => node.type === 'list') as any[];
        const metadataList = lists[1]; // The second list should be the metadata list

        expect(metadataList).toBeDefined();

        // Find the exports list item
        const exportsItem = metadataList.children.find(
          (item: any) =>
            item.type === 'listItem' && item.children[0]?.children[0]?.value?.includes('Exports:'),
        ) as any;

        expect(exportsItem).toBeDefined();

        // Check the nested exports list
        const exportsList = exportsItem.children.find((child: any) => child.type === 'list');
        expect(exportsList).toBeDefined();

        // Check the export name is just "Root" (no component prefix)
        const exportItem = exportsList.children[0];
        const exportParagraph = exportItem.children[0];
        expect(exportParagraph.type).toBe('paragraph');
        expect(exportParagraph.children[0].type).toBe('text');
        expect(exportParagraph.children[0].value).toBe('Root');
      });

      it('should handle empty exports objects', () => {
        const data: PagesMetadata = {
          title: 'Components',
          pages: [
            {
              slug: 'separator',
              path: './separator/page.mdx',
              title: 'Separator',
              description: 'A separator component.',
              exports: {
                Root: {},
              },
            },
          ],
        };

        const result = metadataToMarkdown(data);

        // Should list the export name even without properties
        expect(result).toContain('- Exports:');
        expect(result).toContain('  - Root');
        expect(result).not.toContain('Props:');
        expect(result).not.toContain('Data Attributes:');
        expect(result).not.toContain('CSS Variables:');
      });
    });
  });
});
