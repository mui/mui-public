import { describe, it, expect } from 'vitest';
import type { ComponentTypeMeta, HookTypeMeta, TypesMeta } from './loadPrecomputedTypesMeta';
import { generateTypesMarkdown } from './generateTypesMarkdown';

// Helper to create HAST from text
function textToHast(text: string) {
  return {
    type: 'root' as const,
    children: [
      {
        type: 'element' as const,
        tagName: 'p',
        properties: {},
        children: [{ type: 'text' as const, value: text }],
      },
    ],
  };
}

// Helper to create HAST code
function codeToHast(code: string) {
  return {
    type: 'root' as const,
    children: [
      {
        type: 'element' as const,
        tagName: 'code',
        properties: {},
        children: [{ type: 'text' as const, value: code }],
      },
    ],
  };
}

describe('generateTypesMarkdown', () => {
  describe('component type generation', () => {
    it('should generate markdown for a basic component without description', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown('Button API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button
        "
      `);
    });

    it('should generate markdown for component with HAST description', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        description: textToHast('A clickable button component'),
        descriptionText: 'A clickable button component',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown('Button API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        A clickable button component
        "
      `);
    });

    it('should generate props table with HAST types and descriptions', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('"primary" | "secondary"'),
            typeText: '"primary" | "secondary"',
            description: textToHast('The button variant'),
            descriptionText: 'The button variant',
            default: codeToHast('primary'),
            defaultText: 'primary',
          },
          disabled: {
            type: codeToHast('boolean'),
            typeText: 'boolean',
            description: textToHast('Whether the button is disabled'),
            descriptionText: 'Whether the button is disabled',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown('Button API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop     | Type                       | Default   | Description                    |
        | :------- | :------------------------- | :-------- | :----------------------------- |
        | variant  | \`"primary" \\| "secondary"\` | \`primary\` | The button variant             |
        | disabled | \`boolean\`                  | -         | Whether the button is disabled |
        "
      `);
    });

    it('should generate data attributes table', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {
          'data-state': {
            type: '"active" | "inactive"',
            description: textToHast('The current state of the button'),
            descriptionText: 'The current state of the button',
          },
        },
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown('Button API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Data Attributes:**

        | Attribute  | Type                     | Description                     |
        | :--------- | :----------------------- | :------------------------------ |
        | data-state | \`"active" \\| "inactive"\` | The current state of the button |
        "
      `);
    });

    it('should generate CSS variables table', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {
          '--button-bg': {
            type: 'color',
            description: textToHast('Background color of the button'),
            descriptionText: 'Background color of the button',
          },
          '--button-padding': {
            type: 'length',
            description: textToHast('Padding inside the button'),
            descriptionText: 'Padding inside the button',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown('Button API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button CSS Variables:**

        | Variable           | Type     | Description                    |
        | :----------------- | :------- | :----------------------------- |
        | \`--button-bg\`      | \`color\`  | Background color of the button |
        | \`--button-padding\` | \`length\` | Padding inside the button      |
        "
      `);
    });

    it('should handle component with all sections', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'CompleteButton',
        description: textToHast('A fully-featured button'),
        descriptionText: 'A fully-featured button',
        props: {
          variant: {
            type: codeToHast('string'),
            typeText: 'string',
          },
        },
        dataAttributes: {
          'data-active': {
            type: 'boolean',
            description: textToHast('Active state'),
            descriptionText: 'Active state',
          },
        },
        cssVariables: {
          '--color': {
            type: 'color',
            description: textToHast('Button color'),
            descriptionText: 'Button color',
          },
        },
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'CompleteButton', data: componentMeta },
      ];

      const result = await generateTypesMarkdown('Complete API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Complete API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### CompleteButton

        A fully-featured button

        **CompleteButton Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |

        **CompleteButton Data Attributes:**

        | Attribute   | Type      | Description  |
        | :---------- | :-------- | :----------- |
        | data-active | \`boolean\` | Active state |

        **CompleteButton CSS Variables:**

        | Variable  | Type    | Description  |
        | :-------- | :------ | :----------- |
        | \`--color\` | \`color\` | Button color |
        "
      `);
    });
  });

  describe('hook type generation', () => {
    it('should generate markdown for a basic hook without description', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown('useCounter API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        \`number\`
        "
      `);
    });

    it('should generate markdown for hook with HAST description', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        description: textToHast('A hook for managing counter state'),
        descriptionText: 'A hook for managing counter state',
        parameters: {},
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown('useCounter API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        A hook for managing counter state

        **useCounter Return Value:**

        \`number\`
        "
      `);
    });

    it('should generate parameters table', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {
          initialValue: {
            type: codeToHast('number'),
            typeText: 'number',
            default: codeToHast('0'),
            defaultText: '0',
            description: textToHast('The initial counter value'),
            descriptionText: 'The initial counter value',
          },
          step: {
            type: codeToHast('number'),
            typeText: 'number',
            description: textToHast('Increment/decrement step'),
            descriptionText: 'Increment/decrement step',
          },
        },
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown('useCounter API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Parameters:**

        | Parameter    | Type     | Default | Description               |
        | :----------- | :------- | :------ | :------------------------ |
        | initialValue | \`number\` | \`0\`     | The initial counter value |
        | step         | \`number\` | -       | Increment/decrement step  |

        **useCounter Return Value:**

        \`number\`
        "
      `);
    });

    it('should generate return value as string', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown('useCounter API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        \`number\`
        "
      `);
    });

    it('should generate return value as table for object types', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: {
          count: {
            type: codeToHast('number'),
            typeText: 'number',
            description: textToHast('Current count value'),
            descriptionText: 'Current count value',
          },
          increment: {
            type: codeToHast('() => void'),
            typeText: '() => void',
            description: textToHast('Function to increment counter'),
            descriptionText: 'Function to increment counter',
          },
          decrement: {
            type: codeToHast('() => void'),
            typeText: '() => void',
            description: textToHast('Function to decrement counter'),
            descriptionText: 'Function to decrement counter',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown('useCounter API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        | Property  | Type         | Description                   |
        | :-------- | :----------- | :---------------------------- |
        | count     | \`number\`     | Current count value           |
        | increment | \`() => void\` | Function to increment counter |
        | decrement | \`() => void\` | Function to decrement counter |
        "
      `);
    });
  });

  describe('other export type generation', () => {
    it('should generate markdown for type exports', async () => {
      const exportMeta = {
        name: 'ButtonProps',
        type: {
          kind: 'object' as const,
          properties: [],
          call: [],
          construct: [],
        },
        documentation: {
          description: 'Props for the Button component',
          defaultValue: '',
          visibility: 'public' as const,
          tags: {},
          hasTag: () => false,
          getTagValue: () => undefined,
        },
      };

      const typesMeta: TypesMeta[] = [
        { type: 'other', name: 'ButtonProps', data: exportMeta as any },
      ];

      const result = await generateTypesMarkdown('Types', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Types

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### ButtonProps

        Props for the Button component

        \`\`\`typescript
        type ButtonProps = {};
        \`\`\`
        "
      `);
      // Should include a code block with the formatted type
      expect(result).toMatch(/```typescript/);
    });

    it('should handle export without documentation', async () => {
      const exportMeta = {
        name: 'Status',
        type: {
          kind: 'intrinsic' as const,
          name: 'string',
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'other', name: 'Status', data: exportMeta as any }];

      const result = await generateTypesMarkdown('Types', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Types

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Status

        \`\`\`typescript
        type Status = undefined;
        \`\`\`
        "
      `);
    });

    it('should use flat type name in code blocks for dotted names', async () => {
      // When a type has a dotted name like "Component.Root.State", the heading should
      // show the dotted name, but the code block must use the flat name "ComponentRootState"
      // because TypeScript type declarations cannot have dots in the type name.
      const exportMeta = {
        name: 'Component.Root.State',
        type: {
          kind: 'object' as const,
          properties: [
            { name: 'disabled', type: { kind: 'intrinsic', name: 'boolean' }, optional: false },
            { name: 'active', type: { kind: 'intrinsic', name: 'boolean' }, optional: false },
          ],
          // typeName contains the original naming information
          typeName: {
            name: 'State',
            namespaces: ['ComponentRoot'],
          },
        },
      };

      const typesMeta: TypesMeta[] = [
        { type: 'other', name: 'Component.Root.State', data: exportMeta as any },
      ];

      const result = await generateTypesMarkdown('Types', typesMeta);

      // Heading should use dotted name
      expect(result).toContain('### Component.Root.State');
      // Code block should use flat name (ComponentRootState), not dotted name
      expect(result).toContain('type ComponentRootState = {');
      // Should NOT contain dots in type declaration
      expect(result).not.toMatch(/type Component\.Root\.State =/);
    });
  });

  describe('multiple type generation', () => {
    it('should generate markdown for multiple components', async () => {
      const button: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const input: ComponentTypeMeta = {
        name: 'Input',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Button', data: button },
        { type: 'component', name: 'Input', data: input },
      ];

      const result = await generateTypesMarkdown('Components', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Components

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Input

        ### Button
        "
      `);
    });

    it('should generate markdown for mixed types', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const hook: HookTypeMeta = {
        name: 'useButton',
        parameters: {},
        returnValue: codeToHast('void'),
        returnValueText: 'void',
      };

      const typeExport = {
        name: 'ButtonProps',
        type: { kind: 'intrinsic' as const, name: 'object' },
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Button', data: component },
        { type: 'hook', name: 'useButton', data: hook },
        { type: 'other', name: 'ButtonProps', data: typeExport as any },
      ];

      const result = await generateTypesMarkdown('Mixed API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Mixed API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        ### ButtonProps

        \`\`\`typescript
        type ButtonProps = undefined;
        \`\`\`

        ### useButton

        **useButton Return Value:**

        \`void\`
        "
      `);
    });
  });

  describe('markdown formatting', () => {
    it('should include autogeneration comment', async () => {
      const typesMeta: TypesMeta[] = [];
      const result = await generateTypesMarkdown('Empty', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# Empty

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference
        "
      `);
    });

    it('should create proper heading hierarchy', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API Reference', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API Reference

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button
        "
      `);
    });

    it('should use proper table alignment', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('string'),
            typeText: 'string',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |
        "
      `);
    });
  });

  describe('complex HAST descriptions', () => {
    it('should handle HAST with code blocks in descriptions', async () => {
      const descriptionWithCode = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Use this component like:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: { className: ['language-tsx'] },
                children: [{ type: 'text' as const, value: '<Button variant="primary" />' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithCode,
        descriptionText: 'Use this component like:\n\n```tsx\n<Button variant="primary" />\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        Use this component like:

        \`\`\`tsx
        <Button variant="primary" />
        \`\`\`
        "
      `);
    });

    it('should handle HAST with links in descriptions', async () => {
      const descriptionWithLink = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [
              { type: 'text' as const, value: 'See the ' },
              {
                type: 'element' as const,
                tagName: 'a',
                properties: { href: 'https://example.com' },
                children: [{ type: 'text' as const, value: 'documentation' }],
              },
              { type: 'text' as const, value: ' for more details.' },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithLink,
        descriptionText: 'See the [documentation](https://example.com) for more details.',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        See the [documentation](https://example.com) for more details.
        "
      `);
    });

    it('should handle HAST with lists in descriptions', async () => {
      const descriptionWithList = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'This component supports:' }],
          },
          {
            type: 'element' as const,
            tagName: 'ul',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Primary variant' }],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Secondary variant' }],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Disabled state' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithList,
        descriptionText:
          'This component supports:\n\n- Primary variant\n- Secondary variant\n- Disabled state',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        This component supports:

        - Primary variant
        - Secondary variant
        - Disabled state
        "
      `);
    });

    it('should handle HAST with inline code in prop descriptions', async () => {
      const propDescriptionWithCode = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [
              { type: 'text' as const, value: 'Set to ' },
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'true' }],
              },
              { type: 'text' as const, value: ' to disable the button.' },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          disabled: {
            type: codeToHast('boolean'),
            typeText: 'boolean',
            description: propDescriptionWithCode,
            descriptionText: 'Set to `true` to disable the button.',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop     | Type      | Default | Description                          |
        | :------- | :-------- | :------ | :----------------------------------- |
        | disabled | \`boolean\` | -       | Set to \`true\` to disable the button. |
        "
      `);
    });

    it('should handle HAST with multiple paragraphs', async () => {
      const multiParagraphDescription = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'First paragraph with introduction.' }],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Second paragraph with more details.' }],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Third paragraph with examples.' }],
          },
        ],
      };

      const hook: HookTypeMeta = {
        name: 'useCounter',
        description: multiParagraphDescription,
        descriptionText:
          'First paragraph with introduction.\n\nSecond paragraph with more details.\n\nThird paragraph with examples.',
        parameters: {},
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        First paragraph with introduction.

        Second paragraph with more details.

        Third paragraph with examples.

        **useCounter Return Value:**

        \`number\`
        "
      `);
    });

    it('should handle precomputed code blocks with dataPrecompute attribute', async () => {
      // Simulate a precomputed code block as would be generated by the syntax highlighter
      const precomputedCode = {
        Default: {
          source: {
            type: 'root' as const,
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const x = 42;' }],
              },
            ],
          },
        },
      };

      const descriptionWithPrecomputed = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Example code:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const x = 42;' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithPrecomputed,
        descriptionText: 'Example code:\n\n```\nconst x = 42;\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        Example code:

        \`\`\`
        const x = 42;
        \`\`\`
        "
      `);
      // The precomputed code should be expanded and converted to markdown code block
      expect(result).toMatch(/```[\s\S]*const x = 42;/);
    });

    it('should handle precomputed code with hastJson serialization', async () => {
      const hastJson = JSON.stringify({
        type: 'root',
        children: [
          {
            type: 'element',
            tagName: 'code',
            properties: {},
            children: [{ type: 'text', value: 'function hello() {}' }],
          },
        ],
      });

      const precomputedCode = {
        Default: {
          source: { hastJson },
        },
      };

      const descriptionWithHastJson = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'function hello() {}' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithHastJson,
        descriptionText: '```\nfunction hello() {}\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        \`\`\`
        function hello() {}
        \`\`\`
        "
      `);
    });

    it('should handle precomputed code with string source', async () => {
      const precomputedCode = {
        Default: {
          source: 'const greeting = "Hello";',
        },
      };

      const descriptionWithStringSource = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const greeting = "Hello";' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithStringSource,
        descriptionText: '```\nconst greeting = "Hello";\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        \`\`\`
        const greeting = "Hello";
        \`\`\`
        "
      `);
    });

    it('should handle malformed dataPrecompute gracefully', async () => {
      const descriptionWithInvalidPrecompute = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Before code' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: 'invalid json{',
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'fallback code' }],
              },
            ],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'After code' }],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithInvalidPrecompute,
        descriptionText: 'Before code\n\n```\nfallback code\n```\n\nAfter code',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      // Should not throw, should handle gracefully
      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        Before code

        \`\`\`
        fallback code
        \`\`\`

        After code
        "
      `);
      // When dataPrecompute is invalid, the original code should still be present
      expect(result).toContain('fallback code');
    });

    it('should handle precomputed code in prop descriptions', async () => {
      const precomputedCode = {
        Default: {
          source: {
            type: 'root' as const,
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: '<Button onClick={handler} />' }],
              },
            ],
          },
        },
      };

      const propDescriptionWithPrecomputed = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Usage example:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: '<Button onClick={handler} />' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          onClick: {
            type: codeToHast('() => void'),
            typeText: '() => void',
            description: propDescriptionWithPrecomputed,
            descriptionText: 'Usage example:`<Button onClick={handler} />`',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type         | Default | Description                                  |
        | :------ | :----------- | :------ | :------------------------------------------- |
        | onClick | \`() => void\` | -       | Usage example:\`<Button onClick={handler} />\` |
        "
      `);
    });

    it('should convert lists in prop descriptions to inline comma-separated content', async () => {
      const descriptionWithList = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Supported variants:' }],
          },
          {
            type: 'element' as const,
            tagName: 'ul',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'primary' }],
                  },
                ],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'secondary' }],
                  },
                ],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'tertiary' }],
                  },
                ],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('string'),
            typeText: 'string',
            description: descriptionWithList,
            descriptionText: 'Supported variants:primary, secondary, tertiary',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description                                     |
        | :------ | :------- | :------ | :---------------------------------------------- |
        | variant | \`string\` | -       | Supported variants:primary, secondary, tertiary |
        "
      `);
    });
  });

  describe('optional and required markers', () => {
    it('should handle optional parameters in hooks', async () => {
      const hook: HookTypeMeta = {
        name: 'useCounter',
        parameters: {
          initialValue: {
            type: codeToHast('number'),
            typeText: 'number',
            default: codeToHast('0'),
            defaultText: '0',
            optional: true,
            description: textToHast('Initial counter value'),
            descriptionText: 'Initial counter value',
          },
          step: {
            type: codeToHast('number'),
            typeText: 'number',
            optional: true,
            description: textToHast('Increment step'),
            descriptionText: 'Increment step',
          },
        },
        returnValue: codeToHast('number'),
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Parameters:**

        | Parameter    | Type     | Default | Description           |
        | :----------- | :------- | :------ | :-------------------- |
        | initialValue | \`number\` | \`0\`     | Initial counter value |
        | step         | \`number\` | -       | Increment step        |

        **useCounter Return Value:**

        \`number\`
        "
      `);
      // Optional marker is stored in data but not currently rendered
      // If/when we add optional markers to the output, update this test
    });

    it('should handle required properties in components', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('string'),
            typeText: 'string',
            required: true,
            description: textToHast('Button variant (required)'),
            descriptionText: 'Button variant (required)',
          },
          disabled: {
            type: codeToHast('boolean'),
            typeText: 'boolean',
            description: textToHast('Disabled state (optional)'),
            descriptionText: 'Disabled state (optional)',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop     | Type      | Default | Description               |
        | :------- | :-------- | :------ | :------------------------ |
        | variant  | \`string\`  | -       | Button variant (required) |
        | disabled | \`boolean\` | -       | Disabled state (optional) |
        "
      `);
      // Required marker is stored in data but not currently rendered
      // If/when we add required markers to the output, update this test
    });

    it('should preserve optional flag in hook return value properties', async () => {
      const hook: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: {
          count: {
            type: codeToHast('number'),
            typeText: 'number',
            description: textToHast('Current count'),
            descriptionText: 'Current count',
            required: true,
          },
          reset: {
            type: codeToHast('() => void'),
            typeText: '() => void',
            description: textToHast('Optional reset function'),
            descriptionText: 'Optional reset function',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        | Property | Type         | Description             |
        | :------- | :----------- | :---------------------- |
        | count    | \`number\`     | Current count           |
        | reset    | \`() => void\` | Optional reset function |
        "
      `);
    });
  });

  describe('edge cases', () => {
    it('should handle empty types array', async () => {
      const result = await generateTypesMarkdown('Empty API', []);

      expect(result).toMatchInlineSnapshot(`
        "# Empty API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference
        "
      `);
    });

    it('should handle component with empty props object', async () => {
      const component: ComponentTypeMeta = {
        name: 'Empty',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Empty', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Empty
        "
      `);
    });

    it('should handle hook with empty return value object', async () => {
      const hook: HookTypeMeta = {
        name: 'useEmpty',
        parameters: {},
        returnValue: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useEmpty', data: hook }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useEmpty

        **useEmpty Return Value:**
        "
      `);
      // Empty return value objects still show the header currently
      // This could be considered a bug that should be fixed in the implementation
    });

    it('should handle prop with missing type', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('unknown'),
            typeText: 'unknown',
            description: textToHast('Variant prop'),
            descriptionText: 'Variant prop',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type      | Default | Description  |
        | :------ | :-------- | :------ | :----------- |
        | variant | \`unknown\` | -       | Variant prop |
        "
      `);
    });

    it('should handle prop with missing description', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            type: codeToHast('string'),
            typeText: 'string',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown('API', typesMeta);

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |
        "
      `);
    });
  });
});
