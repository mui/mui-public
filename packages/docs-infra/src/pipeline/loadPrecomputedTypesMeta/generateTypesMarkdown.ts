import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import remarkGfm from 'remark-gfm';
import rehypeRemark from 'rehype-remark';
import type { PhrasingContent, RootContent, Root } from 'mdast';
import type { HastRoot } from '../../CodeHighlighter/types';
import * as md from './createMarkdownNodes';
import type { TypesMeta } from './loadPrecomputedTypesMeta';
import { prettyFormatType } from './format';

/**
 * Parse a markdown string into an AST
 * @param {string} markdown - Markdown string to parse
 * @returns {Object} The root content node of the parsed AST
 */
function parseMarkdown(markdown: string): RootContent[] {
  // Parse markdown into an AST
  const processor = unified().use(remarkParse);
  const result = processor.parse(markdown);
  return result.children as RootContent[];
}

/**
 * Convert HAST (HTML AST) back to MDAST (Markdown AST)
 * @param hast - HAST root node
 * @returns Array of MDAST root content nodes
 */
async function hastToMdast(hast: HastRoot): Promise<RootContent[]> {
  const processor = unified().use(rehypeRemark);
  const result = (await processor.run(hast)) as Root;
  return result.children as RootContent[];
}

/**
 * Parse a markdown string and extract only the inline content (for table cells)
 * @param markdown - Markdown string to parse
 * @returns Array of phrasing content nodes
 */
function parseInlineMarkdown(markdown: string): PhrasingContent[] {
  const nodes = parseMarkdown(markdown);
  // If it's a single paragraph, return its children
  if (nodes.length === 1 && nodes[0].type === 'paragraph') {
    return (nodes[0] as any).children || [md.text(markdown)];
  }
  // Otherwise, convert to text
  return [md.text(markdown)];
}

/**
 * Convert HAST to inline markdown content (for table cells)
 * @param hast - HAST root node
 * @returns Array of phrasing content nodes
 */
async function hastToInlineMdast(hast: HastRoot): Promise<PhrasingContent[]> {
  const nodes = await hastToMdast(hast);

  return nodes.flatMap((node) => {
    // Handle paragraphs - extract their inline children
    if (node.type === 'paragraph') {
      return (node as any).children || [];
    }

    // Handle code blocks - convert to inline code
    if (node.type === 'code') {
      return [md.inlineCode((node as any).value || '')];
    }

    // Handle lists - convert to comma-separated inline content
    if (node.type === 'list') {
      const items = (node as any).children || [];
      const listContent: PhrasingContent[] = [];

      items.forEach((item: any, index: number) => {
        if (item.type === 'listItem') {
          const itemChildren = item.children || [];
          // Recursively flatten list item content
          itemChildren.forEach((child: any) => {
            if (child.type === 'paragraph') {
              listContent.push(...(child.children || []));
            }
          });

          // Add comma separator between items (but not after last item)
          if (index < items.length - 1) {
            listContent.push(md.text(', '));
          }
        }
      });

      return listContent;
    }

    // For other block-level content (headings, etc.), try to extract text
    if ('children' in node && Array.isArray((node as any).children)) {
      return (node as any).children.filter(
        (child: any) => child.type === 'text' || child.type === 'inlineCode',
      );
    }

    // Fallback: return empty array for unhandled node types
    return [];
  });
}

export async function generateTypesMarkdown(name: string, types: TypesMeta[]): Promise<string> {
  const tables: RootContent[] = [
    md.heading(1, name),
    md.comment('<-- Autogenerated By (do not edit the following markdown directly)', 'types.ts'),
    md.heading(2, 'API Reference'),
  ];

  await Promise.all(
    types.map(async (typeMeta) => {
      if (typeMeta.type === 'component') {
        const part = typeMeta.data.name;
        const data = typeMeta.data; // This is now properly typed as ComponentTypeMeta

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.description) {
          // Convert HAST to MDAST and add all content directly
          const descriptionNodes = await hastToMdast(data.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        // Props table (for components)
        if (Object.keys(data.props || {}).length > 0) {
          // Create a proper heading with strong node
          tables.push(md.paragraph([md.strong(`${part} Props:`)]));

          const propsRows = await Promise.all(
            Object.entries(data.props).map(async ([propName, propDef]) => [
              propName,
              propDef.type ? await hastToInlineMdast(propDef.type) : '-',
              propDef.default ? md.inlineCode(String(propDef.default)) : '-',
              propDef.description ? await hastToInlineMdast(propDef.description) : '-',
            ]),
          );

          // Define column alignments: prop name left-aligned, others left-aligned
          const alignments = ['left', 'left', 'left', 'left'];

          const tableNode = md.table(
            ['Prop', 'Type', 'Default', 'Description'],
            propsRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // Data attributes table (for components)
        if (Object.keys(data.dataAttributes || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} Data Attributes:`)]));

          const attrRows = await Promise.all(
            Object.entries(data.dataAttributes).map(async ([attrName, attrDef]) => [
              attrName,
              attrDef.type ? md.inlineCode(attrDef.type) : '-',
              attrDef.description ? await hastToInlineMdast(attrDef.description) : '-',
            ]),
          );

          // Define column alignments
          const alignments = ['left', 'left', 'left'];

          const tableNode = md.table(
            ['Attribute', 'Type', 'Description'],
            attrRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // CSS variables table (for components)
        if (Object.keys(data.cssVariables || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} CSS Variables:`)]));

          const cssRows = await Promise.all(
            Object.entries(data.cssVariables).map(async ([variableName, variableDef]) => [
              md.inlineCode(variableName),
              md.inlineCode(variableDef.type || ''),
              variableDef.description ? await hastToInlineMdast(variableDef.description) : '-',
            ]),
          );

          // Define column alignments
          const alignments = ['left', 'left', 'left'];

          const tableNode = md.table(
            ['Variable', 'Type', 'Description'],
            cssRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }
      } else if (typeMeta.type === 'hook') {
        const part = typeMeta.data.name;
        const data = typeMeta.data; // This is now properly typed as HookTypeMeta

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.description) {
          // Convert HAST to MDAST and add all content directly
          const descriptionNodes = await hastToMdast(data.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        // Parameters table (for hooks)
        if (Object.keys(data.parameters || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} Parameters:`)]));

          const paramRows = Object.entries(data.parameters).map(([paramName, paramDef]) => [
            paramName,
            paramDef.type ? md.inlineCode(paramDef.type) : '-',
            paramDef.default ? md.inlineCode(paramDef.default) : '-',
            parseInlineMarkdown(paramDef.description || '-'),
          ]);

          const alignments = ['left', 'left', 'left', 'left'];

          const tableNode = md.table(
            ['Parameter', 'Type', 'Default', 'Description'],
            paramRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // Return Value (for hooks)
        if (data.returnValue) {
          tables.push(md.paragraph([md.strong(`${part} Return Value:`)]));

          if (typeof data.returnValue === 'string') {
            tables.push(md.paragraph(md.inlineCode(data.returnValue)));
          } else if (
            typeof data.returnValue === 'object' &&
            Object.keys(data.returnValue).length > 0
          ) {
            const returnRows = Object.entries(data.returnValue).map(
              ([returnName, returnDef]: [string, any]) => [
                returnName,
                returnDef.type ? md.inlineCode(returnDef.type) : '-',
                parseInlineMarkdown(returnDef.description || '-'),
              ],
            );

            const alignments = ['left', 'left', 'left'];

            const tableNode = md.table(
              ['Property', 'Type', 'Description'],
              returnRows as any,
              alignments as any,
            );
            tables.push(tableNode);
          }
        }
      } else {
        // For 'other' types (ExportNode)
        const part = typeMeta.data.name || 'Unknown';
        const data = typeMeta.data; // This is now properly typed as ExportNode

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.documentation?.description) {
          // Parse the description as markdown and add all content directly
          const descriptionNodes = parseMarkdown(data.documentation.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        tables.push(
          md.code(await prettyFormatType(data.type, true, undefined, true, []), 'typescript'),
        );
      }
    }),
  );

  const root: Root = { type: 'root', children: tables };

  return unified()
    .use(remarkGfm)
    .use(remarkStringify, {
      bullet: '-',
      emphasis: '*',
      strong: '*',
      fence: '`',
      fences: true,
      listItemIndent: 'one',
      rule: '-',
      quote: "'",
    })
    .stringify(root);
}
