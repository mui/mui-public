import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import remarkGfm from 'remark-gfm';
import type { PhrasingContent, RootContent, Root } from 'mdast';
import * as md from './createMarkdownNodes';
import type { TypesMeta } from './loadPrecomputedTypesMeta';
import { prettyFormatType } from './format';

/**
 * Parse a markdown string into an AST
 * @param {string} markdown - Markdown string to parse
 * @returns {Object} The root content node of the parsed AST
 */
function parseMarkdown(markdown: string): RootContent[] {
  // Parse markdown into an AST
  const processor = unified().use(remarkParse);
  const result = processor.parse(markdown);
  return result.children as RootContent[];
}

/**
 * Parse a markdown string and extract only the inline content (for table cells)
 * @param markdown - Markdown string to parse
 * @returns Array of phrasing content nodes
 */
function parseInlineMarkdown(markdown: string): PhrasingContent[] {
  const nodes = parseMarkdown(markdown);
  // If it's a single paragraph, return its children
  if (nodes.length === 1 && nodes[0].type === 'paragraph') {
    return (nodes[0] as any).children || [md.text(markdown)];
  }
  // Otherwise, convert to text
  return [md.text(markdown)];
}

export async function generateTypesMarkdown(name: string, types: TypesMeta[]): Promise<string> {
  const tables: RootContent[] = [
    md.heading(1, name),
    md.comment('<-- Autogenerated By (do not edit the following markdown directly)', 'types.ts'),
    md.heading(2, 'API Reference'),
  ];

  await Promise.all(
    types.map(async (typeMeta) => {
      if (typeMeta.type === 'component') {
        const part = typeMeta.data.name;
        const data = typeMeta.data; // This is now properly typed as ComponentTypeMeta

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.description) {
          // Parse the description as markdown and add all content directly
          const descriptionNodes = parseMarkdown(data.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        // Props table (for components)
        if (Object.keys(data.props || {}).length > 0) {
          // Create a proper heading with strong node
          tables.push(md.paragraph([md.strong(`${part} Props:`)]));

          const propsRows = Object.entries(data.props).map(([propName, propDef]: [string, any]) => [
            propName,
            propDef.type ? md.inlineCode(propDef.type) : '-',
            propDef.default ? md.inlineCode(propDef.default) : '-',
            parseInlineMarkdown(propDef.description || '-'),
          ]);

          // Define column alignments: prop name left-aligned, others left-aligned
          const alignments = ['left', 'left', 'left', 'left'];

          const tableNode = md.table(
            ['Prop', 'Type', 'Default', 'Description'],
            propsRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // Data attributes table (for components)
        if (Object.keys(data.dataAttributes || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} Data Attributes:`)]));

          const attrRows = Object.entries(data.dataAttributes).map(
            ([attrName, attrDef]: [string, any]) => [
              attrName,
              attrDef.type ? md.inlineCode(attrDef.type) : '-',
              parseInlineMarkdown(attrDef.description || '-'),
            ],
          );

          // Define column alignments
          const alignments = ['left', 'left', 'left'];

          const tableNode = md.table(
            ['Attribute', 'Type', 'Description'],
            attrRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // CSS variables table (for components)
        if (Object.keys(data.cssVariables || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} CSS Variables:`)]));

          const cssRows = Object.entries(data.cssVariables).map(
            ([variableName, variableDef]: [string, any]) => [
              md.inlineCode(variableName),
              md.inlineCode(variableDef.type || ''),
              parseInlineMarkdown(variableDef.description || '-'),
            ],
          );

          // Define column alignments
          const alignments = ['left', 'left', 'left'];

          const tableNode = md.table(
            ['Variable', 'Type', 'Description'],
            cssRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }
      } else if (typeMeta.type === 'hook') {
        const part = typeMeta.data.name;
        const data = typeMeta.data; // This is now properly typed as HookTypeMeta

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.description) {
          // Parse the description as markdown and add all content directly
          const descriptionNodes = parseMarkdown(data.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        // Parameters table (for hooks)
        if (Object.keys(data.parameters || {}).length > 0) {
          tables.push(md.paragraph([md.strong(`${part} Parameters:`)]));

          const paramRows = Object.entries(data.parameters).map(
            ([paramName, paramDef]: [string, any]) => [
              paramName,
              paramDef.type ? md.inlineCode(paramDef.type) : '-',
              paramDef.default ? md.inlineCode(paramDef.default) : '-',
              parseInlineMarkdown(paramDef.description || '-'),
            ],
          );

          const alignments = ['left', 'left', 'left', 'left'];

          const tableNode = md.table(
            ['Parameter', 'Type', 'Default', 'Description'],
            paramRows as any,
            alignments as any,
          );
          tables.push(tableNode);
        }

        // Return Value (for hooks)
        if (data.returnValue) {
          tables.push(md.paragraph([md.strong(`${part} Return Value:`)]));

          if (typeof data.returnValue === 'string') {
            tables.push(md.paragraph(md.inlineCode(data.returnValue)));
          } else if (
            typeof data.returnValue === 'object' &&
            Object.keys(data.returnValue).length > 0
          ) {
            const returnRows = Object.entries(data.returnValue).map(
              ([returnName, returnDef]: [string, any]) => [
                returnName,
                returnDef.type ? md.inlineCode(returnDef.type) : '-',
                parseInlineMarkdown(returnDef.description || '-'),
              ],
            );

            const alignments = ['left', 'left', 'left'];

            const tableNode = md.table(
              ['Property', 'Type', 'Description'],
              returnRows as any,
              alignments as any,
            );
            tables.push(tableNode);
          }
        }
      } else {
        // For 'other' types (ExportNode)
        const part = typeMeta.data.name || 'Unknown';
        const data = typeMeta.data; // This is now properly typed as ExportNode

        // Add subheading for the part
        tables.push(md.heading(3, part));

        // Add description if available
        if (data.documentation?.description) {
          // Parse the description as markdown and add all content directly
          const descriptionNodes = parseMarkdown(data.documentation.description);
          descriptionNodes.forEach((node) => tables.push(node));
        }

        tables.push(
          md.code(await prettyFormatType(data.type, true, undefined, true, []), 'typescript'),
        );
      }
    }),
  );

  const root: Root = { type: 'root', children: tables };

  return unified()
    .use(remarkGfm)
    .use(remarkStringify, {
      bullet: '-',
      emphasis: '*',
      strong: '*',
      fence: '`',
      fences: true,
      listItemIndent: 'one',
      rule: '-',
      quote: "'",
    })
    .stringify(root);
}
