/* eslint-disable no-irregular-whitespace */
import { describe, it, expect } from 'vitest';
import { parseTypesMarkdown } from './loadServerTypesText';
import type { ComponentTypeMeta, HookTypeMeta } from '../loadServerTypesMeta';

describe('loadServerTypesText', () => {
  describe('component parsing', () => {
    it('should parse a basic component without description', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {},
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse a component with description', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

A clickable button component
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "description": {
                    "children": [
                      {
                        "children": [
                          {
                            "type": "text",
                            "value": "A clickable button component",
                          },
                        ],
                        "properties": {},
                        "tagName": "p",
                        "type": "element",
                      },
                    ],
                    "type": "root",
                  },
                  "descriptionText": "A clickable button component",
                  "name": "Button",
                  "props": {},
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse props table with types and descriptions', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop     | Type                       | Default   | Description                    |
| :------- | :------------------------- | :-------- | :----------------------------- |
| variant  | \`"primary" \\| "secondary"\` | \`primary\` | The button variant             |
| disabled | \`boolean\`                  | -         | Whether the button is disabled |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {
                    "disabled": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Whether the button is disabled",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Whether the button is disabled",
                      "typeText": "boolean",
                    },
                    "variant": {
                      "defaultText": "primary",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "The button variant",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "The button variant",
                      "typeText": ""primary" | "secondary"",
                    },
                  },
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse prop examples after props table', async () => {
      const markdown = `# Select.Value API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Value

**Value Props:**

| Prop        | Type                                                   | Default | Description                                                               |
| :---------- | :----------------------------------------------------- | :------ | :------------------------------------------------------------------------ |
| children    | \`React.ReactNode \\| ((value: any) => React.ReactNode)\` | -       | Accepts a function that returns a ReactNode to format the selected value. |
| placeholder | \`React.ReactNode\`                                      | -       | The placeholder value to display when no value is selected.               |

**\`children\` Prop Example:**

\`\`\`tsx
<Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Value": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Value",
                  "props": {
                    "children": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Accepts a function that returns a ReactNode to format the selected value.",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Accepts a function that returns a ReactNode to format the selected value.",
                      "exampleText": "\`\`\`tsx
        <Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
        \`\`\`",
                      "typeText": "React.ReactNode | ((value: any) => React.ReactNode)",
                    },
                    "placeholder": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "The placeholder value to display when no value is selected.",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "The placeholder value to display when no value is selected.",
                      "typeText": "React.ReactNode",
                    },
                  },
                },
                "name": "Value",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Value",
            ],
          },
        }
      `);
    });

    it('should parse data attributes table', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Data Attributes:**

| Attribute  | Type                     | Description                     |
| :--------- | :----------------------- | :------------------------------ |
| data-state | \`"active" \\| "inactive"\` | The current state of the button |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {
                    "data-state": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "The current state of the button",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "The current state of the button",
                      "type": ""active" | "inactive"",
                    },
                  },
                  "name": "Button",
                  "props": {},
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse CSS variables table', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button CSS Variables:**

| Variable           | Type     | Description                    |
| :----------------- | :------- | :----------------------------- |
| \`--button-bg\`      | \`color\`  | Background color of the button |
| \`--button-padding\` | \`length\` | Padding inside the button      |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {
                    "--button-bg": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Background color of the button",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Background color of the button",
                      "type": "color",
                    },
                    "--button-padding": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Padding inside the button",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Padding inside the button",
                      "type": "length",
                    },
                  },
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {},
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse component with all sections', async () => {
      const markdown = `# Complete API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### CompleteButton

A fully-featured button

**CompleteButton Props:**

| Prop    | Type     | Default | Description |
| :------ | :------- | :------ | :---------- |
| variant | \`string\` | -       | -           |

**CompleteButton Data Attributes:**

| Attribute   | Type      | Description  |
| :---------- | :-------- | :----------- |
| data-active | \`boolean\` | Active state |

**CompleteButton CSS Variables:**

| Variable  | Type    | Description  |
| :-------- | :------ | :----------- |
| \`--color\` | \`color\` | Button color |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "CompleteButton": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {
                    "--color": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Button color",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Button color",
                      "type": "color",
                    },
                  },
                  "dataAttributes": {
                    "data-active": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Active state",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Active state",
                      "type": "boolean",
                    },
                  },
                  "description": {
                    "children": [
                      {
                        "children": [
                          {
                            "type": "text",
                            "value": "A fully-featured button",
                          },
                        ],
                        "properties": {},
                        "tagName": "p",
                        "type": "element",
                      },
                    ],
                    "type": "root",
                  },
                  "descriptionText": "A fully-featured button",
                  "name": "CompleteButton",
                  "props": {
                    "variant": {
                      "typeText": "string",
                    },
                  },
                },
                "name": "CompleteButton",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "CompleteButton",
            ],
          },
        }
      `);
    });
  });

  describe('hook parsing', () => {
    it('should parse a basic hook without description', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "useCounter": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "name": "useCounter",
                  "parameters": {},
                  "returnValue": "type ReturnValue = number;",
                },
                "name": "useCounter",
                "type": "hook",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "useCounter",
            ],
          },
        }
      `);
    });

    it('should parse hook with description', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

A hook for counting

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "useCounter": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "description": {
                    "children": [
                      {
                        "children": [
                          {
                            "type": "text",
                            "value": "A hook for counting",
                          },
                        ],
                        "properties": {},
                        "tagName": "p",
                        "type": "element",
                      },
                    ],
                    "type": "root",
                  },
                  "descriptionText": "A hook for counting",
                  "name": "useCounter",
                  "parameters": {},
                  "returnValue": "type ReturnValue = number;",
                },
                "name": "useCounter",
                "type": "hook",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "useCounter",
            ],
          },
        }
      `);
    });

    it('should parse parameters table', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Parameters:**

| Parameter    | Type     | Default | Description         |
| :----------- | :------- | :------ | :------------------ |
| initialValue | \`number\` | \`0\`     | Initial count value |
| step?        | \`number\` | \`1\`     | Step increment      |

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "useCounter": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "name": "useCounter",
                  "parameters": {
                    "initialValue": {
                      "defaultText": "0",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Initial count value",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Initial count value",
                      "typeText": "number",
                    },
                    "step": {
                      "defaultText": "1",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Step increment",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Step increment",
                      "optional": true,
                      "typeText": "number",
                    },
                  },
                  "returnValue": "type ReturnValue = number;",
                },
                "name": "useCounter",
                "type": "hook",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "useCounter",
            ],
          },
        }
      `);
    });

    it('should parse return value as table for object types', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Return Value:**

| Property  | Type         | Description          |
| :-------- | :----------- | :------------------- |
| \`count\`   | \`number\`     | The current count    |
| \`increment\` | \`() => void\` | Increment the count |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "useCounter": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "name": "useCounter",
                  "parameters": {},
                  "returnValue": {
                    "count": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "The current count",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "The current count",
                      "typeText": "number",
                    },
                    "increment": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Increment the count",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Increment the count",
                      "typeText": "() => void",
                    },
                  },
                },
                "name": "useCounter",
                "type": "hook",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "useCounter",
            ],
          },
        }
      `);
    });
  });

  describe('raw type parsing', () => {
    it('should parse raw type exports', async () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root.State

The state of the accordion root

\`\`\`typescript
type AccordionRootState = {
  open: boolean;
  disabled: boolean;
};
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [
            {
              "data": {
                "description": {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "The state of the accordion root",
                        },
                      ],
                      "properties": {},
                      "tagName": "p",
                      "type": "element",
                    },
                  ],
                  "type": "root",
                },
                "descriptionText": "The state of the accordion root",
                "formattedCode": "type AccordionRootState = {
          open: boolean;
          disabled: boolean;
        };",
                "name": "Accordion.Root.State",
              },
              "name": "Accordion.Root.State",
              "type": "raw",
            },
          ],
          "exports": {},
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Accordion.Root.State",
            ],
          },
        }
      `);
    });

    it('should parse re-export types', async () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Root.Props

Re-export of [Root](#root) props.
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [
            {
              "data": {
                "description": {
                  "children": [
                    {
                      "children": [
                        {
                          "type": "text",
                          "value": "Re-export of ",
                        },
                        {
                          "children": [
                            {
                              "type": "text",
                              "value": "Root",
                            },
                          ],
                          "properties": {
                            "href": "#root",
                          },
                          "tagName": "a",
                          "type": "element",
                        },
                        {
                          "type": "text",
                          "value": " props.",
                        },
                      ],
                      "properties": {},
                      "tagName": "p",
                      "type": "element",
                    },
                  ],
                  "type": "root",
                },
                "descriptionText": "Re-export of [Root](#root) props.",
                "formattedCode": "",
                "name": "Root.Props",
                "reExportOf": {
                  "name": "Root",
                  "slug": "root",
                  "suffix": "props",
                },
              },
              "name": "Root.Props",
              "type": "raw",
            },
          ],
          "exports": {},
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Root.Props",
            ],
          },
        }
      `);
    });
  });

  describe('multiple types', () => {
    it('should parse multiple components', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Root

The root button component

**Root Props:**

| Prop    | Type     | Default | Description |
| :------ | :------- | :------ | :---------- |
| variant | \`string\` | -       | Button variant |

### Trigger

The trigger element

**Trigger Props:**

| Prop     | Type      | Default | Description    |
| :------- | :-------- | :------ | :------------- |
| disabled | \`boolean\` | \`false\`  | Disable trigger |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Root": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "description": {
                    "children": [
                      {
                        "children": [
                          {
                            "type": "text",
                            "value": "The root button component",
                          },
                        ],
                        "properties": {},
                        "tagName": "p",
                        "type": "element",
                      },
                    ],
                    "type": "root",
                  },
                  "descriptionText": "The root button component",
                  "name": "Root",
                  "props": {
                    "variant": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Button variant",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Button variant",
                      "typeText": "string",
                    },
                  },
                },
                "name": "Root",
                "type": "component",
              },
            },
            "Trigger": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "description": {
                    "children": [
                      {
                        "children": [
                          {
                            "type": "text",
                            "value": "The trigger element",
                          },
                        ],
                        "properties": {},
                        "tagName": "p",
                        "type": "element",
                      },
                    ],
                    "type": "root",
                  },
                  "descriptionText": "The trigger element",
                  "name": "Trigger",
                  "props": {
                    "disabled": {
                      "defaultText": "false",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Disable trigger",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Disable trigger",
                      "typeText": "boolean",
                    },
                  },
                },
                "name": "Trigger",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Root",
              "Trigger",
            ],
          },
        }
      `);
    });
  });

  describe('external types', () => {
    it('should parse External Types section', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type          | Default | Description |
| :--- | :------------ | :------ | :---------- |
| side | \`Side\`        | -       | The side    |

## External Types

#### Side

\`\`\`tsx
type Side = 'top' | 'bottom' | 'left' | 'right';
\`\`\`

#### Align

\`\`\`tsx
type Align = 'start' | 'center' | 'end';
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.externalTypes).toMatchInlineSnapshot(`
        {
          "Align": "type Align = 'start' | 'center' | 'end';",
          "Side": "type Side = 'top' | 'bottom' | 'left' | 'right';",
        }
      `);
    });
  });

  describe('required and optional markers', () => {
    it('should parse required props with * marker', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop      | Type     | Default | Description |
| :-------- | :------- | :------ | :---------- |
| variant*  | \`string\` | -       | Required    |
| disabled  | \`boolean\` | \`false\` | Optional    |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {
                    "disabled": {
                      "defaultText": "false",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Optional",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Optional",
                      "typeText": "boolean",
                    },
                    "variant": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Required",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Required",
                      "required": true,
                      "typeText": "string",
                    },
                  },
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should parse optional parameters with ? marker', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Parameters:**

| Parameter | Type     | Default | Description |
| :-------- | :------- | :------ | :---------- |
| initial   | \`number\` | \`0\`     | Required    |
| step?     | \`number\` | \`1\`     | Optional    |

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "useCounter": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "name": "useCounter",
                  "parameters": {
                    "initial": {
                      "defaultText": "0",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Required",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Required",
                      "typeText": "number",
                    },
                    "step": {
                      "defaultText": "1",
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "Optional",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "Optional",
                      "optional": true,
                      "typeText": "number",
                    },
                  },
                  "returnValue": "type ReturnValue = number;",
                },
                "name": "useCounter",
                "type": "hook",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "useCounter",
            ],
          },
        }
      `);
    });
  });

  describe('edge cases', () => {
    it('should handle empty types array', async () => {
      const markdown = `# Empty API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {},
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [],
          },
        }
      `);
    });

    it('should handle missing default column value', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| name | \`string\` | -       | The name    |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {
                    "name": {
                      "description": {
                        "children": [
                          {
                            "children": [
                              {
                                "type": "text",
                                "value": "The name",
                              },
                            ],
                            "properties": {},
                            "tagName": "p",
                            "type": "element",
                          },
                        ],
                        "type": "root",
                      },
                      "descriptionText": "The name",
                      "typeText": "string",
                    },
                  },
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });

    it('should handle missing description column value', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| name | \`string\` | -       | -           |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result).toMatchInlineSnapshot(`
        {
          "additionalTypes": [],
          "exports": {
            "Button": {
              "additionalTypes": [],
              "type": {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {
                    "name": {
                      "typeText": "string",
                    },
                  },
                },
                "name": "Button",
                "type": "component",
              },
            },
          },
          "externalTypes": {},
          "typeNameMap": {},
          "variantTypeNameMaps": {},
          "variantTypeNames": {
            "Default": [
              "Button",
            ],
          },
        }
      `);
    });
  });

  describe('typeNameMap parsing', () => {
    it('should parse typeNameMap from metadata comment', async () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

**Accordion.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State","AccordionTriggerState":"Accordion.Trigger.State"}'
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
          "AccordionTriggerState": "Accordion.Trigger.State",
        }
      `);
    });

    it('should return empty typeNameMap when not present', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toEqual({});
    });

    it('should handle malformed typeNameMap gracefully', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'typeNameMap: not-valid-json'
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toEqual({});
    });
  });

  describe('variant parsing', () => {
    it('should create Default variant when no variant metadata is present', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.variantTypeNames).toMatchInlineSnapshot(`
        {
          "Default": [
            "Button",
          ],
        }
      `);

      expect(result.exports.Button.type.data).toMatchInlineSnapshot(`
        {
          "cssVariables": {},
          "dataAttributes": {},
          "name": "Button",
          "props": {
            "id": {
              "description": {
                "children": [
                  {
                    "children": [
                      {
                        "type": "text",
                        "value": "The id",
                      },
                    ],
                    "properties": {},
                    "tagName": "p",
                    "type": "element",
                  },
                ],
                "type": "root",
              },
              "descriptionText": "The id",
              "typeText": "string",
            },
          },
        }
      `);
    });

    it('should parse variantTypes and reconstruct variant type names', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

### IconButton

**IconButton Props:**

| Prop | Type     | Default | Description  |
| :--- | :------- | :------ | :----------- |
| icon | \`string\` | -       | The icon name |

[//]: # 'variantTypes: {"CssModules":["Button"],"Tailwind":["Button","IconButton"]}'
`;

      const result = await parseTypesMarkdown(markdown);

      expect(Object.keys(result.variantTypeNames)).toEqual(['CssModules', 'Tailwind']);

      // CssModules variant should only have Button
      expect(result.variantTypeNames.CssModules).toHaveLength(1);
      expect(result.variantTypeNames.CssModules[0]).toBe('Button');

      // Tailwind variant should have both Button and IconButton
      expect(result.variantTypeNames.Tailwind).toHaveLength(2);
      expect(result.variantTypeNames.Tailwind).toEqual(['Button', 'IconButton']);
    });

    it('should parse variantTypeNameMapKeys and include in variantTypeNameMaps', async () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

**Accordion.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

[//]: # 'variantTypes: {"Default":["Accordion.Root"]}'
[//]: # 'variantTypeNameMapKeys: {"Default":["AccordionRootState"]}'
[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State"}'
`;

      const result = await parseTypesMarkdown(markdown);

      expect(result.variantTypeNameMaps.Default).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
        }
      `);
    });

    it('should handle multiple variants with different typeNameMaps', async () => {
      const markdown = `# Select API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Select.Root

**Select.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| open | \`boolean\` | false   | Open state  |

### Select.Trigger

**Select.Trigger Props:**

| Prop     | Type     | Default | Description |
| :------- | :------- | :------ | :---------- |
| disabled | \`boolean\` | false   | Disabled    |

[//]: # 'variantTypes: {"CssModules":["Select.Root"],"Tailwind":["Select.Root","Select.Trigger"]}'
[//]: # 'variantTypeNameMapKeys: {"CssModules":["SelectRootState"],"Tailwind":["SelectRootState","SelectTriggerState"]}'
[//]: # 'typeNameMap: {"SelectRootState":"Select.Root.State","SelectTriggerState":"Select.Trigger.State"}'
`;

      const result = await parseTypesMarkdown(markdown);

      // CssModules should have only SelectRootState
      expect(result.variantTypeNameMaps.CssModules).toMatchInlineSnapshot(`
        {
          "SelectRootState": "Select.Root.State",
        }
      `);

      // Tailwind should have both
      expect(result.variantTypeNameMaps.Tailwind).toMatchInlineSnapshot(`
        {
          "SelectRootState": "Select.Root.State",
          "SelectTriggerState": "Select.Trigger.State",
        }
      `);
    });

    it('should handle missing types in variantTypes gracefully', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'variantTypes: {"Default":["Button","NonExistent"]}'
`;

      const result = await parseTypesMarkdown(markdown);

      // Should only include the type that exists in the markdown
      expect(result.variantTypeNames.Default).toHaveLength(1);
      expect(result.variantTypeNames.Default[0]).toBe('Button');
    });

    it('should handle malformed variantTypes gracefully', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'variantTypes: not-valid-json'
`;

      const result = await parseTypesMarkdown(markdown);

      // Should fall back to Default variant with all types
      expect(Object.keys(result.variantTypeNames)).toEqual(['Default']);
      expect(result.variantTypeNames.Default).toHaveLength(1);
    });

    it('should include typeNameMap in Default variant when present', async () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State"}'
`;

      const result = await parseTypesMarkdown(markdown);

      // Without variantTypes, Default variant should include the merged typeNameMap
      expect(result.variantTypeNameMaps.Default).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
        }
      `);
    });
  });

  describe('references parsing', () => {
    it('should parse a single prop reference', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop    | Type     | Default | Description       |
| :------ | :------- | :------ | :---------------- |
| variant | \`string\` | -       | The button variant |

**\`variant\` Prop References:**

- See [External docs](https://external.example/docs/Web/CSS/variant)
`;

      const result = await parseTypesMarkdown(markdown);

      const buttonData = result.exports.Button.type.data as ComponentTypeMeta;
      expect(buttonData.props.variant.seeText).toBe(
        '- See [External docs](https://external.example/docs/Web/CSS/variant)',
      );
      expect(buttonData.props.variant.see).toBeDefined();
    });

    it('should parse multiple prop references as a bullet list', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop    | Type     | Default | Description       |
| :------ | :------- | :------ | :---------------- |
| variant | \`string\` | -       | The button variant |

**\`variant\` Prop References:**

- See [External docs](https://external.example/docs/Web/CSS/variant)
- See [Other docs](https://other.external.example)
`;

      const result = await parseTypesMarkdown(markdown);

      const buttonData = result.exports.Button.type.data as ComponentTypeMeta;
      expect(buttonData.props.variant.seeText).toBe(
        '- See [External docs](https://external.example/docs/Web/CSS/variant)\n- See [Other docs](https://other.external.example)',
      );
    });

    it('should parse parameter references for hooks', async () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Parameters:**

| Parameter    | Type     | Default | Description         |
| :----------- | :------- | :------ | :------------------ |
| initialValue | \`number\` | \`0\`     | Initial count value |

**\`initialValue\` Parameter References:**

- See [External docs](https://external.example/reference/hooks/useState)

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = await parseTypesMarkdown(markdown);

      const hookData = result.exports.useCounter.type.data as HookTypeMeta;
      expect(hookData.parameters.initialValue.seeText).toBe(
        '- See [External docs](https://external.example/reference/hooks/useState)',
      );
      expect(hookData.parameters.initialValue.see).toBeDefined();
    });

    it('should parse references after examples for the same prop', async () => {
      const markdown = `# Select.Value API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Value

**Value Props:**

| Prop     | Type                                                   | Default | Description                |
| :------- | :----------------------------------------------------- | :------ | :------------------------- |
| children | \`React.ReactNode \\| ((value: any) => React.ReactNode)\` | -       | Format the selected value. |

**\`children\` Prop Example:**

\`\`\`tsx
<Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
\`\`\`

**\`children\` Prop References:**

- See [External docs](https://external.example/en-US/docs)
`;

      const result = await parseTypesMarkdown(markdown);

      const valueData = result.exports.Value.type.data as ComponentTypeMeta;
      const childrenProp = valueData.props.children;
      expect(childrenProp.exampleText).toContain('<Select.Value>');
      expect(childrenProp.seeText).toBe(
        '- See [External docs](https://external.example/en-US/docs)',
      );
    });

    it('should not add seeText when no references are present', async () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop    | Type     | Default | Description       |
| :------ | :------- | :------ | :---------------- |
| variant | \`string\` | -       | The button variant |
`;

      const result = await parseTypesMarkdown(markdown);

      const buttonData = result.exports.Button.type.data as ComponentTypeMeta;
      expect(buttonData.props.variant.seeText).toBeUndefined();
      expect(buttonData.props.variant.see).toBeUndefined();
    });
  });

  describe('Export Groups with dotted variant names', () => {
    it('should match dotted variant names to undotted type headings', async () => {
      const markdown = `# Blocks

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Root

A simple component that displays a title and optional children.

**Root Props:**

| Prop     | Type              | Default | Description                       |
| :------- | :---------------- | :------ | :-------------------------------- |
| title*   | \`string\`          | -       | The title to display              |
| disabled | \`boolean\`         | -       | Whether the component is disabled |

### Part

A simple component.

**Part Props:**

| Prop     | Type              | Default | Description                       |
| :------- | :---------------- | :------ | :-------------------------------- |
| title*   | \`string\`          | -       | The title to display              |

## Export Groups

- \`Component.Root\`
- \`Component.Part\`
`;

      const result = await parseTypesMarkdown(markdown);

      // The variant names should be Component.Root and Component.Part
      expect(Object.keys(result.variantTypeNames)).toEqual(['Component.Root', 'Component.Part']);

      // Each variant should contain the matching type (Root or Part), not be empty
      expect(result.variantTypeNames['Component.Root']).toEqual(['Root']);
      expect(result.variantTypeNames['Component.Part']).toEqual(['Part']);

      // The exports should contain Root and Part, not be empty
      expect(Object.keys(result.exports).sort()).toEqual(['Part', 'Root']);
    });
  });
});
