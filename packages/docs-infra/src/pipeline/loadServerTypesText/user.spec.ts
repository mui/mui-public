import { describe, it, expect } from 'vitest';
import { parseTypesMarkdown } from './loadServerTypesText';

describe('loadServerTypesText', () => {
  describe('component parsing', () => {
    it('should parse a basic component without description', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "name": "Button",
              "props": {},
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse a component with description', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

A clickable button component
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "descriptionText": "A clickable button component",
              "name": "Button",
              "props": {},
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse props table with types and descriptions', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop     | Type                       | Default   | Description                    |
| :------- | :------------------------- | :-------- | :----------------------------- |
| variant  | \`"primary" \\| "secondary"\` | \`primary\` | The button variant             |
| disabled | \`boolean\`                  | -         | Whether the button is disabled |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "name": "Button",
              "props": {
                "disabled": {
                  "descriptionText": "Whether the button is disabled",
                  "typeText": "boolean",
                },
                "variant": {
                  "defaultText": "primary",
                  "descriptionText": "The button variant",
                  "typeText": ""primary" | "secondary"",
                },
              },
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse prop examples after props table', () => {
      const markdown = `# Select.Value API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Value

**Value Props:**

| Prop        | Type                                                   | Default | Description                                                               |
| :---------- | :----------------------------------------------------- | :------ | :------------------------------------------------------------------------ |
| children    | \`React.ReactNode \\| ((value: any) => React.ReactNode)\` | -       | Accepts a function that returns a ReactNode to format the selected value. |
| placeholder | \`React.ReactNode\`                                      | -       | The placeholder value to display when no value is selected.               |

**\`children\` Prop Example:**

\`\`\`tsx
<Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "name": "Value",
              "props": {
                "children": {
                  "descriptionText": "Accepts a function that returns a ReactNode to format the selected value.",
                  "exampleText": "\`\`\`tsx
        <Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
        \`\`\`",
                  "typeText": "React.ReactNode | ((value: any) => React.ReactNode)",
                },
                "placeholder": {
                  "descriptionText": "The placeholder value to display when no value is selected.",
                  "typeText": "React.ReactNode",
                },
              },
            },
            "name": "Value",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse data attributes table', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Data Attributes:**

| Attribute  | Type                     | Description                     |
| :--------- | :----------------------- | :------------------------------ |
| data-state | \`"active" \\| "inactive"\` | The current state of the button |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {
                "data-state": {
                  "descriptionText": "The current state of the button",
                  "type": ""active" | "inactive"",
                },
              },
              "name": "Button",
              "props": {},
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse CSS variables table', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button CSS Variables:**

| Variable           | Type     | Description                    |
| :----------------- | :------- | :----------------------------- |
| \`--button-bg\`      | \`color\`  | Background color of the button |
| \`--button-padding\` | \`length\` | Padding inside the button      |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {
                "--button-bg": {
                  "descriptionText": "Background color of the button",
                  "type": "color",
                },
                "--button-padding": {
                  "descriptionText": "Padding inside the button",
                  "type": "length",
                },
              },
              "dataAttributes": {},
              "name": "Button",
              "props": {},
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse component with all sections', () => {
      const markdown = `# Complete API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### CompleteButton

A fully-featured button

**CompleteButton Props:**

| Prop    | Type     | Default | Description |
| :------ | :------- | :------ | :---------- |
| variant | \`string\` | -       | -           |

**CompleteButton Data Attributes:**

| Attribute   | Type      | Description  |
| :---------- | :-------- | :----------- |
| data-active | \`boolean\` | Active state |

**CompleteButton CSS Variables:**

| Variable  | Type    | Description  |
| :-------- | :------ | :----------- |
| \`--color\` | \`color\` | Button color |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {
                "--color": {
                  "descriptionText": "Button color",
                  "type": "color",
                },
              },
              "dataAttributes": {
                "data-active": {
                  "descriptionText": "Active state",
                  "type": "boolean",
                },
              },
              "descriptionText": "A fully-featured button",
              "name": "CompleteButton",
              "props": {
                "variant": {
                  "typeText": "string",
                },
              },
            },
            "name": "CompleteButton",
            "type": "component",
          },
        ]
      `);
    });
  });

  describe('hook parsing', () => {
    it('should parse a basic hook without description', () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "name": "useCounter",
              "parameters": {},
              "returnValue": "type ReturnValue = number;",
            },
            "name": "useCounter",
            "type": "hook",
          },
        ]
      `);
    });

    it('should parse hook with description', () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

A hook for counting

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "descriptionText": "A hook for counting",
              "name": "useCounter",
              "parameters": {},
              "returnValue": "type ReturnValue = number;",
            },
            "name": "useCounter",
            "type": "hook",
          },
        ]
      `);
    });

    it('should parse parameters table', () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Parameters:**

| Parameter    | Type     | Default | Description         |
| :----------- | :------- | :------ | :------------------ |
| initialValue | \`number\` | \`0\`     | Initial count value |
| step?        | \`number\` | \`1\`     | Step increment      |

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "name": "useCounter",
              "parameters": {
                "initialValue": {
                  "defaultText": "0",
                  "descriptionText": "Initial count value",
                  "typeText": "number",
                },
                "step": {
                  "defaultText": "1",
                  "descriptionText": "Step increment",
                  "optional": true,
                  "typeText": "number",
                },
              },
              "returnValue": "type ReturnValue = number;",
            },
            "name": "useCounter",
            "type": "hook",
          },
        ]
      `);
    });

    it('should parse return value as table for object types', () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Return Value:**

| Property  | Type         | Description          |
| :-------- | :----------- | :------------------- |
| \`count\`   | \`number\`     | The current count    |
| \`increment\` | \`() => void\` | Increment the count |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "name": "useCounter",
              "parameters": {},
              "returnValue": {
                "count": {
                  "descriptionText": "The current count",
                  "typeText": "number",
                },
                "increment": {
                  "descriptionText": "Increment the count",
                  "typeText": "() => void",
                },
              },
            },
            "name": "useCounter",
            "type": "hook",
          },
        ]
      `);
    });
  });

  describe('raw type parsing', () => {
    it('should parse raw type exports', () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root.State

The state of the accordion root

\`\`\`typescript
type AccordionRootState = {
  open: boolean;
  disabled: boolean;
};
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "descriptionText": "The state of the accordion root",
              "formattedCode": "type AccordionRootState = {
          open: boolean;
          disabled: boolean;
        };",
              "name": "Accordion.Root.State",
            },
            "name": "Accordion.Root.State",
            "type": "raw",
          },
        ]
      `);
    });

    it('should parse re-export types', () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Root.Props

Re-export of [Root](#root) props.
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "descriptionText": "Re-export of [Root](#root) props.",
              "formattedCode": "",
              "name": "Root.Props",
              "reExportOf": {
                "name": "Root",
                "slug": "root",
                "suffix": "props",
              },
            },
            "name": "Root.Props",
            "type": "raw",
          },
        ]
      `);
    });
  });

  describe('multiple types', () => {
    it('should parse multiple components', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Root

The root button component

**Root Props:**

| Prop    | Type     | Default | Description |
| :------ | :------- | :------ | :---------- |
| variant | \`string\` | -       | Button variant |

### Trigger

The trigger element

**Trigger Props:**

| Prop     | Type      | Default | Description    |
| :------- | :-------- | :------ | :------------- |
| disabled | \`boolean\` | \`false\`  | Disable trigger |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "descriptionText": "The root button component",
              "name": "Root",
              "props": {
                "variant": {
                  "descriptionText": "Button variant",
                  "typeText": "string",
                },
              },
            },
            "name": "Root",
            "type": "component",
          },
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "descriptionText": "The trigger element",
              "name": "Trigger",
              "props": {
                "disabled": {
                  "defaultText": "false",
                  "descriptionText": "Disable trigger",
                  "typeText": "boolean",
                },
              },
            },
            "name": "Trigger",
            "type": "component",
          },
        ]
      `);
    });
  });

  describe('external types', () => {
    it('should parse External Types section', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type          | Default | Description |
| :--- | :------------ | :------ | :---------- |
| side | \`Side\`        | -       | The side    |

## External Types

#### Side

\`\`\`tsx
type Side = 'top' | 'bottom' | 'left' | 'right';
\`\`\`

#### Align

\`\`\`tsx
type Align = 'start' | 'center' | 'end';
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.externalTypes).toMatchInlineSnapshot(`
        {
          "Align": "type Align = 'start' | 'center' | 'end';",
          "Side": "type Side = 'top' | 'bottom' | 'left' | 'right';",
        }
      `);
    });
  });

  describe('required and optional markers', () => {
    it('should parse required props with * marker', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop      | Type     | Default | Description |
| :-------- | :------- | :------ | :---------- |
| variant*  | \`string\` | -       | Required    |
| disabled  | \`boolean\` | \`false\` | Optional    |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`
        [
          {
            "data": {
              "cssVariables": {},
              "dataAttributes": {},
              "name": "Button",
              "props": {
                "disabled": {
                  "defaultText": "false",
                  "descriptionText": "Optional",
                  "typeText": "boolean",
                },
                "variant": {
                  "descriptionText": "Required",
                  "required": true,
                  "typeText": "string",
                },
              },
            },
            "name": "Button",
            "type": "component",
          },
        ]
      `);
    });

    it('should parse optional parameters with ? marker', () => {
      const markdown = `# useCounter API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### useCounter

**useCounter Parameters:**

| Parameter | Type     | Default | Description |
| :-------- | :------- | :------ | :---------- |
| initial   | \`number\` | \`0\`     | Required    |
| step?     | \`number\` | \`1\`     | Optional    |

**useCounter Return Value:**

\`\`\`tsx
type ReturnValue = number;
\`\`\`
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes[0].data).toMatchInlineSnapshot(`
        {
          "name": "useCounter",
          "parameters": {
            "initial": {
              "defaultText": "0",
              "descriptionText": "Required",
              "typeText": "number",
            },
            "step": {
              "defaultText": "1",
              "descriptionText": "Optional",
              "optional": true,
              "typeText": "number",
            },
          },
          "returnValue": "type ReturnValue = number;",
        }
      `);
    });
  });

  describe('edge cases', () => {
    it('should handle empty types array', () => {
      const markdown = `# Empty API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes).toMatchInlineSnapshot(`[]`);
    });

    it('should handle missing default column value', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| name | \`string\` | -       | The name    |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes[0].data).toMatchInlineSnapshot(`
        {
          "cssVariables": {},
          "dataAttributes": {},
          "name": "Button",
          "props": {
            "name": {
              "descriptionText": "The name",
              "typeText": "string",
            },
          },
        }
      `);
    });

    it('should handle missing description column value', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| name | \`string\` | -       | -           |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.allTypes[0].data).toMatchInlineSnapshot(`
        {
          "cssVariables": {},
          "dataAttributes": {},
          "name": "Button",
          "props": {
            "name": {
              "typeText": "string",
            },
          },
        }
      `);
    });
  });

  describe('typeNameMap parsing', () => {
    it('should parse typeNameMap from metadata comment', () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

**Accordion.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State","AccordionTriggerState":"Accordion.Trigger.State"}'
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
          "AccordionTriggerState": "Accordion.Trigger.State",
        }
      `);
    });

    it('should return empty typeNameMap when not present', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toEqual({});
    });

    it('should handle malformed typeNameMap gracefully', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'typeNameMap: not-valid-json'
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.typeNameMap).toEqual({});
    });
  });

  describe('variantData parsing', () => {
    it('should create Default variant when no variant metadata is present', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.variantData).toMatchInlineSnapshot(`
        {
          "Default": {
            "typeNameMap": undefined,
            "types": [
              {
                "data": {
                  "cssVariables": {},
                  "dataAttributes": {},
                  "name": "Button",
                  "props": {
                    "id": {
                      "descriptionText": "The id",
                      "typeText": "string",
                    },
                  },
                },
                "name": "Button",
                "type": "component",
              },
            ],
          },
        }
      `);
    });

    it('should parse variantTypes and reconstruct variantData', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

**Button Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

### IconButton

**IconButton Props:**

| Prop | Type     | Default | Description  |
| :--- | :------- | :------ | :----------- |
| icon | \`string\` | -       | The icon name |

[//]: # 'variantTypes: {"CssModules":["Button"],"Tailwind":["Button","IconButton"]}'
`;

      const result = parseTypesMarkdown(markdown);

      expect(Object.keys(result.variantData)).toEqual(['CssModules', 'Tailwind']);

      // CssModules variant should only have Button
      expect(result.variantData.CssModules.types).toHaveLength(1);
      expect(result.variantData.CssModules.types[0].name).toBe('Button');

      // Tailwind variant should have both Button and IconButton
      expect(result.variantData.Tailwind.types).toHaveLength(2);
      expect(result.variantData.Tailwind.types.map((t) => t.name)).toEqual([
        'Button',
        'IconButton',
      ]);
    });

    it('should parse variantTypeNameMapKeys and include in variantData', () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

**Accordion.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| id   | \`string\` | -       | The id      |

[//]: # 'variantTypes: {"Default":["Accordion.Root"]}'
[//]: # 'variantTypeNameMapKeys: {"Default":["AccordionRootState"]}'
[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State"}'
`;

      const result = parseTypesMarkdown(markdown);

      expect(result.variantData.Default.typeNameMap).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
        }
      `);

      // Merged typeNameMap should also be present
      expect(result.typeNameMap).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
        }
      `);
    });

    it('should handle multiple variants with different typeNameMaps', () => {
      const markdown = `# Select API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Select.Root

**Select.Root Props:**

| Prop | Type     | Default | Description |
| :--- | :------- | :------ | :---------- |
| open | \`boolean\` | false   | Open state  |

### Select.Trigger

**Select.Trigger Props:**

| Prop     | Type     | Default | Description |
| :------- | :------- | :------ | :---------- |
| disabled | \`boolean\` | false   | Disabled    |

[//]: # 'variantTypes: {"CssModules":["Select.Root"],"Tailwind":["Select.Root","Select.Trigger"]}'
[//]: # 'variantTypeNameMapKeys: {"CssModules":["SelectRootState"],"Tailwind":["SelectRootState","SelectTriggerState"]}'
[//]: # 'typeNameMap: {"SelectRootState":"Select.Root.State","SelectTriggerState":"Select.Trigger.State"}'
`;

      const result = parseTypesMarkdown(markdown);

      // CssModules should have only SelectRootState
      expect(result.variantData.CssModules.typeNameMap).toMatchInlineSnapshot(`
        {
          "SelectRootState": "Select.Root.State",
        }
      `);

      // Tailwind should have both
      expect(result.variantData.Tailwind.typeNameMap).toMatchInlineSnapshot(`
        {
          "SelectRootState": "Select.Root.State",
          "SelectTriggerState": "Select.Trigger.State",
        }
      `);
    });

    it('should handle missing types in variantTypes gracefully', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'variantTypes: {"Default":["Button","NonExistent"]}'
`;

      const result = parseTypesMarkdown(markdown);

      // Should only include the type that exists in the markdown
      expect(result.variantData.Default.types).toHaveLength(1);
      expect(result.variantData.Default.types[0].name).toBe('Button');
    });

    it('should handle malformed variantTypes gracefully', () => {
      const markdown = `# Button API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Button

[//]: # 'variantTypes: not-valid-json'
`;

      const result = parseTypesMarkdown(markdown);

      // Should fall back to Default variant with all types
      expect(Object.keys(result.variantData)).toEqual(['Default']);
      expect(result.variantData.Default.types).toHaveLength(1);
    });

    it('should include typeNameMap in Default variant when present', () => {
      const markdown = `# Accordion API

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### Accordion.Root

[//]: # 'typeNameMap: {"AccordionRootState":"Accordion.Root.State"}'
`;

      const result = parseTypesMarkdown(markdown);

      // Without variantTypes, Default variant should include the merged typeNameMap
      expect(result.variantData.Default.typeNameMap).toMatchInlineSnapshot(`
        {
          "AccordionRootState": "Accordion.Root.State",
        }
      `);
    });
  });
});
