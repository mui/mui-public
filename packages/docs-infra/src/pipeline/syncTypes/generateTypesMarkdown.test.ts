import { describe, it, expect } from 'vitest';
import type {
  ComponentTypeMeta,
  HookTypeMeta,
  RawTypeMeta,
  TypesMeta,
} from '../loadServerTypesMeta';
import { generateTypesMarkdown, type GenerateTypesMarkdownOptions } from './generateTypesMarkdown';
import { organizeTypesByExport } from '../loadServerTypesText';

// Helper to create HAST from text
function textToHast(text: string) {
  return {
    type: 'root' as const,
    children: [
      {
        type: 'element' as const,
        tagName: 'p',
        properties: {},
        children: [{ type: 'text' as const, value: text }],
      },
    ],
  };
}

// Helper to create a RawTypeMeta for testing
function createRawTypeMeta(
  name: string,
  formattedCode: string,
  descriptionText?: string,
): RawTypeMeta {
  return {
    name,
    formattedCode,
    ...(descriptionText ? { descriptionText, description: textToHast(descriptionText) } : {}),
  };
}

/**
 * Helper to create GenerateTypesMarkdownOptions from flat types array.
 * This bridges the old test format to the new options-based API.
 */
function createOptions(
  name: string,
  types: TypesMeta[],
  typeNameMap: Record<string, string> = {},
  externalTypes: Record<string, string> = {},
): GenerateTypesMarkdownOptions {
  const variantData = { Default: { types, typeNameMap } };
  const organized = organizeTypesByExport(variantData, typeNameMap);
  return {
    name,
    organized,
    typeNameMap,
    externalTypes,
  };
}

/**
 * Helper to create options with explicit variantData for testing variant features.
 */
function createOptionsWithVariants(
  name: string,
  types: TypesMeta[],
  typeNameMap: Record<string, string>,
  externalTypes: Record<string, string>,
  variantData: Record<string, { types: TypesMeta[]; typeNameMap?: Record<string, string> }>,
): GenerateTypesMarkdownOptions {
  const organized = organizeTypesByExport(variantData, typeNameMap);
  return {
    name,
    organized,
    typeNameMap,
    externalTypes,
  };
}

describe('generateTypesMarkdown', () => {
  describe('component type generation', () => {
    it('should generate markdown for a basic component without description', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button
        "
      `);
    });

    it('should generate markdown for component with HAST description', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        description: textToHast('A clickable button component'),
        descriptionText: 'A clickable button component',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        A clickable button component
        "
      `);
    });

    it('should generate props table with types and descriptions', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: '"primary" | "secondary"',
            description: textToHast('The button variant'),
            descriptionText: 'The button variant',
            defaultText: 'primary',
          },
          disabled: {
            typeText: 'boolean',
            description: textToHast('Whether the button is disabled'),
            descriptionText: 'Whether the button is disabled',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop     | Type                       | Default   | Description                    |
        | :------- | :------------------------- | :-------- | :----------------------------- |
        | variant  | \`"primary" \\| "secondary"\` | \`primary\` | The button variant             |
        | disabled | \`boolean\`                  | -         | Whether the button is disabled |
        "
      `);
    });

    it('should generate prop examples after props table', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Select.Value',
        props: {
          children: {
            typeText: 'React.ReactNode | ((value: any) => React.ReactNode)',
            description: textToHast(
              'Accepts a function that returns a ReactNode to format the selected value.',
            ),
            descriptionText:
              'Accepts a function that returns a ReactNode to format the selected value.',
            exampleText:
              "```tsx\n<Select.Value>\n  {(value: string | null) => value ? labels[value] : 'No value'}\n</Select.Value>\n```",
          },
          placeholder: {
            typeText: 'React.ReactNode',
            description: textToHast('The placeholder value to display when no value is selected.'),
            descriptionText: 'The placeholder value to display when no value is selected.',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Select.Value', data: componentMeta },
      ];

      const result = await generateTypesMarkdown(createOptions('Select.Value API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Select.Value API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Value

        **Value Props:**

        | Prop        | Type                                                   | Default | Description                                                               |
        | :---------- | :----------------------------------------------------- | :------ | :------------------------------------------------------------------------ |
        | children    | \`React.ReactNode \\| ((value: any) => React.ReactNode)\` | -       | Accepts a function that returns a ReactNode to format the selected value. |
        | placeholder | \`React.ReactNode\`                                      | -       | The placeholder value to display when no value is selected.               |

        **\`children\` Prop Example:**

        \`\`\`tsx
        <Select.Value>{(value: string | null) => (value ? labels[value] : 'No value')}</Select.Value>
        \`\`\`
        "
      `);
    });

    it('should generate prop references as a bullet list', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Dialog.Trigger',
        props: {
          onClick: {
            typeText: '(event: React.MouseEvent) => void',
            description: textToHast('Callback fired when the trigger is clicked.'),
            descriptionText: 'Callback fired when the trigger is clicked.',
            seeText:
              '- See [docs.external.example](https://docs.external.example/en-US/docs/Web/API/Element/click_event) for further information.\n- See [External Docs](http://external.example)',
          },
          disabled: {
            typeText: 'boolean',
            description: textToHast('Whether the trigger is disabled.'),
            descriptionText: 'Whether the trigger is disabled.',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Dialog.Trigger', data: componentMeta },
      ];

      const result = await generateTypesMarkdown(createOptions('Dialog.Trigger API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Dialog.Trigger API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Trigger

        **Trigger Props:**

        | Prop     | Type                                | Default | Description                                 |
        | :------- | :---------------------------------- | :------ | :------------------------------------------ |
        | onClick  | \`(event: React.MouseEvent) => void\` | -       | Callback fired when the trigger is clicked. |
        | disabled | \`boolean\`                           | -       | Whether the trigger is disabled.            |

        **\`onClick\` Prop References:**

        - See [docs.external.example](https://docs.external.example/en-US/docs/Web/API/Element/click_event) for further information.
        - See [External Docs](http://external.example)
        "
      `);
    });

    it('should generate data attributes table', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {
          'data-state': {
            type: '"active" | "inactive"',
            description: textToHast('The current state of the button'),
            descriptionText: 'The current state of the button',
          },
        },
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Data Attributes:**

        | Attribute  | Type                     | Description                     |
        | :--------- | :----------------------- | :------------------------------ |
        | data-state | \`"active" \\| "inactive"\` | The current state of the button |
        "
      `);
    });

    it('should generate CSS variables table', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {
          '--button-bg': {
            type: 'color',
            description: textToHast('Background color of the button'),
            descriptionText: 'Background color of the button',
          },
          '--button-padding': {
            type: 'length',
            description: textToHast('Padding inside the button'),
            descriptionText: 'Padding inside the button',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Button API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button CSS Variables:**

        | Variable           | Type     | Description                    |
        | :----------------- | :------- | :----------------------------- |
        | \`--button-bg\`      | \`color\`  | Background color of the button |
        | \`--button-padding\` | \`length\` | Padding inside the button      |
        "
      `);
    });

    it('should handle component with all sections', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'CompleteButton',
        description: textToHast('A fully-featured button'),
        descriptionText: 'A fully-featured button',
        props: {
          variant: {
            typeText: 'string',
          },
        },
        dataAttributes: {
          'data-active': {
            type: 'boolean',
            description: textToHast('Active state'),
            descriptionText: 'Active state',
          },
        },
        cssVariables: {
          '--color': {
            type: 'color',
            description: textToHast('Button color'),
            descriptionText: 'Button color',
          },
        },
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'CompleteButton', data: componentMeta },
      ];

      const result = await generateTypesMarkdown(createOptions('Complete API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Complete API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### CompleteButton

        A fully-featured button

        **CompleteButton Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |

        **CompleteButton Data Attributes:**

        | Attribute   | Type      | Description  |
        | :---------- | :-------- | :----------- |
        | data-active | \`boolean\` | Active state |

        **CompleteButton CSS Variables:**

        | Variable  | Type    | Description  |
        | :-------- | :------ | :----------- |
        | \`--color\` | \`color\` | Button color |
        "
      `);
    });
  });

  describe('hook type generation', () => {
    it('should generate markdown for a basic hook without description', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useCounter API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
    });

    it('should generate markdown for hook with HAST description', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        description: textToHast('A hook for managing counter state'),
        descriptionText: 'A hook for managing counter state',
        parameters: {},
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useCounter API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        A hook for managing counter state

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
    });

    it('should generate parameters table', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {
          initialValue: {
            typeText: 'number',
            defaultText: '0',
            description: textToHast('The initial counter value'),
            descriptionText: 'The initial counter value',
          },
          step: {
            typeText: 'number',
            description: textToHast('Increment/decrement step'),
            descriptionText: 'Increment/decrement step',
          },
        },
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useCounter API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Parameters:**

        | Parameter    | Type     | Default | Description               |
        | :----------- | :------- | :------ | :------------------------ |
        | initialValue | \`number\` | \`0\`     | The initial counter value |
        | step         | \`number\` | -       | Increment/decrement step  |

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
    });

    it('should generate properties table when properties field is used', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useRender',
        properties: {
          className: {
            typeText: 'string',
            description: textToHast('CSS class name'),
            descriptionText: 'CSS class name',
          },
          style: {
            typeText: 'React.CSSProperties',
            required: true,
            description: textToHast('Inline styles'),
            descriptionText: 'Inline styles',
          },
        },
        returnValue: 'React.ReactElement',
        returnValueText: 'React.ReactElement',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useRender', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useRender API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useRender API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useRender

        **useRender Properties:**

        | Property  | Type                  | Default | Description    |
        | :-------- | :-------------------- | :------ | :------------- |
        | className | \`string\`              | -       | CSS class name |
        | style\\*   | \`React.CSSProperties\` | -       | Inline styles  |

        **useRender Return Value:**

        \`\`\`tsx
        type ReturnValue = React.ReactElement;
        \`\`\`
        "
      `);
    });

    it('should generate return value as string', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useCounter API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
    });

    it('should generate return value as table for object types', async () => {
      const hookMeta: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: {
          count: {
            typeText: 'number',
            description: textToHast('Current count value'),
            descriptionText: 'Current count value',
          },
          increment: {
            typeText: '() => void',
            description: textToHast('Function to increment counter'),
            descriptionText: 'Function to increment counter',
          },
          decrement: {
            typeText: '() => void',
            description: textToHast('Function to decrement counter'),
            descriptionText: 'Function to decrement counter',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hookMeta }];

      const result = await generateTypesMarkdown(createOptions('useCounter API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# useCounter API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        | Property  | Type         | Description                   |
        | :-------- | :----------- | :---------------------------- |
        | count     | \`number\`     | Current count value           |
        | increment | \`() => void\` | Function to increment counter |
        | decrement | \`() => void\` | Function to decrement counter |
        "
      `);
    });
  });

  describe('raw type generation', () => {
    it('should generate markdown for raw type exports', async () => {
      const typesMeta: TypesMeta[] = [
        {
          type: 'raw',
          name: 'ButtonProps',
          data: createRawTypeMeta(
            'ButtonProps',
            'type ButtonProps = {}',
            'Props for the Button component',
          ),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Types', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Types

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ## Additional Types

        ### ButtonProps

        Props for the Button component

        \`\`\`typescript
        type ButtonProps = {}
        \`\`\`
        "
      `);
      // Should include a code block with the formatted type
      expect(result).toMatch(/```typescript/);
    });

    it('should handle raw type without description', async () => {
      const typesMeta: TypesMeta[] = [
        {
          type: 'raw',
          name: 'Status',
          data: createRawTypeMeta('Status', 'type Status = string'),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Types', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Types

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ## Additional Types

        ### Status

        \`\`\`typescript
        type Status = string
        \`\`\`
        "
      `);
    });

    it('should use flat type name in code blocks for dotted names', async () => {
      // When a type has a dotted name like "Component.Root.State", the heading should
      // show the dotted name, but the code block must use the flat name "ComponentRootState"
      // because TypeScript type declarations cannot have dots in the type name.
      const typesMeta: TypesMeta[] = [
        {
          type: 'raw',
          name: 'Component.Root.State',
          data: createRawTypeMeta(
            'Component.Root.State',
            'type ComponentRootState = {\n  disabled: boolean;\n  active: boolean;\n}',
          ),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Types', typesMeta));

      // Heading should use dotted name
      expect(result).toContain('### Component.Root.State');
      // Code block should use flat name (ComponentRootState), not dotted name
      expect(result).toContain('type ComponentRootState = {');
      // Should NOT contain dots in type declaration
      expect(result).not.toMatch(/type Component\.Root\.State =/);
    });
  });

  describe('multiple type generation', () => {
    it('should generate markdown for multiple components', async () => {
      const button: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const input: ComponentTypeMeta = {
        name: 'Input',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Button', data: button },
        { type: 'component', name: 'Input', data: input },
      ];

      const result = await generateTypesMarkdown(createOptions('Components', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Components

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        ### Input
        "
      `);
    });

    it('should generate markdown for mixed types', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const hook: HookTypeMeta = {
        name: 'useButton',
        parameters: {},
        returnValue: 'void',
        returnValueText: 'void',
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Button', data: component },
        { type: 'hook', name: 'useButton', data: hook },
        {
          type: 'raw',
          name: 'ButtonProps',
          data: createRawTypeMeta('ButtonProps', 'type ButtonProps = object'),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Mixed API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Mixed API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        ### useButton

        **useButton Return Value:**

        \`\`\`tsx
        type ReturnValue = void;
        \`\`\`

        ## Additional Types

        ### ButtonProps

        \`\`\`typescript
        type ButtonProps = object
        \`\`\`
        "
      `);
    });
  });

  describe('markdown formatting', () => {
    it('should include autogeneration comment', async () => {
      const typesMeta: TypesMeta[] = [];
      const result = await generateTypesMarkdown(createOptions('Empty', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# Empty

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference
        "
      `);
    });

    it('should create proper heading hierarchy', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API Reference', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API Reference

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button
        "
      `);
    });

    it('should use proper table alignment', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: 'string',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |
        "
      `);
    });
  });

  describe('complex HAST descriptions', () => {
    it('should handle HAST with code blocks in descriptions', async () => {
      const descriptionWithCode = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Use this component like:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: { className: ['language-tsx'] },
                children: [{ type: 'text' as const, value: '<Button variant="primary" />' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithCode,
        descriptionText: 'Use this component like:\n\n```tsx\n<Button variant="primary" />\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        Use this component like:

        \`\`\`tsx
        <Button variant="primary" />
        \`\`\`
        "
      `);
    });

    it('should handle HAST with links in descriptions', async () => {
      const descriptionWithLink = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [
              { type: 'text' as const, value: 'See the ' },
              {
                type: 'element' as const,
                tagName: 'a',
                properties: { href: 'https://example.com' },
                children: [{ type: 'text' as const, value: 'documentation' }],
              },
              { type: 'text' as const, value: ' for more details.' },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithLink,
        descriptionText: 'See the [documentation](https://example.com) for more details.',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        See the [documentation](https://example.com) for more details.
        "
      `);
    });

    it('should handle HAST with lists in descriptions', async () => {
      const descriptionWithList = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'This component supports:' }],
          },
          {
            type: 'element' as const,
            tagName: 'ul',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Primary variant' }],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Secondary variant' }],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [{ type: 'text' as const, value: 'Disabled state' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        description: descriptionWithList,
        descriptionText:
          'This component supports:\n\n- Primary variant\n- Secondary variant\n- Disabled state',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        This component supports:

        - Primary variant
        - Secondary variant
        - Disabled state
        "
      `);
    });

    it('should handle HAST with inline code in prop descriptions', async () => {
      const propDescriptionWithCode = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [
              { type: 'text' as const, value: 'Set to ' },
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'true' }],
              },
              { type: 'text' as const, value: ' to disable the button.' },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          disabled: {
            typeText: 'boolean',
            description: propDescriptionWithCode,
            descriptionText: 'Set to `true` to disable the button.',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop     | Type      | Default | Description                          |
        | :------- | :-------- | :------ | :----------------------------------- |
        | disabled | \`boolean\` | -       | Set to \`true\` to disable the button. |
        "
      `);
    });

    it('should handle HAST with multiple paragraphs', async () => {
      const multiParagraphDescription = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'First paragraph with introduction.' }],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Second paragraph with more details.' }],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Third paragraph with examples.' }],
          },
        ],
      };

      const hook: HookTypeMeta = {
        name: 'useCounter',
        description: multiParagraphDescription,
        descriptionText:
          'First paragraph with introduction.\n\nSecond paragraph with more details.\n\nThird paragraph with examples.',
        parameters: {},
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        First paragraph with introduction.

        Second paragraph with more details.

        Third paragraph with examples.

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
    });

    it('should handle precomputed code blocks with dataPrecompute attribute', async () => {
      // Simulate a precomputed code block as would be generated by the syntax highlighter
      const precomputedCode = {
        Default: {
          source: {
            type: 'root' as const,
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const x = 42;' }],
              },
            ],
          },
        },
      };

      const descriptionWithPrecomputed = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Example code:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const x = 42;' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithPrecomputed,
        descriptionText: 'Example code:\n\n```\nconst x = 42;\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        Example code:

        \`\`\`
        const x = 42;
        \`\`\`
        "
      `);
      // The precomputed code should be expanded and converted to markdown code block
      expect(result).toMatch(/```[\s\S]*const x = 42;/);
    });

    it('should handle precomputed code with hastJson serialization', async () => {
      const hastJson = JSON.stringify({
        type: 'root',
        children: [
          {
            type: 'element',
            tagName: 'code',
            properties: {},
            children: [{ type: 'text', value: 'function hello() {}' }],
          },
        ],
      });

      const precomputedCode = {
        Default: {
          source: { hastJson },
        },
      };

      const descriptionWithHastJson = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'function hello() {}' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithHastJson,
        descriptionText: '```\nfunction hello() {}\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        \`\`\`
        function hello() {}
        \`\`\`
        "
      `);
    });

    it('should handle precomputed code with string source', async () => {
      const precomputedCode = {
        Default: {
          source: 'const greeting = "Hello";',
        },
      };

      const descriptionWithStringSource = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'const greeting = "Hello";' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithStringSource,
        descriptionText: '```\nconst greeting = "Hello";\n```',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        \`\`\`
        const greeting = "Hello";
        \`\`\`
        "
      `);
    });

    it('should handle malformed dataPrecompute gracefully', async () => {
      const descriptionWithInvalidPrecompute = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Before code' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: 'invalid json{',
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: 'fallback code' }],
              },
            ],
          },
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'After code' }],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Example',
        description: descriptionWithInvalidPrecompute,
        descriptionText: 'Before code\n\n```\nfallback code\n```\n\nAfter code',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Example', data: component }];

      // Should not throw, should handle gracefully
      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Example

        Before code

        \`\`\`
        fallback code
        \`\`\`

        After code
        "
      `);
      // When dataPrecompute is invalid, the original code should still be present
      expect(result).toContain('fallback code');
    });

    it('should handle precomputed code in prop descriptions', async () => {
      const precomputedCode = {
        Default: {
          source: {
            type: 'root' as const,
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: '<Button onClick={handler} />' }],
              },
            ],
          },
        },
      };

      const propDescriptionWithPrecomputed = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Usage example:' }],
          },
          {
            type: 'element' as const,
            tagName: 'pre',
            properties: {
              dataPrecompute: JSON.stringify(precomputedCode),
            },
            children: [
              {
                type: 'element' as const,
                tagName: 'code',
                properties: {},
                children: [{ type: 'text' as const, value: '<Button onClick={handler} />' }],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          onClick: {
            typeText: '() => void',
            description: propDescriptionWithPrecomputed,
            descriptionText: 'Usage example:`<Button onClick={handler} />`',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type         | Default | Description                                  |
        | :------ | :----------- | :------ | :------------------------------------------- |
        | onClick | \`() => void\` | -       | Usage example:\`<Button onClick={handler} />\` |
        "
      `);
    });

    it('should convert lists in prop descriptions to inline comma-separated content', async () => {
      const descriptionWithList = {
        type: 'root' as const,
        children: [
          {
            type: 'element' as const,
            tagName: 'p',
            properties: {},
            children: [{ type: 'text' as const, value: 'Supported variants:' }],
          },
          {
            type: 'element' as const,
            tagName: 'ul',
            properties: {},
            children: [
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'primary' }],
                  },
                ],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'secondary' }],
                  },
                ],
              },
              {
                type: 'element' as const,
                tagName: 'li',
                properties: {},
                children: [
                  {
                    type: 'element' as const,
                    tagName: 'p',
                    properties: {},
                    children: [{ type: 'text' as const, value: 'tertiary' }],
                  },
                ],
              },
            ],
          },
        ],
      };

      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: 'string',
            description: descriptionWithList,
            descriptionText: 'Supported variants:primary, secondary, tertiary',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description                                     |
        | :------ | :------- | :------ | :---------------------------------------------- |
        | variant | \`string\` | -       | Supported variants:primary, secondary, tertiary |
        "
      `);
    });
  });

  describe('optional and required markers', () => {
    it('should handle optional parameters in hooks', async () => {
      const hook: HookTypeMeta = {
        name: 'useCounter',
        parameters: {
          initialValue: {
            typeText: 'number',
            defaultText: '0',
            optional: true,
            description: textToHast('Initial counter value'),
            descriptionText: 'Initial counter value',
          },
          step: {
            typeText: 'number',
            optional: true,
            description: textToHast('Increment step'),
            descriptionText: 'Increment step',
          },
        },
        returnValue: 'number',
        returnValueText: 'number',
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Parameters:**

        | Parameter    | Type     | Default | Description           |
        | :----------- | :------- | :------ | :-------------------- |
        | initialValue | \`number\` | \`0\`     | Initial counter value |
        | step         | \`number\` | -       | Increment step        |

        **useCounter Return Value:**

        \`\`\`tsx
        type ReturnValue = number;
        \`\`\`
        "
      `);
      // Optional marker is stored in data but not currently rendered
      // If/when we add optional markers to the output, update this test
    });

    it('should handle required properties in components', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: 'string',
            required: true,
            description: textToHast('Button variant (required)'),
            descriptionText: 'Button variant (required)',
          },
          disabled: {
            typeText: 'boolean',
            description: textToHast('Disabled state (optional)'),
            descriptionText: 'Disabled state (optional)',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop      | Type      | Default | Description               |
        | :-------- | :-------- | :------ | :------------------------ |
        | variant\\* | \`string\`  | -       | Button variant (required) |
        | disabled  | \`boolean\` | -       | Disabled state (optional) |
        "
      `);
      // Required marker is stored in data but not currently rendered
      // If/when we add required markers to the output, update this test
    });

    it('should preserve optional flag in hook return value properties', async () => {
      const hook: HookTypeMeta = {
        name: 'useCounter',
        parameters: {},
        returnValue: {
          count: {
            typeText: 'number',
            description: textToHast('Current count'),
            descriptionText: 'Current count',
            required: true,
          },
          reset: {
            typeText: '() => void',
            description: textToHast('Optional reset function'),
            descriptionText: 'Optional reset function',
          },
        },
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useCounter', data: hook }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useCounter

        **useCounter Return Value:**

        | Property | Type         | Description             |
        | :------- | :----------- | :---------------------- |
        | count    | \`number\`     | Current count           |
        | reset    | \`() => void\` | Optional reset function |
        "
      `);
    });
  });

  describe('edge cases', () => {
    it('should handle empty types array', async () => {
      const result = await generateTypesMarkdown(createOptions('Empty API', []));

      expect(result).toMatchInlineSnapshot(`
        "# Empty API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference
        "
      `);
    });

    it('should handle component with empty props object', async () => {
      const component: ComponentTypeMeta = {
        name: 'Empty',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Empty', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Empty
        "
      `);
    });

    it('should handle hook with empty return value object', async () => {
      const hook: HookTypeMeta = {
        name: 'useEmpty',
        parameters: {},
        returnValue: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'hook', name: 'useEmpty', data: hook }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### useEmpty

        **useEmpty Return Value:**
        "
      `);
      // Empty return value objects still show the header currently
      // This could be considered a bug that should be fixed in the implementation
    });

    it('should handle prop with missing type', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: 'unknown',
            description: textToHast('Variant prop'),
            descriptionText: 'Variant prop',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type      | Default | Description  |
        | :------ | :-------- | :------ | :----------- |
        | variant | \`unknown\` | -       | Variant prop |
        "
      `);
    });

    it('should handle prop with missing description', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {
          variant: {
            typeText: 'string',
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];

      const result = await generateTypesMarkdown(createOptions('API', typesMeta));

      expect(result).toMatchInlineSnapshot(`
        "# API

        [//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

        ## API Reference

        ### Button

        **Button Props:**

        | Prop    | Type     | Default | Description |
        | :------ | :------- | :------ | :---------- |
        | variant | \`string\` | -       | -           |
        "
      `);
    });

    it('should include validate command hint in comment when path is provided', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };
      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];
      const options = {
        ...createOptions('Button API', typesMeta),
        path: 'src/app/docs/react/components/button/types.md',
      };

      const result = await generateTypesMarkdown(options);

      expect(result).toContain(
        "types.ts '<-- Autogenerated By (do not edit the following markdown directly), run: pnpm docs:validate docs/react/components/button'",
      );
    });

    it('should quote path in validate hint when it contains parentheses', async () => {
      const component: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };
      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: component }];
      const options = {
        ...createOptions('Button API', typesMeta),
        path: 'src/app/(docs)/react/components/button/types.md',
      };

      const result = await generateTypesMarkdown(options);

      expect(result).toContain(
        `types.ts '<-- Autogenerated By (do not edit the following markdown directly), run: pnpm docs:validate "(docs)/react/components/button"'`,
      );
    });
  });

  describe('duplicate type filtering (syncTypes integration)', () => {
    // These tests validate the filtering logic that removes flat-named types
    // when a corresponding namespaced version exists.
    // The actual filtering happens in syncTypes.ts, but we can verify the
    // expected behavior through the markdown generation.

    it('should NOT include flat types in output when namespaced equivalent exists', async () => {
      // In the real processing, if we have both:
      //   - Accordion.Item.ChangeEventReason (namespaced)
      //   - AccordionItemChangeEventReason (flat)
      // The flat version should be filtered out BEFORE markdown generation.
      // This test verifies the expected final output structure.

      // Only the namespaced type should be in the final output
      const typesMeta: TypesMeta[] = [
        {
          type: 'raw',
          name: 'Item.ChangeEventReason',
          data: createRawTypeMeta(
            'Item.ChangeEventReason',
            "type AccordionItemChangeEventReason = 'trigger-press' | 'none'",
          ),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Accordion', typesMeta));

      // Should have the namespaced heading
      expect(result).toContain('### Item.ChangeEventReason');
      // Should NOT have a flat-named heading
      expect(result).not.toContain('### AccordionItemChangeEventReason');
    });

    it('should keep flat types that have no namespaced equivalent', async () => {
      // Types like AccordionValue that don't have a Accordion.Value equivalent
      // should be kept in the output
      const typesMeta: TypesMeta[] = [
        {
          type: 'raw',
          name: 'AccordionValue',
          data: createRawTypeMeta('AccordionValue', 'type AccordionValue = any[]'),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Accordion', typesMeta));

      expect(result).toContain('### AccordionValue');
    });

    it('should add Additional Types heading for non-namespaced types when components are namespaced', async () => {
      // This test replicates the blocks-data-attr demo scenario:
      // - Components are namespaced (Component.Root, Component.Part)
      // - There's a non-namespaced additional type (InputType)
      const rootComponent: ComponentTypeMeta = {
        name: 'Root',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const partComponent: ComponentTypeMeta = {
        name: 'Part',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Component.Root', data: rootComponent },
        { type: 'component', name: 'Component.Part', data: partComponent },
        {
          type: 'raw',
          name: 'InputType',
          data: createRawTypeMeta('InputType', "type InputType = 'text' | 'number'"),
        },
      ];

      const result = await generateTypesMarkdown(createOptions('Component API', typesMeta));

      // Should have the Additional Types heading
      expect(result).toContain('## Additional Types');
      expect(result).toContain('### InputType');
    });
  });

  describe('external types generation', () => {
    it('should generate External Types section when external types are provided', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Root',
        props: {
          orientation: {
            typeText: 'Orientation',
            descriptionText: 'The orientation of the component',
            description: textToHast('The orientation of the component'),
          },
        },
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Component.Root', data: componentMeta },
      ];

      const externalTypes = {
        Orientation: "type Orientation = 'horizontal' | 'vertical';",
      };

      const result = await generateTypesMarkdown(
        createOptions('Component API', typesMeta, {}, externalTypes),
      );

      expect(result).toContain('## External Types');
      expect(result).toContain('### Orientation');
      expect(result).toContain("type Orientation = 'horizontal' | 'vertical'");
    });

    it('should not generate External Types section when no external types are provided', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Root',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Component.Root', data: componentMeta },
      ];

      const result = await generateTypesMarkdown(createOptions('Component API', typesMeta, {}, {}));

      expect(result).not.toContain('## External Types');
    });

    it('should generate multiple external types in the section', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Root',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Component.Root', data: componentMeta },
      ];

      const externalTypes = {
        Orientation: "type Orientation = 'horizontal' | 'vertical';",
        Side: "type Side = 'top' | 'bottom' | 'left' | 'right';",
        Align: "type Align = 'start' | 'center' | 'end';",
      };

      const result = await generateTypesMarkdown(
        createOptions('Component API', typesMeta, {}, externalTypes),
      );

      expect(result).toContain('## External Types');
      expect(result).toContain('### Orientation');
      expect(result).toContain('### Side');
      expect(result).toContain('### Align');
      expect(result).toContain("type Orientation = 'horizontal' | 'vertical'");
      expect(result).toContain("type Side = 'top' | 'bottom' | 'left' | 'right'");
      expect(result).toContain("type Align = 'start' | 'center' | 'end'");
    });
  });

  describe('typeNameMap embedding', () => {
    it('should embed typeNameMap as Canonical Types section when provided', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Root',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const rootStateMeta: RawTypeMeta = {
        name: 'Accordion.Root.State',
        formattedCode: 'type AccordionRootState = { open: boolean }',
      };

      const triggerStateMeta: RawTypeMeta = {
        name: 'Accordion.Trigger.State',
        formattedCode: 'type AccordionTriggerState = { active: boolean }',
      };

      // The flat aliases must be in the types array to be recognized as exported
      const rootStateAliasMeta: RawTypeMeta = {
        name: 'AccordionRootState',
        formattedCode: 'type AccordionRootState = { open: boolean }',
      };

      const triggerStateAliasMeta: RawTypeMeta = {
        name: 'AccordionTriggerState',
        formattedCode: 'type AccordionTriggerState = { active: boolean }',
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Accordion.Root', data: componentMeta },
        { type: 'raw', name: 'Accordion.Root.State', data: rootStateMeta },
        { type: 'raw', name: 'Accordion.Trigger.State', data: triggerStateMeta },
        // Flat aliases that users import from the default export
        { type: 'raw', name: 'AccordionRootState', data: rootStateAliasMeta },
        { type: 'raw', name: 'AccordionTriggerState', data: triggerStateAliasMeta },
      ];

      const typeNameMap = {
        AccordionRootState: 'Accordion.Root.State',
        AccordionTriggerState: 'Accordion.Trigger.State',
      };

      const result = await generateTypesMarkdown(
        createOptions('Accordion API', typesMeta, typeNameMap),
      );

      // Should have Canonical Types section with inverted mapping
      expect(result).toContain('## Canonical Types');
      expect(result).toContain('- `Accordion.Root.State`: `AccordionRootState`');
      expect(result).toContain('- `Accordion.Trigger.State`: `AccordionTriggerState`');
    });

    it('should not embed Canonical Types section when typeNameMap is empty', async () => {
      const componentMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: componentMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta, {}));

      expect(result).not.toContain('Canonical Types');
    });
  });

  describe('variantData embedding', () => {
    it('should embed Export Groups section when variantData is provided', async () => {
      const buttonMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const iconButtonMeta: ComponentTypeMeta = {
        name: 'IconButton',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Button', data: buttonMeta },
        { type: 'component', name: 'IconButton', data: iconButtonMeta },
      ];

      const variantData = {
        CssModules: { types: [{ type: 'component' as const, name: 'Button', data: buttonMeta }] },
        Tailwind: {
          types: [
            { type: 'component' as const, name: 'Button', data: buttonMeta },
            { type: 'component' as const, name: 'IconButton', data: iconButtonMeta },
          ],
        },
      };

      const result = await generateTypesMarkdown(
        createOptionsWithVariants('Button API', typesMeta, {}, {}, variantData),
      );

      // Should have Export Groups section
      expect(result).toContain('## Export Groups');
      expect(result).toContain('- `CssModules`: `Button`');
      expect(result).toContain('- `Tailwind`: `Button`, `IconButton`');
    });

    it('should embed Export Groups and Canonical Types with variant annotations when variants have typeNameMaps', async () => {
      const rootMeta: ComponentTypeMeta = {
        name: 'Root',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const triggerMeta: ComponentTypeMeta = {
        name: 'Trigger',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const rootStateMeta: RawTypeMeta = {
        name: 'Accordion.Root.State',
        formattedCode: 'type AccordionRootState = { open: boolean }',
      };

      const triggerStateMeta: RawTypeMeta = {
        name: 'Accordion.Trigger.State',
        formattedCode: 'type AccordionTriggerState = { active: boolean }',
      };

      // Flat alias types that users import
      const rootStateAliasMeta: RawTypeMeta = {
        name: 'AccordionRootState',
        formattedCode: 'type AccordionRootState = { open: boolean }',
      };

      const triggerStateAliasMeta: RawTypeMeta = {
        name: 'AccordionTriggerState',
        formattedCode: 'type AccordionTriggerState = { active: boolean }',
      };

      const typesMeta: TypesMeta[] = [
        { type: 'component', name: 'Accordion.Root', data: rootMeta },
        { type: 'component', name: 'Accordion.Trigger', data: triggerMeta },
        { type: 'raw', name: 'Accordion.Root.State', data: rootStateMeta },
        { type: 'raw', name: 'Accordion.Trigger.State', data: triggerStateMeta },
      ];

      const variantData = {
        CssModules: {
          types: [
            { type: 'component' as const, name: 'Accordion.Root', data: rootMeta },
            { type: 'raw' as const, name: 'Accordion.Root.State', data: rootStateMeta },
            { type: 'raw' as const, name: 'AccordionRootState', data: rootStateAliasMeta },
          ],
          typeNameMap: { AccordionRootState: 'Accordion.Root.State' },
        },
        Tailwind: {
          types: [
            { type: 'component' as const, name: 'Accordion.Root', data: rootMeta },
            { type: 'component' as const, name: 'Accordion.Trigger', data: triggerMeta },
            { type: 'raw' as const, name: 'Accordion.Root.State', data: rootStateMeta },
            { type: 'raw' as const, name: 'Accordion.Trigger.State', data: triggerStateMeta },
            { type: 'raw' as const, name: 'AccordionRootState', data: rootStateAliasMeta },
            { type: 'raw' as const, name: 'AccordionTriggerState', data: triggerStateAliasMeta },
          ],
          typeNameMap: {
            AccordionRootState: 'Accordion.Root.State',
            AccordionTriggerState: 'Accordion.Trigger.State',
          },
        },
      };

      const mergedTypeNameMap = {
        AccordionRootState: 'Accordion.Root.State',
        AccordionTriggerState: 'Accordion.Trigger.State',
      };

      const result = await generateTypesMarkdown(
        createOptionsWithVariants('Accordion API', typesMeta, mergedTypeNameMap, {}, variantData),
      );

      // Should have Export Groups section
      expect(result).toContain('## Export Groups');
      expect(result).toContain('`CssModules`');
      expect(result).toContain('`Accordion.Root`');
      expect(result).toContain('`Tailwind`');

      // Should have Canonical Types section
      expect(result).toContain('## Canonical Types');
      expect(result).toContain('`Accordion.Root.State`');
      expect(result).toContain('`AccordionRootState`');
      expect(result).toContain('`Accordion.Trigger.State`');
      expect(result).toContain('`AccordionTriggerState`');
    });

    it('should not embed variant metadata when only Default variant exists', async () => {
      const buttonMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: buttonMeta }];

      const variantData = {
        Default: { types: [{ type: 'component' as const, name: 'Button', data: buttonMeta }] },
      };

      const result = await generateTypesMarkdown(
        createOptionsWithVariants('Button API', typesMeta, {}, {}, variantData),
      );

      // Should NOT embed Export Groups for single Default variant
      expect(result).not.toContain('Export Groups');
    });

    it('should not embed any variant metadata when variantData is not provided', async () => {
      const buttonMeta: ComponentTypeMeta = {
        name: 'Button',
        props: {},
        dataAttributes: {},
        cssVariables: {},
      };

      const typesMeta: TypesMeta[] = [{ type: 'component', name: 'Button', data: buttonMeta }];

      const result = await generateTypesMarkdown(createOptions('Button API', typesMeta));

      expect(result).not.toContain('Export Groups');
    });
  });
});
