import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { updatePageIndex } from './updatePageIndex';
import type { PageMetadata } from './metadataToMarkdown';

const TEST_DIR = join(__dirname, '.test-updatePageIndex');

describe('updatePageIndex', () => {
  beforeEach(async () => {
    // Create test directory
    await mkdir(TEST_DIR, { recursive: true });
    await mkdir(join(TEST_DIR, 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'components', 'button'), { recursive: true });
  });

  afterEach(async () => {
    // Clean up test directory
    await rm(TEST_DIR, { recursive: true, force: true });
  });

  it('should create new index file when none exists', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should update existing index file with new page', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Checkbox](./checkbox/page.mdx) - A checkbox component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should update existing page metadata', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - Old description.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

Old description.

[Read more](./button/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'Updated button component with new features.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      Updated button component with new features.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle custom index file name', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
      indexFileName: 'index.mdx',
    });

    const indexPath = join(TEST_DIR, 'components', 'index.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle metadata with openGraph', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
      keywords: ['interactive', 'input'],
      openGraph: {
        title: 'Button Component',
        description: 'A comprehensive button component.',
        images: [
          {
            url: 'https://example.com/button.png',
            width: 800,
            height: 600,
            alt: 'Button preview',
          },
        ],
      },
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button Component](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button Component

      A comprehensive button component.

      ![Button preview](https://example.com/button.png)

      - Keywords: interactive, input

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should preserve order from existing index', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Checkbox](./checkbox/page.mdx) - A checkbox component.
- [Input](./input/page.mdx) - An input component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)

## Input

An input component.

[Read more](./input/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    // Button should be added at the end, preserving Checkbox -> Input order
    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should correctly resolve index path from nested page structure', async () => {
    // Test the actual path structure: app/components/checkbox/page.mdx -> app/components/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'checkbox'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'checkbox',
      path: './checkbox/page.mdx',
      title: 'Checkbox',
      description: 'A checkbox component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'checkbox', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    // Index should be at app/components/page.mdx (not app/components/checkbox/page.mdx)
    const indexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# Components');
    expect(content).toContain('[Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)');
    expect(content).toContain('A checkbox component.');
  });

  it('should derive index title from directory name when not provided', async () => {
    // Create a directory with kebab-case name
    await mkdir(join(TEST_DIR, 'ui-components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'ui-components', 'button'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Don't provide indexTitle - should derive "Ui Components" from "ui-components"
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'ui-components', 'button', 'page.mdx'),
      metadata,
    });

    const indexPath = join(TEST_DIR, 'ui-components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# Ui Components');
    expect(content).toMatchInlineSnapshot(`
      "# Ui Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should recursively update parent indexes when updateParents is true', async () => {
    // Create a three-level structure: app/components/button/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });

    // Create the top-level app index file to mark the boundary
    await writeFile(join(TEST_DIR, 'app', 'page.mdx'), '# App\n\n', 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with parent updating enabled and baseDir set to app
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Verify the immediate parent (components/page.mdx) was created
    const componentsIndexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const componentsContent = await readFile(componentsIndexPath, 'utf-8');
    expect(componentsContent).toContain('# Components');
    expect(componentsContent).toContain('[Button](#button)');

    // Verify the grandparent (app/page.mdx) was updated
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Full Docs](./components/page.mdx)');
  });

  it('should respect include filter and skip indexes outside included paths', async () => {
    // Create a structure with both included and excluded paths
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });
    await mkdir(join(TEST_DIR, 'excluded'), { recursive: true });
    await mkdir(join(TEST_DIR, 'excluded', 'secret'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with include filter - only 'app' and 'src/app' are included
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      include: ['app', 'src/app'],
    });

    // Verify the index was created (within included path)
    const indexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const indexExists = await readFile(indexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(indexExists).toBe(true);

    // Try to update an index outside the included paths
    const excludedMetadata: PageMetadata = {
      slug: 'secret',
      path: './secret/page.mdx',
      title: 'Secret',
      description: 'A secret page.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'excluded', 'secret', 'page.mdx'),
      metadata: excludedMetadata,
      baseDir: TEST_DIR,
      include: ['app', 'src/app'],
    });

    // Verify the index was NOT created (outside included path)
    const excludedIndexPath = join(TEST_DIR, 'excluded', 'page.mdx');
    const excludedIndexExists = await readFile(excludedIndexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(excludedIndexExists).toBe(false);
  });

  it('should respect exclude filter and skip indexes in excluded paths', async () => {
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'private'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'private', 'internal'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'internal',
      path: './internal/page.mdx',
      title: 'Internal',
      description: 'Internal page.',
    };

    // Update with exclude filter
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'private', 'internal', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      exclude: ['app/private'],
    });

    // Verify the index was NOT created (in excluded path)
    const indexPath = join(TEST_DIR, 'app', 'private', 'page.mdx');
    const indexExists = await readFile(indexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(indexExists).toBe(false);
  });

  it('should respect filters when recursively updating parents', async () => {
    // Create a three-level structure
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });

    // Create the top-level app index
    await writeFile(join(TEST_DIR, 'app', 'page.mdx'), '# App\n\n', 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with recursive parents but include filter that only allows 'app/components'
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      updateParents: true,
      include: ['app/components'],
    });

    // Verify the components index was created (within filter)
    const componentsIndexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const componentsContent = await readFile(componentsIndexPath, 'utf-8');
    expect(componentsContent).toContain('[Button](#button)');

    // Verify the app index was NOT updated (outside filter)
    const appContent = await readFile(join(TEST_DIR, 'app', 'page.mdx'), 'utf-8');
    expect(appContent).not.toContain('[Components](#components)');
    expect(appContent).toBe('# App\n\n'); // Should still be the original content
  });

  it('should preserve route groups in paths when creating index', async () => {
    // Create a structure with Next.js route groups: app/(public)/(content)/react/page.mdx
    // Parent directory (skipping route groups): app
    // Index created at: app/page.mdx
    // Path in index: ./(public)/(content)/react/page.mdx (preserves route groups)
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)', 'react'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'react',
      path: './(public)/(content)/react/page.mdx',
      title: 'React',
      description: 'React components.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', '(content)', 'react', 'page.mdx'),
      metadata,
    });

    // Index should be created at app/page.mdx (route groups are skipped)
    const indexPath = join(TEST_DIR, 'app', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# App');
    expect(content).toContain('[React](#react)');
    // Path should preserve route groups for correct relative path from app/
    expect(content).toContain('[Full Docs](./(public)/(content)/react/page.mdx)');
  });

  it('should include route groups in paths when recursively updating parent', async () => {
    // Create structure: app/(public)/(content)/react/page.mdx
    // Parent (skipping route groups): app
    // Index created at: app/page.mdx with path ./(public)/(content)/react/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)', 'react'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'react',
      path: './(public)/(content)/react/page.mdx',
      title: 'React',
      description: 'React components.',
    };

    // Enable recursive parent updates
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', '(content)', 'react', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Index should be at app/page.mdx (route groups are skipped)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[React](#react)');
    // Path should include route groups for correct relative path from app/
    expect(appContent).toContain('[Full Docs](./(public)/(content)/react/page.mdx)');
  });

  it('should handle multiple nested route groups correctly', async () => {
    // Create: app/(auth)/(protected)/(admin)/settings/page.mdx
    // Parent (skipping all route groups): app
    // Index created at: app/page.mdx with path ./(auth)/(protected)/(admin)/settings/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)', 'settings'), {
      recursive: true,
    });

    const metadata: PageMetadata = {
      slug: 'settings',
      path: './(auth)/(protected)/(admin)/settings/page.mdx',
      title: 'Settings',
      description: 'Admin settings.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)', 'settings', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Index at app/page.mdx (all route groups skipped)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Settings](#settings)');
    // Path should preserve all route groups
    expect(appContent).toContain('[Full Docs](./(auth)/(protected)/(admin)/settings/page.mdx)');
  });

  it('should handle mixed route groups and regular directories', async () => {
    // Create: app/(public)/components/(forms)/input/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components', '(forms)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components', '(forms)', 'input'), {
      recursive: true,
    });

    const metadata: PageMetadata = {
      slug: 'input',
      path: './(public)/components/(forms)/input/page.mdx',
      title: 'Input',
      description: 'Input component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', 'components', '(forms)', 'input', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // The parent index is created at app/page.mdx (route groups skipped)
    // It contains a reference to the components index (which was recursively created)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Full Docs](./(public)/components/page.mdx)');
    // Input should be listed as a section under Components
    expect(appContent).toContain('- Input');
  });

  it('should not lose child pages when multiple concurrent updates occur', async () => {
    // This test ensures that when multiple child directories update the same parent index
    // concurrently, all child pages are preserved in the final index.
    // This prevents a race condition where re-reading the file during parent updates
    // could cause some pages to be lost.

    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'overview'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'handbook'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'utils'), { recursive: true });

    const overviewMeta: PageMetadata = {
      slug: 'overview',
      path: './overview/page.mdx',
      title: 'Overview',
      description: 'Overview section.',
    };

    const componentsMeta: PageMetadata = {
      slug: 'components',
      path: './components/page.mdx',
      title: 'Components',
      description: 'Components section.',
    };

    const handbookMeta: PageMetadata = {
      slug: 'handbook',
      path: './handbook/page.mdx',
      title: 'Handbook',
      description: 'Handbook section.',
    };

    const utilsMeta: PageMetadata = {
      slug: 'utils',
      path: './utils/page.mdx',
      title: 'Utils',
      description: 'Utils section.',
    };

    // Simulate concurrent updates by running all updates in parallel
    await Promise.all([
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'overview', 'page.mdx'),
        metadata: overviewMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'components', 'page.mdx'),
        metadata: componentsMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'handbook', 'page.mdx'),
        metadata: handbookMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'utils', 'page.mdx'),
        metadata: utilsMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
    ]);

    // Verify that ALL four child pages are present in the parent index
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');

    // All four pages should be present
    expect(appContent).toContain('[Overview](#overview)');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Handbook](#handbook)');
    expect(appContent).toContain('[Utils](#utils)');

    // Verify all sections are present
    expect(appContent).toContain('## Overview');
    expect(appContent).toContain('## Components');
    expect(appContent).toContain('## Handbook');
    expect(appContent).toContain('## Utils');

    // Count the number of H2 headings to ensure we have exactly 4
    const h2Count = (appContent.match(/^## /gm) || []).length;
    expect(h2Count).toBe(4);
  });

  it('should handle metadata with parts array', async () => {
    const metadata: PageMetadata = {
      slug: 'alert-dialog',
      path: './alert-dialog/page.mdx',
      title: 'Alert Dialog',
      description: 'An alert dialog component.',
      parts: ['Root', 'Trigger', 'Popup', 'Portal', 'Backdrop'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'alert-dialog', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Alert Dialog](#alert-dialog) - [Full Docs](./alert-dialog/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Alert Dialog

      An alert dialog component.

      - Parts: Root, Trigger, Popup, Portal, Backdrop

      [Read more](./alert-dialog/page.mdx)
      "
    `);
  });

  it('should handle metadata with props, dataAttributes, and cssVariables', async () => {
    const metadata: PageMetadata = {
      slug: 'tooltip',
      path: './tooltip/page.mdx',
      title: 'Tooltip',
      description: 'A tooltip component.',
      parts: ['Root', 'Trigger', 'Popup'],
      props: ['align', 'className', 'defaultOpen', 'open', 'side'],
      dataAttributes: ['data-align', 'data-open', 'data-side'],
      cssVariables: ['--anchor-height', '--anchor-width', '--transform-origin'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'tooltip', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Tooltip](#tooltip) - [Full Docs](./tooltip/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Tooltip

      A tooltip component.

      - Parts: Root, Trigger, Popup
      - Props: align, className, defaultOpen, open, side
      - Data Attributes: data-align, data-open, data-side
      - CSS Variables: --anchor-height, --anchor-width, --transform-origin

      [Read more](./tooltip/page.mdx)
      "
    `);
  });

  it('should update existing metadata with new parts and props', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
      parts: ['Root', 'Icon'],
      props: ['className', 'disabled', 'onClick'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      - Parts: Root, Icon
      - Props: className, disabled, onClick

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle batch updates with parts and props', async () => {
    const metadataList: PageMetadata[] = [
      {
        slug: 'checkbox',
        path: './checkbox/page.mdx',
        title: 'Checkbox',
        description: 'A checkbox component.',
        parts: ['Root', 'Indicator'],
        props: ['checked', 'className', 'disabled'],
      },
      {
        slug: 'switch',
        path: './switch/page.mdx',
        title: 'Switch',
        description: 'A switch component.',
        parts: ['Root', 'Thumb'],
        props: ['checked', 'className', 'onCheckedChange'],
        dataAttributes: ['data-checked', 'data-disabled'],
      },
    ];

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');

    await updatePageIndex({
      pagePath: indexPath,
      metadataList,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)
      - [Switch](#switch) - [Full Docs](./switch/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Checkbox

      A checkbox component.

      - Parts: Root, Indicator
      - Props: checked, className, disabled

      [Read more](./checkbox/page.mdx)

      ## Switch

      A switch component.

      - Parts: Root, Thumb
      - Props: checked, className, onCheckedChange
      - Data Attributes: data-checked, data-disabled

      [Read more](./switch/page.mdx)
      "
    `);
  });
});
