import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, rm, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { updatePageIndex } from './updatePageIndex';
import type { PageMetadata } from './metadataToMarkdown';

const TEST_DIR = join(__dirname, '.test-updatePageIndex');

describe('updatePageIndex', () => {
  beforeEach(async () => {
    // Create test directory
    await mkdir(TEST_DIR, { recursive: true });
    await mkdir(join(TEST_DIR, 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'components', 'button'), { recursive: true });
  });

  afterEach(async () => {
    // Clean up test directory
    await rm(TEST_DIR, { recursive: true, force: true });
  });

  it('should create new index file when none exists', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should update existing index file with new page', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Checkbox](./checkbox/page.mdx) - A checkbox component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Checkbox](./checkbox/page.mdx)
      - [Button](#button) [New] - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should update existing page metadata', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](./button/page.mdx) - Old description.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

Old description.

[Read more](./button/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'Updated button component with new features.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'
      "
    `);
  });

  it('should handle custom index file name', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
      indexFileName: 'index.mdx',
    });

    const indexPath = join(TEST_DIR, 'components', 'index.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle metadata with openGraph', async () => {
    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
      keywords: ['interactive', 'input'],
      openGraph: {
        title: 'Button Component',
        description: 'A comprehensive button component.',
        images: [
          {
            url: 'https://example.com/button.png',
            width: 800,
            height: 600,
            alt: 'Button preview',
          },
        ],
      },
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button Component](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button Component

      A comprehensive button component.

      ![Button preview](https://example.com/button.png)

      - Keywords: interactive, input

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should preserve order from existing index', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Checkbox](./checkbox/page.mdx) - A checkbox component.
- [Input](./input/page.mdx) - An input component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)

## Input

An input component.

[Read more](./input/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    // Button should be added at the end, preserving Checkbox -> Input order
    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Checkbox](./checkbox/page.mdx)
      - [Input](./input/page.mdx)
      - [Button](#button) [New] - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should correctly resolve index path from nested page structure', async () => {
    // Test the actual path structure: app/components/checkbox/page.mdx -> app/components/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'checkbox'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'checkbox',
      path: './checkbox/page.mdx',
      title: 'Checkbox',
      description: 'A checkbox component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'checkbox', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    // Index should be at app/components/page.mdx (not app/components/checkbox/page.mdx)
    const indexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# Components');
    expect(content).toContain('[Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)');
    expect(content).toContain('A checkbox component.');
  });

  it('should derive index title from directory name when not provided', async () => {
    // Create a directory with kebab-case name
    await mkdir(join(TEST_DIR, 'ui-components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'ui-components', 'button'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Don't provide indexTitle - should derive "Ui Components" from "ui-components"
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'ui-components', 'button', 'page.mdx'),
      metadata,
    });

    const indexPath = join(TEST_DIR, 'ui-components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# Ui Components');
    expect(content).toMatchInlineSnapshot(`
      "# Ui Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should recursively update parent indexes when updateParents is true', async () => {
    // Create a three-level structure: app/components/button/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });

    // Create the top-level app index file to mark the boundary
    await writeFile(
      join(TEST_DIR, 'app', 'page.mdx'),
      "# App\n\n[//]: # 'This file is autogenerated'\n\n",
      'utf-8',
    );

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with parent updating enabled and baseDir set to app
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Verify the immediate parent (components/page.mdx) was created
    const componentsIndexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const componentsContent = await readFile(componentsIndexPath, 'utf-8');
    expect(componentsContent).toContain('# Components');
    expect(componentsContent).toContain('[Button](#button)');

    // Verify the grandparent (app/page.mdx) was updated
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Full Docs](./components/page.mdx)');
  });

  it('should respect include filter and skip indexes outside included paths', async () => {
    // Create a structure with both included and excluded paths
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });
    await mkdir(join(TEST_DIR, 'excluded'), { recursive: true });
    await mkdir(join(TEST_DIR, 'excluded', 'secret'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with include filter - only 'app' and 'src/app' are included
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      include: ['app', 'src/app'],
    });

    // Verify the index was created (within included path)
    const indexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const indexExists = await readFile(indexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(indexExists).toBe(true);

    // Try to update an index outside the included paths
    const excludedMetadata: PageMetadata = {
      slug: 'secret',
      path: './secret/page.mdx',
      title: 'Secret',
      description: 'A secret page.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'excluded', 'secret', 'page.mdx'),
      metadata: excludedMetadata,
      baseDir: TEST_DIR,
      include: ['app', 'src/app'],
    });

    // Verify the index was NOT created (outside included path)
    const excludedIndexPath = join(TEST_DIR, 'excluded', 'page.mdx');
    const excludedIndexExists = await readFile(excludedIndexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(excludedIndexExists).toBe(false);
  });

  it('should respect exclude filter and skip indexes in excluded paths', async () => {
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'private'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'private', 'internal'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'internal',
      path: './internal/page.mdx',
      title: 'Internal',
      description: 'Internal page.',
    };

    // Update with exclude filter
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'private', 'internal', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      exclude: ['app/private'],
    });

    // Verify the index was NOT created (in excluded path)
    const indexPath = join(TEST_DIR, 'app', 'private', 'page.mdx');
    const indexExists = await readFile(indexPath, 'utf-8').then(
      () => true,
      () => false,
    );
    expect(indexExists).toBe(false);
  });

  it('should respect filters when recursively updating parents', async () => {
    // Create a three-level structure
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components', 'button'), { recursive: true });

    // Create the top-level app index
    await writeFile(join(TEST_DIR, 'app', 'page.mdx'), '# App\n\n', 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
    };

    // Update with recursive parents but include filter that only allows 'app/components'
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', 'components', 'button', 'page.mdx'),
      metadata,
      baseDir: TEST_DIR,
      updateParents: true,
      include: ['app/components'],
    });

    // Verify the components index was created (within filter)
    const componentsIndexPath = join(TEST_DIR, 'app', 'components', 'page.mdx');
    const componentsContent = await readFile(componentsIndexPath, 'utf-8');
    expect(componentsContent).toContain('[Button](#button)');

    // Verify the app index was NOT updated (outside filter)
    const appContent = await readFile(join(TEST_DIR, 'app', 'page.mdx'), 'utf-8');
    expect(appContent).not.toContain('[Components](#components)');
    expect(appContent).toBe('# App\n\n'); // Should still be the original content
  });

  it('should preserve route groups in paths when creating index', async () => {
    // Create a structure with Next.js route groups: app/(public)/(content)/react/page.mdx
    // Parent directory (skipping route groups): app
    // Index created at: app/page.mdx
    // Path in index: ./(public)/(content)/react/page.mdx (preserves route groups)
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)', 'react'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'react',
      path: './(public)/(content)/react/page.mdx',
      title: 'React',
      description: 'React components.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', '(content)', 'react', 'page.mdx'),
      metadata,
    });

    // Index should be created at app/page.mdx (route groups are skipped)
    const indexPath = join(TEST_DIR, 'app', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toContain('# App');
    expect(content).toContain('[React](#react)');
    // Path should preserve route groups for correct relative path from app/
    expect(content).toContain('[Full Docs](./(public)/(content)/react/page.mdx)');
  });

  it('should include route groups in paths when recursively updating parent', async () => {
    // Create structure: app/(public)/(content)/react/page.mdx
    // Parent (skipping route groups): app
    // Index created at: app/page.mdx with path ./(public)/(content)/react/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', '(content)', 'react'), { recursive: true });

    const metadata: PageMetadata = {
      slug: 'react',
      path: './(public)/(content)/react/page.mdx',
      title: 'React',
      description: 'React components.',
    };

    // Enable recursive parent updates
    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', '(content)', 'react', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Index should be at app/page.mdx (route groups are skipped)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[React](#react)');
    // Path should include route groups for correct relative path from app/
    expect(appContent).toContain('[Full Docs](./(public)/(content)/react/page.mdx)');
  });

  it('should handle multiple nested route groups correctly', async () => {
    // Create: app/(auth)/(protected)/(admin)/settings/page.mdx
    // Parent (skipping all route groups): app
    // Index created at: app/page.mdx with path ./(auth)/(protected)/(admin)/settings/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)', 'settings'), {
      recursive: true,
    });

    const metadata: PageMetadata = {
      slug: 'settings',
      path: './(auth)/(protected)/(admin)/settings/page.mdx',
      title: 'Settings',
      description: 'Admin settings.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(auth)', '(protected)', '(admin)', 'settings', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // Index at app/page.mdx (all route groups skipped)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Settings](#settings)');
    // Path should preserve all route groups
    expect(appContent).toContain('[Full Docs](./(auth)/(protected)/(admin)/settings/page.mdx)');
  });

  it('should handle mixed route groups and regular directories', async () => {
    // Create: app/(public)/components/(forms)/input/page.mdx
    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components', '(forms)'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', '(public)', 'components', '(forms)', 'input'), {
      recursive: true,
    });

    const metadata: PageMetadata = {
      slug: 'input',
      path: './(public)/components/(forms)/input/page.mdx',
      title: 'Input',
      description: 'Input component.',
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'app', '(public)', 'components', '(forms)', 'input', 'page.mdx'),
      metadata,
      updateParents: true,
      baseDir: join(TEST_DIR, 'app'),
    });

    // The parent index is created at app/page.mdx (route groups skipped)
    // It contains a reference to the components index (which was recursively created)
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Full Docs](./(public)/components/page.mdx)');
    // Input should be listed as a section under Components
    expect(appContent).toContain('- Input');
  });

  it('should not lose child pages when multiple concurrent updates occur', async () => {
    // This test ensures that when multiple child directories update the same parent index
    // concurrently, all child pages are preserved in the final index.
    // This prevents a race condition where re-reading the file during parent updates
    // could cause some pages to be lost.

    await mkdir(join(TEST_DIR, 'app'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'overview'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'components'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'handbook'), { recursive: true });
    await mkdir(join(TEST_DIR, 'app', 'utils'), { recursive: true });

    const overviewMeta: PageMetadata = {
      slug: 'overview',
      path: './overview/page.mdx',
      title: 'Overview',
      description: 'Overview section.',
    };

    const componentsMeta: PageMetadata = {
      slug: 'components',
      path: './components/page.mdx',
      title: 'Components',
      description: 'Components section.',
    };

    const handbookMeta: PageMetadata = {
      slug: 'handbook',
      path: './handbook/page.mdx',
      title: 'Handbook',
      description: 'Handbook section.',
    };

    const utilsMeta: PageMetadata = {
      slug: 'utils',
      path: './utils/page.mdx',
      title: 'Utils',
      description: 'Utils section.',
    };

    // Simulate concurrent updates by running all updates in parallel
    await Promise.all([
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'overview', 'page.mdx'),
        metadata: overviewMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'components', 'page.mdx'),
        metadata: componentsMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'handbook', 'page.mdx'),
        metadata: handbookMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
      updatePageIndex({
        pagePath: join(TEST_DIR, 'app', 'utils', 'page.mdx'),
        metadata: utilsMeta,
        updateParents: true,
        baseDir: join(TEST_DIR, 'app'),
      }),
    ]);

    // Verify that ALL four child pages are present in the parent index
    const appIndexPath = join(TEST_DIR, 'app', 'page.mdx');
    const appContent = await readFile(appIndexPath, 'utf-8');

    // All four pages should be present
    expect(appContent).toContain('[Overview](#overview)');
    expect(appContent).toContain('[Components](#components)');
    expect(appContent).toContain('[Handbook](#handbook)');
    expect(appContent).toContain('[Utils](#utils)');

    // Verify all sections are present
    expect(appContent).toContain('## Overview');
    expect(appContent).toContain('## Components');
    expect(appContent).toContain('## Handbook');
    expect(appContent).toContain('## Utils');

    // Count the number of H2 headings to ensure we have exactly 4
    const h2Count = (appContent.match(/^## /gm) || []).length;
    expect(h2Count).toBe(4);
  });

  it('should handle metadata with parts array', async () => {
    const metadata: PageMetadata = {
      slug: 'alert-dialog',
      path: './alert-dialog/page.mdx',
      title: 'Alert Dialog',
      description: 'An alert dialog component.',
      parts: ['Root', 'Trigger', 'Popup', 'Portal', 'Backdrop'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'alert-dialog', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Alert Dialog](#alert-dialog) - [Full Docs](./alert-dialog/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Alert Dialog

      An alert dialog component.

      - Parts: Root, Trigger, Popup, Portal, Backdrop

      [Read more](./alert-dialog/page.mdx)
      "
    `);
  });

  it('should handle metadata with props, dataAttributes, and cssVariables', async () => {
    const metadata: PageMetadata = {
      slug: 'tooltip',
      path: './tooltip/page.mdx',
      title: 'Tooltip',
      description: 'A tooltip component.',
      parts: ['Root', 'Trigger', 'Popup'],
      props: ['align', 'className', 'defaultOpen', 'open', 'side'],
      dataAttributes: ['data-align', 'data-open', 'data-side'],
      cssVariables: ['--anchor-height', '--anchor-width', '--transform-origin'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'tooltip', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Tooltip](#tooltip) - [Full Docs](./tooltip/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Tooltip

      A tooltip component.

      - Parts: Root, Trigger, Popup
      - Props: align, className, defaultOpen, open, side
      - Data Attributes: data-align, data-open, data-side
      - CSS Variables: --anchor-height, --anchor-width, --transform-origin

      [Read more](./tooltip/page.mdx)
      "
    `);
  });

  it('should update existing metadata with new parts and props', async () => {
    const indexPath = join(TEST_DIR, 'components', 'page.mdx');
    const existingContent = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    await writeFile(indexPath, existingContent, 'utf-8');

    const metadata: PageMetadata = {
      slug: 'button',
      path: './button/page.mdx',
      title: 'Button',
      description: 'A button component.',
      parts: ['Root', 'Icon'],
      props: ['className', 'disabled', 'onClick'],
    };

    await updatePageIndex({
      pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
      metadata,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      - Parts: Root, Icon
      - Props: className, disabled, onClick

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle batch updates with parts and props', async () => {
    const metadataList: PageMetadata[] = [
      {
        slug: 'checkbox',
        path: './checkbox/page.mdx',
        title: 'Checkbox',
        description: 'A checkbox component.',
        parts: ['Root', 'Indicator'],
        props: ['checked', 'className', 'disabled'],
      },
      {
        slug: 'switch',
        path: './switch/page.mdx',
        title: 'Switch',
        description: 'A switch component.',
        parts: ['Root', 'Thumb'],
        props: ['checked', 'className', 'onCheckedChange'],
        dataAttributes: ['data-checked', 'data-disabled'],
      },
    ];

    const indexPath = join(TEST_DIR, 'components', 'page.mdx');

    await updatePageIndex({
      pagePath: indexPath,
      metadataList,
      indexTitle: 'Components',
    });

    const content = await readFile(indexPath, 'utf-8');

    expect(content).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)
      - [Switch](#switch) - [Full Docs](./switch/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Checkbox

      A checkbox component.

      - Parts: Root, Indicator
      - Props: checked, className, disabled

      [Read more](./checkbox/page.mdx)

      ## Switch

      A switch component.

      - Parts: Root, Thumb
      - Props: checked, className, onCheckedChange
      - Data Attributes: data-checked, data-disabled

      [Read more](./switch/page.mdx)
      "
    `);
  });

  describe('onlyUpdateIndexes option', () => {
    it('should skip creating new index when onlyUpdateIndexes is true', async () => {
      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        onlyUpdateIndexes: true,
      });

      // Index file should NOT be created
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');
      await expect(readFile(indexPath, 'utf-8')).rejects.toThrow('ENOENT');
    });

    it('should update existing index when onlyUpdateIndexes is true', async () => {
      // Create an existing index
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');
      await writeFile(
        indexPath,
        `[//]: # 'This file is autogenerated'\n\n# Components\n\n`,
        'utf-8',
      );

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        onlyUpdateIndexes: true,
      });

      // Index should be updated
      const content = await readFile(indexPath, 'utf-8');
      expect(content).toContain('## Button');
    });
  });

  describe('markerDir option', () => {
    it('should create marker file when index is updated', async () => {
      const markerDir = join(TEST_DIR, '.markers');
      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
        markerDir,
      });

      // Marker file should be created
      const markerPath = join(markerDir, 'components', 'page.mdx');
      const markerExists = await readFile(markerPath, 'utf-8').then(
        () => true,
        () => false,
      );
      expect(markerExists).toBe(true);
    });

    it('should not create marker file when markerDir is false', async () => {
      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        markerDir: false,
      });

      // No marker directory should exist
      const markerDir = join(TEST_DIR, '.markers');
      const markerExists = await readFile(markerDir, 'utf-8').then(
        () => true,
        () => false,
      );
      expect(markerExists).toBe(false);
    });

    it('should not create marker file when index is not modified', async () => {
      const markerDir = join(TEST_DIR, '.markers');

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      // First update to create the index
      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
      });

      // Clear any potential markers from first update
      await rm(markerDir, { recursive: true, force: true }).catch(() => {});

      // Second update with same data should not create a marker
      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
        markerDir,
      });

      // Marker should NOT be created since content didn't change
      const markerPath = join(markerDir, 'components', 'page.mdx');
      const markerExists = await readFile(markerPath, 'utf-8').then(
        () => true,
        () => false,
      );
      expect(markerExists).toBe(false);
    });

    it('should resolve markerDir relative to baseDir', async () => {
      const markerDir = '.markers';
      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
        markerDir,
      });

      // Marker file should be created relative to baseDir
      const markerPath = join(TEST_DIR, markerDir, 'components', 'page.mdx');
      const markerExists = await readFile(markerPath, 'utf-8').then(
        () => true,
        () => false,
      );
      expect(markerExists).toBe(true);
    });
  });

  describe('errorIfOutOfDate option', () => {
    it('should throw error when index is missing and errorIfOutOfDate is true', async () => {
      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await expect(
        updatePageIndex({
          pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
          metadata,
          indexTitle: 'Components',
          baseDir: TEST_DIR,
          errorIfOutOfDate: true,
        }),
      ).rejects.toThrow('Index file is missing');
    });

    it('should throw error when index is out of date and errorIfOutOfDate is true', async () => {
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');
      await writeFile(
        indexPath,
        `[//]: # 'This file is autogenerated'\n\n# Components\n\n`,
        'utf-8',
      );

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await expect(
        updatePageIndex({
          pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
          metadata,
          indexTitle: 'Components',
          baseDir: TEST_DIR,
          errorIfOutOfDate: true,
        }),
      ).rejects.toThrow('Index file is out of date');
    });

    it('should not throw when index is up to date and errorIfOutOfDate is true', async () => {
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      // First create the index
      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
      });

      // Read what was written
      const writtenContent = await readFile(indexPath, 'utf-8');

      // Parse back and use the same data for second call
      const parsed = await import('./metadataToMarkdown').then((m) =>
        m.markdownToMetadata(writtenContent),
      );
      const parsedMeta = parsed!.pages.find((p) => p.slug === 'button')!;

      // Second call with parsed data should not throw since it matches exactly
      await expect(
        updatePageIndex({
          pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
          metadata: parsedMeta,
          indexTitle: 'Components',
          baseDir: TEST_DIR,
          errorIfOutOfDate: true,
        }),
      ).resolves.toBeUndefined();
    });
  });

  describe('autogeneration marker check', () => {
    it('should skip updating files without autogeneration marker', async () => {
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');
      const manualContent = '# Components\n\nThis is a manually created file.\n';
      await writeFile(indexPath, manualContent, 'utf-8');

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
      });

      // Content should remain unchanged
      const content = await readFile(indexPath, 'utf-8');
      expect(content).toBe(manualContent);
    });

    it('should update files with autogeneration marker', async () => {
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');
      await writeFile(
        indexPath,
        `[//]: # 'This file is autogenerated'\n\n# Components\n\n`,
        'utf-8',
      );

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
      });

      // Content should be updated
      const content = await readFile(indexPath, 'utf-8');
      expect(content).toContain('## Button');
    });
  });

  describe('combined options', () => {
    it('should work with onlyUpdateIndexes and markerDir together', async () => {
      const markerDir = join(TEST_DIR, '.markers');
      const indexPath = join(TEST_DIR, 'components', 'page.mdx');

      // Create existing index
      await writeFile(
        indexPath,
        `[//]: # 'This file is autogenerated'\n\n# Components\n\n`,
        'utf-8',
      );

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Components',
        baseDir: TEST_DIR,
        onlyUpdateIndexes: true,
        markerDir,
      });

      // Index should be updated
      const content = await readFile(indexPath, 'utf-8');
      expect(content).toContain('## Button');

      // Marker should be created
      const markerPath = join(markerDir, 'components', 'page.mdx');
      const markerExists = await readFile(markerPath, 'utf-8').then(
        () => true,
        () => false,
      );
      expect(markerExists).toBe(true);
    });

    it('should propagate markerDir through recursive parent updates', async () => {
      const markerDir = join(TEST_DIR, '.markers');

      await mkdir(join(TEST_DIR, 'components', 'forms'), { recursive: true });
      await mkdir(join(TEST_DIR, 'components', 'forms', 'button'), { recursive: true });

      const metadata: PageMetadata = {
        slug: 'button',
        path: './button/page.mdx',
        title: 'Button',
        description: 'A button component.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'components', 'forms', 'button', 'page.mdx'),
        metadata,
        indexTitle: 'Button Docs',
        updateParents: true,
        baseDir: TEST_DIR,
        markerDir,
      });

      // Both indexes should have markers
      const buttonMarker = join(markerDir, 'components', 'forms', 'page.mdx');
      const formsMarker = join(markerDir, 'components', 'page.mdx');

      const buttonMarkerExists = await readFile(buttonMarker, 'utf-8').then(
        () => true,
        () => false,
      );
      const formsMarkerExists = await readFile(formsMarker, 'utf-8').then(
        () => true,
        () => false,
      );

      expect(buttonMarkerExists).toBe(true);
      expect(formsMarkerExists).toBe(true);
    });
  });

  describe('single-link entries (external links)', () => {
    it('should exclude single-link entries from parent index sections', async () => {
      await mkdir(join(TEST_DIR, 'handbook'), { recursive: true });
      await mkdir(join(TEST_DIR, 'handbook', 'forms'), { recursive: true });
      await mkdir(join(TEST_DIR, 'handbook', 'typescript'), { recursive: true });

      // Create handbook index with single-link entry
      const handbookIndex = `# Handbook

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Forms](#forms) - [Full Docs](./forms/page.mdx)
- [llms.txt](/llms.txt) [External]
- [TypeScript](#typescript) - [Full Docs](./typescript/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Forms

A guide to building forms.

[Read more](./forms/page.mdx)

## TypeScript

A guide to using TypeScript.

[Read more](./typescript/page.mdx)
`;
      await writeFile(join(TEST_DIR, 'handbook', 'page.mdx'), handbookIndex, 'utf-8');

      // Update forms page to trigger parent update
      const formsMetadata: PageMetadata = {
        slug: 'forms',
        path: './forms/page.mdx',
        title: 'Forms',
        description: 'A guide to building forms.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'handbook', 'forms', 'page.mdx'),
        metadata: formsMetadata,
        indexTitle: 'Forms',
        updateParents: true,
        baseDir: TEST_DIR,
      });

      // Read handbook index
      const handbookContent = await readFile(join(TEST_DIR, 'handbook', 'page.mdx'), 'utf-8');

      // llms.txt should still be in the editable list
      expect(handbookContent).toContain('- [llms.txt](/llms.txt) [External]');
      // llms.txt should NOT have a detail section
      expect(handbookContent).not.toContain('## llms.txt');

      // Now check parent index - llms.txt should NOT be in sections
      await mkdir(join(TEST_DIR, 'handbook-parent'), { recursive: true });

      // Move handbook to be a child directory for testing parent sections
      await rm(join(TEST_DIR, 'handbook'), { recursive: true });
      await mkdir(join(TEST_DIR, 'docs'), { recursive: true });
      await mkdir(join(TEST_DIR, 'docs', 'handbook'), { recursive: true });
      await mkdir(join(TEST_DIR, 'docs', 'handbook', 'forms'), { recursive: true });

      await writeFile(join(TEST_DIR, 'docs', 'handbook', 'page.mdx'), handbookIndex, 'utf-8');

      // Update forms page to trigger parent update
      await updatePageIndex({
        pagePath: join(TEST_DIR, 'docs', 'handbook', 'forms', 'page.mdx'),
        metadata: formsMetadata,
        indexTitle: 'Forms',
        updateParents: true,
        baseDir: TEST_DIR,
      });

      // Read parent index
      const parentContent = await readFile(join(TEST_DIR, 'docs', 'page.mdx'), 'utf-8');

      // Parent index should have Handbook section (derived from directory name)
      // The section title is "Forms" because it's looking at the index in handbook/
      expect(parentContent).toContain('## Forms');
      expect(parentContent).toContain('- Sections:');
      expect(parentContent).toContain('- Forms');
      expect(parentContent).toContain('- TypeScript');
      // llms.txt should NOT appear in parent index sections
      expect(parentContent).not.toContain('- llms.txt');
    });

    it('should preserve skipDetailSection flag when updating child pages', async () => {
      await mkdir(join(TEST_DIR, 'resources'), { recursive: true });
      await mkdir(join(TEST_DIR, 'resources', 'docs'), { recursive: true });

      // Create resources index with single-link entry
      const resourcesIndex = `# Resources

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [API](/api) [External] [New]
- [Documentation](#docs) - [Full Docs](./docs/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Documentation

Internal documentation.

[Read more](./docs/page.mdx)
`;
      await writeFile(join(TEST_DIR, 'resources', 'page.mdx'), resourcesIndex, 'utf-8');

      // Update docs page
      const docsMetadata: PageMetadata = {
        slug: 'docs',
        path: './docs/page.mdx',
        title: 'Documentation',
        description: 'Updated documentation.',
      };

      await updatePageIndex({
        pagePath: join(TEST_DIR, 'resources', 'docs', 'page.mdx'),
        metadata: docsMetadata,
        indexTitle: 'Documentation',
      });

      // Read resources index
      const resourcesContent = await readFile(join(TEST_DIR, 'resources', 'page.mdx'), 'utf-8');

      // API should preserve tags and NOT have detail section
      expect(resourcesContent).toContain('- [API](/api) [External] [New]');
      expect(resourcesContent).not.toContain('## API');
      // Documentation should have detail section
      expect(resourcesContent).toContain('## Documentation');
      expect(resourcesContent).toContain('Updated documentation.');
    });
  });
});
