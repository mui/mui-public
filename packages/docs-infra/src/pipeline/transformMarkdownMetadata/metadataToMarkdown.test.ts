import { describe, it, expect } from 'vitest';
import {
  metadataToMarkdown,
  metadataToMarkdownAst,
  markdownToMetadata,
} from './metadataToMarkdown';
import type { PagesMetadata } from './metadataToMarkdown';

describe('metadataToMarkdown', () => {
  it('should convert page metadata to markdown string', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          openGraph: {
            title: 'Button',
            description: 'A button component.',
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'A simple button',
              },
            ],
          },
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following order can be modified'

      - [Button](./button/page.mdx) - A button component.

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      ![A simple button](https://example.com/button.png)

      - Keywords: interactive, input

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle multiple pages', () => {
    const data: PagesMetadata = {
      title: 'UI Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [Button](./button/page.mdx) - A button component.');
    expect(result).toContain('- [Checkbox](./checkbox/page.mdx) - A checkbox component.');
    expect(result).toContain('## Button');
    expect(result).toContain('## Checkbox');
  });

  it('should use fallback description when not provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [button](./button/page.mdx) - No description available');
  });

  it('should handle pages without images', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('![');
    expect(result).toContain('## Button');
    expect(result).toContain('A button component.');
  });

  it('should handle pages without keywords', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('Keywords:');
  });

  it('should prefer openGraph data over regular metadata', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Regular Button',
          description: 'Regular description',
          openGraph: {
            title: 'OpenGraph Button',
            description: 'OpenGraph description',
          },
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [OpenGraph Button](./button/page.mdx) - OpenGraph description');
    expect(result).toContain('## OpenGraph Button');
    expect(result).not.toContain('Regular Button');
    expect(result).not.toContain('Regular description');
  });
});

describe('metadataToMarkdownAst', () => {
  it('should convert page metadata to markdown AST', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    expect(result.type).toBe('root');
    expect(result.children).toHaveLength(7); // H1, comment, list item, comment, H2, description, read more

    // Check H1
    expect(result.children[0]).toMatchObject({
      type: 'heading',
      depth: 1,
      children: [{ type: 'text', value: 'Components' }],
    });

    // Check list item paragraph
    const listItem = result.children[2] as any;
    expect(listItem.type).toBe('paragraph');
    expect(listItem.children[0].value).toBe('- ');
    expect(listItem.children[1].type).toBe('link');
    expect(listItem.children[1].url).toBe('./button/page.mdx');

    // Check H2
    const h2 = result.children[4] as any;
    expect(h2.type).toBe('heading');
    expect(h2.depth).toBe(2);
  });

  it('should include images in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          openGraph: {
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'Button image',
              },
            ],
          },
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the image node
    const imageNode = result.children.find(
      (child: any) =>
        child.type === 'paragraph' &&
        child.children &&
        child.children.some((c: any) => c.type === 'image'),
    ) as any;

    expect(imageNode).toBeDefined();
    expect(imageNode.children[0].type).toBe('image');
    expect(imageNode.children[0].url).toBe('https://example.com/button.png');
    expect(imageNode.children[0].alt).toBe('Button image');
  });

  it('should include keywords in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input', 'form'],
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the metadata list containing keywords
    const metadataList = result.children.find((child: any) => child.type === 'list') as any;

    expect(metadataList).toBeDefined();

    // Find the keywords list item
    const keywordItem = metadataList.children.find(
      (item: any) =>
        item.type === 'listItem' && item.children[0]?.children[0]?.value?.includes('Keywords:'),
    ) as any;

    expect(keywordItem).toBeDefined();
    expect(keywordItem.children[0].children[0].value).toContain('interactive, input, form');
  });
});

describe('markdownToMetadata', () => {
  it('should parse markdown string back to metadata', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - A button component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

![A simple button](https://example.com/button.png)

- Keywords: interactive, input

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.title).toBe('Components');
    expect(result?.pages).toHaveLength(1);

    const page = result?.pages[0];
    expect(page?.slug).toBe('button');
    expect(page?.path).toBe('./button/page.mdx');
    expect(page?.title).toBe('Button');
    expect(page?.description).toBe('A button component.');
    expect(page?.keywords).toEqual(['interactive', 'input']);
    expect(page?.openGraph?.images?.[0].url).toBe('https://example.com/button.png');
    expect(page?.openGraph?.images?.[0].alt).toBe('A simple button');
  });

  it('should parse multiple pages', async () => {
    const markdown = `# UI Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - A button component.
- [Checkbox](./checkbox/page.mdx) - A checkbox component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);
    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('checkbox');
  });

  it('should handle pages without images', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - A button component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].openGraph?.images).toBeUndefined();
  });

  it('should handle pages without keywords', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - A button component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].keywords).toBeUndefined();
  });

  it('should return null when no title is found', async () => {
    const markdown = `
- [Button](./button/page.mdx) - A button component.
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeNull();
  });

  it('should extract slug from path correctly', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - A button component.
- [Nested Component](./nested/component/page.mdx) - A nested component.
- [Simple](./simple.mdx) - Simple component.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Nested Component

A nested component.

[Read more](./nested/component/page.mdx)

## Simple

Simple component.

[Read more](./simple.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('component');
    expect(result?.pages[2].slug).toBe('simple');
  });

  it('should merge data from editable and detail sections', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Button](./button/page.mdx) - Short description.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A more detailed button component description.

![Button image](https://example.com/button.png)

- Keywords: interactive, clickable

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    const page = result?.pages[0];
    // Detail section should override editable section
    expect(page?.description).toBe('A more detailed button component description.');
    expect(page?.keywords).toEqual(['interactive', 'clickable']);
    expect(page?.openGraph?.images?.[0].url).toBe('https://example.com/button.png');
  });

  it('should correctly parse actual generated markdown format', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following order can be modified'

- [myFunction](./my-function/page.mdx) - No description available
- [anotherFunction](./another-function/page.mdx) - No description available

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function that provides essential functionality for the application.

[Read more](./my-function/page.mdx)

## anotherFunction

The anotherFunction utility handles data processing with advanced features.

[Read more](./another-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);

    const firstPage = result?.pages[0];
    expect(firstPage?.slug).toBe('my-function');
    expect(firstPage?.title).toBe('myFunction');
    expect(firstPage?.description).toBe(
      'The myFunction utility is a helper function that provides essential functionality for the application.',
    );

    const secondPage = result?.pages[1];
    expect(secondPage?.slug).toBe('another-function');
    expect(secondPage?.title).toBe('anotherFunction');
    expect(secondPage?.description).toBe(
      'The anotherFunction utility handles data processing with advanced features.',
    );
  });

  it('should handle titles with inline code formatting', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following order can be modified'

- [myFunction](./my-function/page.mdx) - No description available

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function.

[Read more](./my-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('my-function');
    expect(page?.title).toBe('myFunction');
    expect(page?.description).toBe('The myFunction utility is a helper function.');
  });

  it('should replace newlines with spaces in descriptions', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Example Component](./example-component/page.mdx) - No description available

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Example Component

The Example Component provides a powerful and
flexible way to display content with multiple features and options.
It supports both basic usage and advanced scenarios with custom configurations.

[Read more](./example-component/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('example-component');
    expect(page?.title).toBe('Example Component');
    // Newlines should be replaced with spaces
    expect(page?.description).toBe(
      'The Example Component provides a powerful and flexible way to display content with multiple features and options. It supports both basic usage and advanced scenarios with custom configurations.',
    );
  });

  it('should preserve inline code in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [Code Highlighter](./code-highlighter/page.mdx) - The \`CodeHighlighter\` component provides syntax highlighting.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Code Highlighter

The \`CodeHighlighter\` component provides syntax highlighting.

[Read more](./code-highlighter/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve inline code
    expect(page?.description).toBe('The `CodeHighlighter` component provides syntax highlighting.');

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toEqual([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'CodeHighlighter' },
      { type: 'text', value: ' component provides syntax highlighting.' },
    ]);
  });

  it('should preserve links in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following order can be modified'

- [useErrors](./use-errors/page.mdx) - The \`useErrors\` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## useErrors

The \`useErrors\` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.

[Read more](./use-errors/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve links and inline code
    expect(page?.description).toBe(
      'The `useErrors` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.',
    );

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toMatchObject([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'useErrors' },
      { type: 'text', value: ' hook implements the ' },
      {
        type: 'link',
        url: '../../patterns/props-context-layering/page.mdx',
        children: [{ type: 'text', value: 'Props Context Layering pattern' }],
      },
      { type: 'text', value: ' for error handling.' },
    ]);
  });

  it('should preserve formatting through round-trip with inline code', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'code-highlighter',
          path: './code-highlighter/page.mdx',
          title: 'Code Highlighter',
          description: 'The `CodeHighlighter` component provides syntax highlighting.',
          descriptionMarkdown: [
            { type: 'text', value: 'The ' },
            { type: 'inlineCode', value: 'CodeHighlighter' },
            { type: 'text', value: ' component provides syntax highlighting.' },
          ],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);

    // The markdown should contain backticks
    expect(markdown).toContain('The `CodeHighlighter` component provides syntax highlighting.');

    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].descriptionMarkdown).toEqual(original.pages[0].descriptionMarkdown);
  });
});

describe('round-trip conversion', () => {
  it('should maintain data integrity through conversion cycle', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          openGraph: {
            title: 'Button',
            description: 'A button component.',
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'Button image',
              },
            ],
          },
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
          keywords: ['form', 'input'],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toHaveLength(original.pages.length);

    // Check first component
    expect(parsed?.pages[0].slug).toBe(original.pages[0].slug);
    expect(parsed?.pages[0].path).toBe(original.pages[0].path);
    expect(parsed?.pages[0].title).toBe(original.pages[0].title);
    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].keywords).toEqual(original.pages[0].keywords);
    expect(parsed?.pages[0].openGraph?.images?.[0].url).toBe(
      original.pages[0].openGraph?.images?.[0].url,
    );

    // Check second component
    expect(parsed?.pages[1].slug).toBe(original.pages[1].slug);
    expect(parsed?.pages[1].keywords).toEqual(original.pages[1].keywords);
  });

  it('should handle empty pages array', async () => {
    const original: PagesMetadata = {
      title: 'Empty Components',
      pages: [],
    };

    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toEqual([]);
  });

  it('should preserve sections through round-trip conversion', async () => {
    const original: PagesMetadata = {
      title: 'Functions',
      pages: [
        {
          slug: 'my-function',
          path: './my-function/page.mdx',
          title: 'My Function',
          description: 'An example function.',
          sections: {
            overview: {
              title: 'Overview',
              titleMarkdown: [{ type: 'text', value: 'Overview' }],
              children: {},
            },
            api: {
              title: 'API',
              titleMarkdown: [{ type: 'text', value: 'API' }],
              children: {
                parameters: {
                  title: 'Parameters',
                  titleMarkdown: [{ type: 'text', value: 'Parameters' }],
                  children: {},
                },
                'return-value': {
                  title: 'Return Value',
                  titleMarkdown: [{ type: 'text', value: 'Return Value' }],
                  children: {},
                },
              },
            },
            examples: {
              title: 'Examples',
              titleMarkdown: [{ type: 'text', value: 'Examples' }],
              children: {
                'basic-usage': {
                  title: 'Basic Usage',
                  titleMarkdown: [{ type: 'text', value: 'Basic Usage' }],
                  children: {},
                },
              },
            },
          },
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.pages).toHaveLength(1);
    expect(parsed?.pages[0].sections).toBeDefined();
    expect(parsed?.pages[0].sections).toEqual(original.pages[0].sections);
  });
});
