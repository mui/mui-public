import { describe, it, expect } from 'vitest';
import {
  metadataToMarkdown,
  metadataToMarkdownAst,
  markdownToMetadata,
} from './metadataToMarkdown';
import type { PagesMetadata } from './metadataToMarkdown';

describe('metadataToMarkdown', () => {
  it('should convert page metadata to markdown string', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          embeddings: [0.1, 0.2, 0.3],
          openGraph: {
            title: 'Button',
            description: 'A button component.',
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'A simple button',
              },
            ],
          },
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toMatchInlineSnapshot(`
      "# Components

      [//]: # 'This file is autogenerated, but the following list can be modified.'

      - [Button](#button) - [Full Docs](./button/page.mdx)

      [//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

      ## Button

      A button component.

      ![A simple button](https://example.com/button.png)

      - Keywords: interactive, input

      [//]: # 'Embeddings: [0.1,0.2,0.3]'

      [Read more](./button/page.mdx)
      "
    `);
  });

  it('should handle multiple pages', () => {
    const data: PagesMetadata = {
      title: 'UI Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [Button](#button) - [Full Docs](./button/page.mdx)');
    expect(result).toContain('- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)');
    expect(result).toContain('## Button');
    expect(result).toContain('## Checkbox');
  });

  it('should use fallback description when not provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [button](#button) - [Full Docs](./button/page.mdx)');
  });

  it('should handle pages without images', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('![');
    expect(result).toContain('## Button');
    expect(result).toContain('A button component.');
  });

  it('should handle pages without keywords', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).not.toContain('Keywords:');
  });

  it('should prefer openGraph data over regular metadata', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Regular Button',
          description: 'Regular description',
          openGraph: {
            title: 'OpenGraph Button',
            description: 'OpenGraph description',
          },
        },
      ],
    };

    const result = metadataToMarkdown(data);

    expect(result).toContain('- [OpenGraph Button](#button) - [Full Docs](./button/page.mdx)');
    expect(result).toContain('## OpenGraph Button');
    expect(result).not.toContain('Regular Button');
    expect(result).not.toContain('Regular description');
  });
});

describe('metadataToMarkdownAst', () => {
  it('should convert page metadata to markdown AST', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    expect(result.type).toBe('root');
    expect(result.children).toHaveLength(7); // H1, comment, list, comment, H2, description, read more

    // Check H1
    expect(result.children[0]).toMatchObject({
      type: 'heading',
      depth: 1,
      children: [{ type: 'text', value: 'Components' }],
    });

    // Check list - new format: - [Title](#slug) - [Full Docs](./path)
    const list = result.children[2] as any;
    expect(list.type).toBe('list');
    expect(list.ordered).toBe(false);
    expect(list.children).toHaveLength(1); // One list item

    const listItem = list.children[0];
    expect(listItem.type).toBe('listItem');
    expect(listItem.children).toHaveLength(1); // One paragraph in the list item

    const paragraph = listItem.children[0];
    expect(paragraph.type).toBe('paragraph');
    expect(paragraph.children[0].type).toBe('link');
    expect(paragraph.children[0].url).toBe('#button'); // Link to section
    expect(paragraph.children[0].children[0].value).toBe('Button'); // Link text
    expect(paragraph.children[1].value).toBe(' - '); // Separator
    expect(paragraph.children[2].type).toBe('link');
    expect(paragraph.children[2].url).toBe('./button/page.mdx'); // Link to full docs
    expect(paragraph.children[2].children[0].value).toBe('Full Docs'); // Link text

    // Check H2
    const h2 = result.children[4] as any;
    expect(h2.type).toBe('heading');
    expect(h2.depth).toBe(2);
  });

  it('should include images in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          openGraph: {
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'Button image',
              },
            ],
          },
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the image node
    const imageNode = result.children.find(
      (child: any) =>
        child.type === 'paragraph' &&
        child.children &&
        child.children.some((c: any) => c.type === 'image'),
    ) as any;

    expect(imageNode).toBeDefined();
    expect(imageNode.children[0].type).toBe('image');
    expect(imageNode.children[0].url).toBe('https://example.com/button.png');
    expect(imageNode.children[0].alt).toBe('Button image');
  });

  it('should include keywords in AST when provided', () => {
    const data: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input', 'form'],
        },
      ],
    };

    const result = metadataToMarkdownAst(data);

    // Find the metadata list containing keywords (this is the second list in the document)
    const allLists = result.children.filter((child: any) => child.type === 'list') as any[];
    const metadataList = allLists[1]; // The first list is the editable page list, the second is the detail metadata

    expect(metadataList).toBeDefined();

    // Find the keywords list item
    const keywordItem = metadataList.children.find(
      (item: any) =>
        item.type === 'listItem' && item.children[0]?.children[0]?.value?.includes('Keywords:'),
    ) as any;

    expect(keywordItem).toBeDefined();
    expect(keywordItem.children[0].children[0].value).toContain('interactive, input, form');
  });
});

describe('markdownToMetadata', () => {
  it('should parse markdown string back to metadata', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

![A simple button](https://example.com/button.png)

- Keywords: interactive, input

[//]: # 'Embeddings: [0.1,0.2,0.3]'

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeDefined();
    expect(result?.title).toBe('Components');
    expect(result?.pages).toHaveLength(1);

    const page = result?.pages[0];
    expect(page?.slug).toBe('button');
    expect(page?.path).toBe('./button/page.mdx');
    expect(page?.title).toBe('Button');
    expect(page?.description).toBe('A button component.');
    expect(page?.keywords).toEqual(['interactive', 'input']);
    expect(page?.embeddings).toEqual([0.1, 0.2, 0.3]);
    expect(page?.openGraph?.images?.[0].url).toBe('https://example.com/button.png');
    expect(page?.openGraph?.images?.[0].alt).toBe('A simple button');
  });

  it('should parse multiple pages', async () => {
    const markdown = `# UI Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)
- [Checkbox](#checkbox) - [Full Docs](./checkbox/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Checkbox

A checkbox component.

[Read more](./checkbox/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);
    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('checkbox');
  });

  it('should handle pages without images', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].openGraph?.images).toBeUndefined();
  });

  it('should handle pages without keywords', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].keywords).toBeUndefined();
  });

  it('should return null when no title is found', async () => {
    const markdown = `
- [Button](#button) - [Full Docs](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result).toBeNull();
  });

  it('should extract slug from path correctly', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)
- [Nested Component](#nested-component) - [Full Docs](./nested/component/page.mdx)
- [Simple](#simple) - [Full Docs](./simple.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A button component.

[Read more](./button/page.mdx)

## Nested Component

A nested component.

[Read more](./nested/component/page.mdx)

## Simple

Simple component.

[Read more](./simple.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages[0].slug).toBe('button');
    expect(result?.pages[1].slug).toBe('nested-component');
    expect(result?.pages[2].slug).toBe('simple');
  });

  it('should generate slugs that preserve camelCase as lowercase', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#myfunction) - [Full Docs](./my-function/page.mdx)
- [My Component](#my-component) - [Full Docs](./my-component/page.mdx)
- [Product\u00a0Name](#productname) - [Full Docs](./product-name/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

A simple function utility.

[Read more](./my-function/page.mdx)

## My Component

A multi-word component.

[Read more](./my-component/page.mdx)

## Product\u00a0Name

A title with non-breaking space.

[Read more](./product-name/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    // camelCase titles should become all lowercase (no hyphens inserted)
    expect(result?.pages[0].slug).toBe('myfunction');
    expect(result?.pages[0].title).toBe('myFunction');

    // Multi-word titles with regular spaces should use hyphens
    expect(result?.pages[1].slug).toBe('my-component');
    expect(result?.pages[1].title).toBe('My Component');

    // Titles with non-breaking spaces should have them removed (not converted to hyphens)
    expect(result?.pages[2].slug).toBe('productname');
    expect(result?.pages[2].title).toBe('Product\u00a0Name');
  });
  it('should merge data from editable and detail sections', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Button](#button) - [Full Docs](./button/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Button

A more detailed button component description.

![Button image](https://example.com/button.png)

- Keywords: interactive, clickable

[Read more](./button/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    const page = result?.pages[0];
    // Detail section should override editable section
    expect(page?.description).toBe('A more detailed button component description.');
    expect(page?.keywords).toEqual(['interactive', 'clickable']);
    expect(page?.openGraph?.images?.[0].url).toBe('https://example.com/button.png');
  });

  it('should correctly parse actual generated markdown format', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#my-function) - [Full Docs](./my-function/page.mdx)
- [anotherFunction](#another-function) - [Full Docs](./another-function/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function that provides essential functionality for the application.

[Read more](./my-function/page.mdx)

## anotherFunction

The anotherFunction utility handles data processing with advanced features.

[Read more](./another-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(2);

    const firstPage = result?.pages[0];
    expect(firstPage?.slug).toBe('my-function');
    expect(firstPage?.title).toBe('myFunction');
    expect(firstPage?.description).toBe(
      'The myFunction utility is a helper function that provides essential functionality for the application.',
    );

    const secondPage = result?.pages[1];
    expect(secondPage?.slug).toBe('another-function');
    expect(secondPage?.title).toBe('anotherFunction');
    expect(secondPage?.description).toBe(
      'The anotherFunction utility handles data processing with advanced features.',
    );
  });

  it('should handle titles with inline code formatting', async () => {
    const markdown = `# Functions

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [myFunction](#my-function) - [Full Docs](./my-function/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## myFunction

The myFunction utility is a helper function.

[Read more](./my-function/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('my-function');
    expect(page?.title).toBe('myFunction');
    expect(page?.description).toBe('The myFunction utility is a helper function.');
  });

  it('should replace newlines with spaces in descriptions', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Example Component](#example-component) - [Full Docs](./example-component/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Example Component

The Example Component provides a powerful and
flexible way to display content with multiple features and options.
It supports both basic usage and advanced scenarios with custom configurations.

[Read more](./example-component/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.slug).toBe('example-component');
    expect(page?.title).toBe('Example Component');
    // Newlines should be replaced with spaces
    expect(page?.description).toBe(
      'The Example Component provides a powerful and flexible way to display content with multiple features and options. It supports both basic usage and advanced scenarios with custom configurations.',
    );
  });

  it('should preserve inline code in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Code Highlighter](#code-highlighter) - [Full Docs](./code-highlighter/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Code Highlighter

The \`CodeHighlighter\` component provides syntax highlighting.

[Read more](./code-highlighter/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve inline code
    expect(page?.description).toBe('The `CodeHighlighter` component provides syntax highlighting.');

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toEqual([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'CodeHighlighter' },
      { type: 'text', value: ' component provides syntax highlighting.' },
    ]);
  });

  it('should preserve links in descriptions when parsing', async () => {
    const markdown = `# Components

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [useErrors](#use-errors) - [Full Docs](./use-errors/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## useErrors

The \`useErrors\` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.

[Read more](./use-errors/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];

    // The description should preserve links and inline code
    expect(page?.description).toBe(
      'The `useErrors` hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) for error handling.',
    );

    // The descriptionMarkdown should have the AST structure
    expect(page?.descriptionMarkdown).toBeDefined();
    expect(page?.descriptionMarkdown).toMatchObject([
      { type: 'text', value: 'The ' },
      { type: 'inlineCode', value: 'useErrors' },
      { type: 'text', value: ' hook implements the ' },
      {
        type: 'link',
        url: '../../patterns/props-context-layering/page.mdx',
        children: [{ type: 'text', value: 'Props Context Layering pattern' }],
      },
      { type: 'text', value: ' for error handling.' },
    ]);
  });

  it('should preserve formatting through round-trip with inline code', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'code-highlighter',
          path: './code-highlighter/page.mdx',
          title: 'Code Highlighter',
          description: 'The `CodeHighlighter` component provides syntax highlighting.',
          descriptionMarkdown: [
            { type: 'text', value: 'The ' },
            { type: 'inlineCode', value: 'CodeHighlighter' },
            { type: 'text', value: ' component provides syntax highlighting.' },
          ],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);

    // The markdown should contain backticks
    expect(markdown).toContain('The `CodeHighlighter` component provides syntax highlighting.');

    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].descriptionMarkdown).toEqual(original.pages[0].descriptionMarkdown);
  });
});

describe('round-trip conversion', () => {
  it('should maintain data integrity through conversion cycle', async () => {
    const original: PagesMetadata = {
      title: 'Components',
      pages: [
        {
          slug: 'button',
          path: './button/page.mdx',
          title: 'Button',
          description: 'A button component.',
          keywords: ['interactive', 'input'],
          embeddings: [0.1, 0.2, 0.3, 0.4, 0.5],
          openGraph: {
            title: 'Button',
            description: 'A button component.',
            images: [
              {
                url: 'https://example.com/button.png',
                width: 800,
                height: 600,
                alt: 'Button image',
              },
            ],
          },
        },
        {
          slug: 'checkbox',
          path: './checkbox/page.mdx',
          title: 'Checkbox',
          description: 'A checkbox component.',
          keywords: ['form', 'input'],
          embeddings: [0.6, 0.7, 0.8],
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toHaveLength(original.pages.length);

    // Check first component
    expect(parsed?.pages[0].slug).toBe(original.pages[0].slug);
    expect(parsed?.pages[0].path).toBe(original.pages[0].path);
    expect(parsed?.pages[0].title).toBe(original.pages[0].title);
    expect(parsed?.pages[0].description).toBe(original.pages[0].description);
    expect(parsed?.pages[0].keywords).toEqual(original.pages[0].keywords);
    expect(parsed?.pages[0].embeddings).toEqual(original.pages[0].embeddings);
    expect(parsed?.pages[0].openGraph?.images?.[0].url).toBe(
      original.pages[0].openGraph?.images?.[0].url,
    );

    // Check second component
    expect(parsed?.pages[1].slug).toBe(original.pages[1].slug);
    expect(parsed?.pages[1].keywords).toEqual(original.pages[1].keywords);
    expect(parsed?.pages[1].embeddings).toEqual(original.pages[1].embeddings);
  });

  it('should handle empty pages array', async () => {
    const original: PagesMetadata = {
      title: 'Empty Components',
      pages: [],
    };

    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed?.title).toBe(original.title);
    expect(parsed?.pages).toEqual([]);
  });

  it('should preserve sections through round-trip conversion', async () => {
    const original: PagesMetadata = {
      title: 'Functions',
      pages: [
        {
          slug: 'my-function',
          path: './my-function/page.mdx',
          title: 'My Function',
          description: 'An example function.',
          sections: {
            overview: {
              title: 'Overview',
              titleMarkdown: [{ type: 'text', value: 'Overview' }],
              children: {},
            },
            api: {
              title: 'API',
              titleMarkdown: [{ type: 'text', value: 'API' }],
              children: {
                parameters: {
                  title: 'Parameters',
                  titleMarkdown: [{ type: 'text', value: 'Parameters' }],
                  children: {},
                },
                'return-value': {
                  title: 'Return Value',
                  titleMarkdown: [{ type: 'text', value: 'Return Value' }],
                  children: {},
                },
              },
            },
            examples: {
              title: 'Examples',
              titleMarkdown: [{ type: 'text', value: 'Examples' }],
              children: {
                'basic-usage': {
                  title: 'Basic Usage',
                  titleMarkdown: [{ type: 'text', value: 'Basic Usage' }],
                  children: {},
                },
              },
            },
          },
        },
      ],
    };

    // Convert to markdown and back
    const markdown = metadataToMarkdown(original);
    const parsed = await markdownToMetadata(markdown);

    expect(parsed).toBeDefined();
    expect(parsed?.pages).toHaveLength(1);
    expect(parsed?.pages[0].sections).toBeDefined();
    expect(parsed?.pages[0].sections).toEqual(original.pages[0].sections);
  });

  it('should handle sections with numbered titles correctly', async () => {
    const markdown = `# Patterns

[//]: # 'This file is autogenerated, but the following list can be modified.'

- [Props Context Layering](#props-context-layering) - [Full Docs](./props-context-layering/page.mdx)

[//]: # 'This file is autogenerated, DO NOT EDIT AFTER THIS LINE'

## Props Context Layering

A pattern for isomorphic components.

- Sections:
  - Server-Client Boundary Constraints
  - 1\\. Early rendering with fallback values
  - 2\\. Conditional async operations
  - 3\\. Props-first, context-enhanced hooks
  - 4\\. Lazy-load heavy functions
  - Implementation Checklist
  - Real-World Usage

[Read more](./props-context-layering/page.mdx)
`;

    const result = await markdownToMetadata(markdown);

    expect(result?.pages).toHaveLength(1);
    const page = result?.pages[0];
    expect(page?.sections).toBeDefined();

    // Should have all 7 sections
    expect(Object.keys(page?.sections || {})).toEqual([
      'server-client-boundary-constraints',
      '1-early-rendering-with-fallback-values',
      '2-conditional-async-operations',
      '3-props-first-context-enhanced-hooks',
      '4-lazy-load-heavy-functions',
      'implementation-checklist',
      'real-world-usage',
    ]);

    // Check that numbered sections are properly parsed
    expect(page?.sections?.['1-early-rendering-with-fallback-values']).toEqual({
      title: '1. Early rendering with fallback values',
      titleMarkdown: [{ type: 'text', value: '1. Early rendering with fallback values' }],
      children: {},
    });

    expect(page?.sections?.['2-conditional-async-operations']).toEqual({
      title: '2. Conditional async operations',
      titleMarkdown: [{ type: 'text', value: '2. Conditional async operations' }],
      children: {},
    });
  });
});
