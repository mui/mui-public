# transformMarkdownCodeVariants

A remark plugin that transforms code blocks with variants into HTML pre/code structures that can be processed by the existing rehype plugin.

## Features

- **Flexible variant syntax**: Supports both `variant=name` and `variant-group=name` formats
- **Language class support**: Automatically adds `class="language-{lang}"` attributes for syntax highlighting
- **Additional properties**: Passes extra metadata as `data-*` attributes to HTML elements
- **HTML escaping**: Properly escapes code content for security
- **Flexible spacing**: Works with or without blank lines between code blocks
- **Universal language support**: Works with any programming language, not just bash/terminal
- **Group detection**: Automatically groups adjacent code blocks with variant metadata
- **Label support**: For variant-group format, supports paragraph labels between code blocks

## Usage

### Basic Usage with MDX

This plugin is designed specifically for MDX and generates proper JSX elements:

```typescript
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import { transformMarkdownCodeVariants } from '@mui/internal-docs-infra/transformMarkdownCodeVariants';

const processor = unified()
  .use(remarkParse)
  .use(transformMarkdownCodeVariants);
```

### Usage with MDX Compiler

```typescript
import { compile } from '@mdx-js/mdx';
import { transformMarkdownCodeVariants } from '@mui/internal-docs-infra/transformMarkdownCodeVariants';

const result = await compile(mdxSource, {
  remarkPlugins: [transformMarkdownCodeVariants],
});
```

### Usage with Next.js MDX

```javascript
// next.config.js
const withMDX = require('@next/mdx')({
  options: {
    remarkPlugins: [transformMarkdownCodeVariants],
  },
});

module.exports = withMDX({
  // your Next.js config
});
```

## Examples

### Adjacent code blocks with variant attribute

Transform consecutive code blocks with variant metadata into grouped HTML structures.

**Input:**

```markdown
```bash variant=npm
npm install @mui/internal-docs-infra
```

```bash variant=pnpm
pnpm install @mui/internal-docs-infra
```

```bash variant=yarn
yarn add @mui/internal-docs-infra
```
```

**Output:**
```html
<pre>
  <code class="language-bash" data-variant="npm">npm install @mui/internal-docs-infra</code>
  <code class="language-bash" data-variant="pnpm">pnpm install @mui/internal-docs-infra</code>
  <code class="language-bash" data-variant="yarn">yarn add @mui/internal-docs-infra</code>
</pre>
```

### Code blocks with variant-group and labels

For variant-group format, the plugin extracts labels from paragraphs between code blocks.

**Input:**

```markdown
npm

```bash variant-group=install
npm install @mui/internal-docs-infra
```

pnpm

```bash variant-group=install
pnpm install @mui/internal-docs-infra
```

yarn

```bash variant-group=install
yarn add @mui/internal-docs-infra
```
```

**Output:**
```html
<pre>
  <code class="language-bash" data-variant="npm">npm install @mui/internal-docs-infra</code>
  <code class="language-bash" data-variant="pnpm">pnpm install @mui/internal-docs-infra</code>
  <code class="language-bash" data-variant="yarn">yarn add @mui/internal-docs-infra</code>
</pre>
```

### Additional properties as data attributes

Any additional properties in the code block metadata are passed through as data attributes.

**Input:**

```markdown
```bash variant=npm filename=package.json
npm install @mui/internal-docs-infra
```

```bash variant=pnpm filename=package.json
pnpm install @mui/internal-docs-infra
```
```

**Output:**
```html
<pre>
  <code class="language-bash" data-variant="npm" data-filename="package.json">npm install @mui/internal-docs-infra</code>
  <code class="language-bash" data-variant="pnpm" data-filename="package.json">pnpm install @mui/internal-docs-infra</code>
</pre>
```

### Code blocks without explicit language

The plugin also handles code blocks where the variant metadata appears without an explicit language.

**Input:**

```markdown
``` variant=option1
Some plain text content
```

``` variant=option2
More plain text content
```
```

**Output:**
```html
<pre>
  <code data-variant="option1">Some plain text content</code>
  <code data-variant="option2">More plain text content</code>
</pre>
```

## Behavior

### Adjacent Grouping

Code blocks are grouped if they are consecutive in the document. Blank lines between code blocks are allowed and don't prevent grouping.

```markdown
```js variant=es6
const greeting = 'Hello';
```

```js variant=commonjs
const greeting = require('./greeting');
```
```

### Variant-Group Exception

For `variant-group`, a single paragraph with text between code blocks is allowed and used as the variant name. The paragraph text becomes the variant label.

### Minimum Group Size

At least 2 code blocks are required to form a group. Single code blocks with variant metadata are left unchanged.

### Data Attributes

All properties after the language (except `variant` and `variant-group`) are added as `data-*` attributes to the generated HTML.

### HTML Escaping

Code content is properly escaped for HTML output to prevent XSS attacks and ensure proper rendering.

## Integration

This plugin is designed to work with the existing [`transformHtmlCode`](/functions/transformHtmlCode) rehype plugin. The HTML output from this plugin will be processed by that plugin to provide:

- Syntax highlighting
- Code transformation (TypeScript to JavaScript)
- Interactive code features
- Variant switching functionality

## Implementation Details

### AST Transformation

The plugin uses `unist-util-visit` to traverse the markdown AST and identify code blocks with variant metadata. It then:

1. **Parses metadata**: Extracts variant information and additional properties from code block metadata
2. **Groups adjacent blocks**: Collects consecutive code blocks that belong together
3. **Generates MDX JSX**: Creates proper `mdxJsxFlowElement` nodes with `pre` and `code` elements
4. **Sets attributes**: Adds `data-variant`, `className`, and custom data attributes
5. **Replaces nodes**: Substitutes the original code blocks with the generated MDX JSX elements

### Language Detection

The plugin handles language information in two ways:

- **With explicit language**: `````javascript variant=npm` - language is `javascript`, meta is `variant=npm`
- **Without explicit language**: `````variant=npm` - meta information is in the language field

### Metadata Parsing

The `parseMeta` function splits metadata strings by spaces and parses key=value pairs:

- `variant=name` - Sets the variant for grouping
- `variant-group=name` - Sets the variant group for label-based grouping  
- `filename=package.json` - Becomes `data-filename="package.json"`
- Any other properties become data attributes

## Error Handling

The plugin is designed to be robust and graceful:

- Invalid metadata is ignored
- Single code blocks with variants are left unchanged
- Non-adjacent code blocks are not grouped
- Generates proper MDX JSX elements that integrate seamlessly

## Performance Considerations

- Uses `Set` data structures for efficient duplicate tracking
- Processes nodes in a single AST traversal
- Minimal memory overhead for metadata parsing
- Parallel-friendly (no global state dependencies)
