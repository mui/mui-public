# useDemo Hook

The `useDemo` hook extends `useCode` functionality to provide a complete demo rendering solution that combines component previews with code display. It's specifically designed for creating interactive demonstrations where users can see both working React components and their source code.

## Overview

Built on top of the `useCode` hook, `useDemo` adds demo-specific functionality like name and slug management while inheriting all code management capabilities. This makes it the go-to choice for creating rich interactive demos within the `CodeHighlighter` ecosystem.

## Key Features

- **Complete code management** via `useCode` integration
- **Component rendering** alongside code display
- **Demo identification** with automatic slug generation
- **Variant switching** for different implementation approaches
- **Transform support** for language conversions (TypeScript to JavaScript)
- **File navigation** for multi-file demos

## Basic Usage

```tsx
import { useDemo } from '@mui/internal-docs-infra';

export function DemoContent(props) {
  const demo = useDemo(props);

  return (
    <div className={styles.container} ref={demo.ref}>
      {/* Component Preview Section */}
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      {/* Code Section */}
      <div className={styles.codeSection}>
        <div className={styles.code}>
          <pre className={styles.codeBlock}>
            {demo.selectedFile}
          </pre>
        </div>
      </div>
    </div>
  );
}
```

## Advanced Usage

### Full Interactive Demo Interface

```tsx
export function DemoContent(props) {
  const demo = useDemo(props);

  const hasJsTransform = demo.availableTransforms.includes('js');
  const isJsSelected = demo.selectedTransform === 'js';

  const labels = { false: 'TS', true: 'JS' };
  const toggleJs = React.useCallback(
    (checked: boolean) => {
      demo.selectTransform(checked ? 'js' : null);
    },
    [demo],
  );

  const tabs = React.useMemo(
    () => demo.files.map(({ name }) => ({ id: name, name })),
    [demo.files],
  );

  const variants = React.useMemo(
    () => demo.variants.map((variant) => ({ 
      value: variant, 
      label: variantNames[variant] || variant 
    })),
    [demo.variants],
  );

  return (
    <div className={styles.container}>
      {/* Demo Preview */}
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      {/* Code Section */}
      <div className={styles.codeSection}>
        <div className={styles.header}>
          <div className={styles.headerContainer}>
            {/* File Tabs */}
            <div className={styles.tabContainer}>
              {demo.files.length > 1 ? (
                <Tabs
                  tabs={tabs}
                  selectedTabId={demo.selectedFileName}
                  onTabSelect={demo.selectFileName}
                />
              ) : (
                <span className={styles.fileName}>{demo.selectedFileName}</span>
              )}
            </div>
            
            {/* Actions */}
            <div className={styles.headerActions}>
              <CopyButton copy={demo.copy} copyDisabled={demo.copyDisabled} />
              
              {/* Variant Selector */}
              {demo.variants.length > 1 && (
                <Select
                  items={variants}
                  value={demo.selectedVariant}
                  onValueChange={demo.selectVariant}
                />
              )}
              
              {/* Transform Toggle */}
              {hasJsTransform && (
                <div className={styles.switchContainer}>
                  <LabeledSwitch
                    checked={isJsSelected}
                    onCheckedChange={toggleJs}
                    labels={labels}
                  />
                </div>
              )}
            </div>
          </div>
        </div>
        
        {/* Code Display */}
        <div className={styles.code}>
          <pre className={styles.codeBlock}>
            {demo.selectedFile}
          </pre>
        </div>
      </div>
    </div>
  );
}
```

### Editable Demo (Live Editing)

```tsx
export function DemoLiveContent(props) {
  const demo = useDemo(props);

  const hasJsTransform = demo.availableTransforms.includes('js');
  const isJsSelected = demo.selectedTransform === 'js';

  const labels = { false: 'TS', true: 'JS' };
  const toggleJs = React.useCallback(
    (checked: boolean) => {
      demo.selectTransform(checked ? 'js' : null);
    },
    [demo],
  );

  const tabs = React.useMemo(
    () => demo.files.map(({ name }) => ({ id: name, name })),
    [demo.files],
  );

  const variants = React.useMemo(
    () => demo.variants.map((variant) => ({ 
      value: variant, 
      label: variantNames[variant] || variant 
    })),
    [demo.variants],
  );

  // Set up editable functionality
  const editorRef = React.useRef(null);
  const onChange = React.useCallback((text: string) => {
    demo.setSource?.(text);
  }, []);
  useEditable(editorRef, onChange, { 
    indentation: 2, 
    disabled: !demo.setSource 
  });

  return (
    <div className={styles.container}>
      {/* Live Demo Preview */}
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      {/* Editable Code Section */}
      <div className={styles.codeSection}>
        <div className={styles.header}>
          <div className={styles.headerContainer}>
            <div className={styles.tabContainer}>
              {demo.files.length > 1 ? (
                <Tabs
                  tabs={tabs}
                  selectedTabId={demo.selectedFileName}
                  onTabSelect={demo.selectFileName}
                />
              ) : (
                <span className={styles.fileName}>{demo.selectedFileName}</span>
              )}
            </div>
            <div className={styles.headerActions}>
              {demo.variants.length > 1 && (
                <Select
                  items={variants}
                  value={demo.selectedVariant}
                  onValueChange={demo.selectVariant}
                />
              )}
              {hasJsTransform && (
                <div className={styles.switchContainer}>
                  <LabeledSwitch
                    checked={isJsSelected}
                    onCheckedChange={toggleJs}
                    labels={labels}
                  />
                </div>
              )}
            </div>
          </div>
        </div>
        
        {/* Editable Code Block */}
        <div className={styles.code}>
          <pre className={styles.codeBlock} ref={editorRef}>
            {demo.selectedFile}
          </pre>
        </div>
      </div>
    </div>
  );
}
```

## API Reference

### Parameters

#### `contentProps: ContentProps<T>`

The content properties passed from your parent component - these should always be passed directly to `useDemo()` without accessing them directly:

```tsx
export function DemoContent(props: ContentProps<{}>) {
  const demo = useDemo(props); // Pass props directly to useDemo
  
  // Never access props.name, props.code, etc. directly
  // Use demo.name, demo.selectedFile, etc. instead
}
```

#### `opts?: UseDemoOpts`

Optional configuration object:

```tsx
interface UseDemoOpts {
  defaultOpen?: boolean;          // Whether to start expanded
  copy?: UseCopierOpts;          // Copy functionality options
  githubUrlPrefix?: string;      // GitHub URL prefix for links
  codeSandboxUrlPrefix?: string; // CodeSandbox URL prefix
  stackBlitzPrefix?: string;     // StackBlitz URL prefix
  initialVariant?: string;       // Initially selected variant
  initialTransform?: string;     // Initially selected transform
}
```

### Return Value

The hook returns all `useCode` properties plus demo-specific additions:

#### Demo Properties
- **`component: React.ReactNode`** - The React component for the current variant (for live preview)
- **`ref: React.RefObject<HTMLDivElement | null>`** - Ref for the demo container element
- **`resetFocus: () => void`** - Function to reset focus to the demo container
- **`name: string | undefined`** - Display name for the demo
- **`slug: string | undefined`** - URL-friendly identifier (auto-generated from name)

#### Inherited from useCode
All properties from `useCode` are available with exact types:
- **`variants: string[]`**, **`selectedVariant: string`**, **`selectVariant: React.Dispatch<React.SetStateAction<string>>`**
- **`files: Array<{ name: string; component: React.ReactNode }>`**, **`selectedFile: React.ReactNode`**, **`selectedFileName: string | undefined`**, **`selectFileName: (fileName: string) => void`**
- **`expanded: boolean`**, **`expand: () => void`**, **`setExpanded: React.Dispatch<React.SetStateAction<boolean>>`**
- **`copy: (event: React.MouseEvent<HTMLButtonElement>) => Promise<void>`**
- **`availableTransforms: string[]`**, **`selectedTransform: string | null | undefined`**, **`selectTransform: (transformName: string | null) => void`**
- **`setSource?: (source: string) => void`** (when editing is available)

See [useCode documentation](../use-code/page.mdx) for detailed information about inherited functionality.

## Integration Patterns

### Standard Usage Pattern

The most common pattern is to use `useDemo` in a content component that receives props from the demo factory:

```tsx
// In your demo's Content component
export function DemoContent(props: ContentProps<{}>) {
  const demo = useDemo(props); // Always pass props directly
  
  return (
    <div className={styles.container}>
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      <div className={styles.codeSection}>
        <pre className={styles.codeBlock}>
          {demo.selectedFile}
        </pre>
      </div>
    </div>
  );
}
```

### Demo Factory Integration

This content component is used with the demo factory pattern, not as a direct child of `CodeHighlighter`:

```tsx
// [✓] Correct - Demo factory usage
const ButtonDemo = createDemo({
  name: 'Button Demo',
  code: buttonCode,
  components: { Default: ButtonComponent },
  Content: DemoContent,
});

// [x] Incorrect - Never use DemoContent as a direct child
<CodeHighlighter>
  <DemoContent /> {/* This won't work */}
</CodeHighlighter>
```

## Best Practices

### 1. Always Pass Props Directly
```tsx
export function DemoContent(props: ContentProps<{}>) {
  const demo = useDemo(props); // [✓] Pass props directly
  
  // [x] Never access props.name, props.code, etc.
  // [✓] Use demo.name, demo.selectedFile, etc.
  
  return (
    <div className={styles.container}>
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      <div className={styles.codeSection}>
        <pre className={styles.codeBlock}>
          {demo.selectedFile}
        </pre>
      </div>
    </div>
  );
}
```

### 2. Conditional UI Elements
```tsx
export function DemoContent(props) {
  const demo = useDemo(props);

  return (
    <div className={styles.container}>
      {demo.component}
      
      {/* Only show file tabs if multiple files */}
      {demo.files.length > 1 ? (
        <Tabs 
          tabs={demo.files.map(f => ({ id: f.name, name: f.name }))}
          selectedTabId={demo.selectedFileName}
          onTabSelect={demo.selectFileName}
        />
      ) : (
        <span>{demo.selectedFileName}</span>
      )}
      
      <pre className={styles.codeBlock}>
        {demo.selectedFile}
      </pre>
    </div>
  );
}
```

### 3. Simple Transform Toggle
```tsx
export function DemoContent(props) {
  const demo = useDemo(props);

  const hasTransforms = demo.availableTransforms.length > 0;
  const isJsSelected = demo.selectedTransform === 'js';

  return (
    <div className={styles.container}>
      {demo.component}
      
      {hasTransforms && (
        <button onClick={() => demo.selectTransform(isJsSelected ? null : 'js')}>
          {isJsSelected ? 'Show TS' : 'Show JS'}
        </button>
      )}
      
      <pre className={styles.codeBlock}>
        {demo.selectedFile}
      </pre>
    </div>
  );
}
```

## Common Patterns

### Simple Demo Display

The most basic pattern for showing a component with its code:

```tsx
export function DemoContent(props) {
  const demo = useDemo(props);

  return (
    <div className={styles.container}>
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      <div className={styles.codeSection}>
        <pre className={styles.codeBlock}>
          {demo.selectedFile}
        </pre>
      </div>
    </div>
  );
}
```

### Demo with File Navigation

When you have multiple files to show:

```tsx
export function MultiFileDemoContent(props) {
  const demo = useDemo(props);

  return (
    <div className={styles.container}>
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      <div className={styles.codeSection}>
        {demo.files.length > 1 && (
          <div className={styles.fileNav}>
            {demo.files.map(file => (
              <button 
                key={file.name}
                onClick={() => demo.selectFileName(file.name)}
                className={demo.selectedFileName === file.name ? styles.active : ''}
              >
                {file.name}
              </button>
            ))}
          </div>
        )}
        
        <pre className={styles.codeBlock}>
          {demo.selectedFile}
        </pre>
      </div>
    </div>
  );
}
```

### Demo with Language Toggle

For demos that support TypeScript/JavaScript switching:

```tsx
export function DemoWithLanguageToggle(props) {
  const demo = useDemo(props);
  
  const canToggleJs = demo.availableTransforms.includes('js');
  const showingJs = demo.selectedTransform === 'js';

  return (
    <div className={styles.container}>
      <div className={styles.demoSection}>
        {demo.component}
      </div>
      
      <div className={styles.codeSection}>
        {canToggleJs && (
          <div className={styles.languageToggle}>
            <button 
              onClick={() => demo.selectTransform(showingJs ? null : 'js')}
            >
              {showingJs ? 'TypeScript' : 'JavaScript'}
            </button>
          </div>
        )}
        
        <pre className={styles.codeBlock}>
          {demo.selectedFile}
        </pre>
      </div>
    </div>
  );
}
```

## Performance Considerations

- **Component memoization**: Components are automatically memoized by the demo factory
- **Code lazy loading**: Inherited from `useCode` - syntax highlighting can be deferred
- **Transform caching**: Transform results are cached for quick switching
- **File switching**: File navigation is optimized for instant switching

## Error Handling

`useDemo` inherits error handling from `useCode` and adds demo-specific safeguards:

- **Missing components**: Gracefully handles when components aren't available for a variant
- **Invalid names/slugs**: Provides fallback values for missing identification
- **Component render errors**: Use React Error Boundaries to catch component-specific issues

## Troubleshooting

### Component Not Rendering
- Verify the component is passed in the `components` prop
- Check that the variant name matches between `code` and `components`
- Ensure the component doesn't have render-blocking errors

### Code Not Showing
- See [useCode troubleshooting](../use-code/page.mdx#troubleshooting) for code-related issues
- Verify `contentProps` contains the expected code structure

### Slug Not Generated
- Provide either a `name` or `slug` in `contentProps`
- The slug is auto-generated using kebab-case from the name

## Related

- **[useCode](../use-code/page.mdx)**: The underlying hook for code management (see [useCode documentation](../use-code/page.mdx))
- **[CodeHighlighter](../../components/code-highlighter/page.mdx)**: The main component that provides context for demos
- **[abstractCreateDemo](../../functions/abstract-create-demo/page.mdx)**: Factory function for creating precomputed demos
