/**
 * Core GitHub OAuth authentication utilities
 *
 * This utility provides core GitHub OAuth functionality using openid-client.
 * It handles token storage, refresh, and device flow initiation.
 * CLI-specific user interaction is handled in cli/cmdGithubAuth.mjs.
 *
 * @generated by Claude Code
 */

import {
  createDeviceCode,
  exchangeDeviceCode,
  refreshToken as ghRefreshToken,
} from '@octokit/oauth-methods';
import clipboardy from 'clipboardy';
import open from 'open';

import { credentialManager } from './credentials.mjs';

const GITHUB_APP_CLIENT_ID = 'Iv23lilHsGU3i1tIARsT'; // MUI Code Infra Oauth App
// Use the client id as the key so that if it changes, we don't conflict with old tokens
const GITHUB_APP_CREDENTIAL_KEY = GITHUB_APP_CLIENT_ID;

/**
 * @typedef {Object} GitHubAppAuthenticationWithRefreshToken
 * @property {string} token - The access token
 * @property {string} [expiresAt] - ISO string when the access token expires
 * @property {string} [refreshToken] - The refresh token
 * @property {string} [refreshTokenExpiresAt] - ISO string when the refresh token expires
 */

export const ERRORS = {
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  REFRESH_FAILED: 'REFRESH_FAILED',
  AUTH_REQUIRED: 'AUTH_REQUIRED',
  TIMEOUT: 'TIMEOUT',
};

export function persistentAuthStrategy() {
  function createCachedToken() {
    /**
     * @type {string}
     */
    let token = '';
    let timeSinceAccess = 0;
    let lastAccess = Date.now();

    return async function getToken() {
      if (!token) {
        token = await endToEndGhAuthGetToken(true);
      }
      const now = Date.now();
      timeSinceAccess += now - lastAccess;
      lastAccess = now;
      // Reset token if it has been more than 5 minutes since last access
      if (timeSinceAccess > 1 * 60 * 1000) {
        timeSinceAccess = 0;
        token = '';
      }
      return token;
    };
  }
  const getToken = createCachedToken();
  /**
   * Request hook to add authentication token to requests.
   * Automatically handles token refresh on 401 errors.
   *
   * @param {import('@octokit/types').RequestInterface} request
   * @param {import('@octokit/types').Route} route
   * @param {import('@octokit/types').RequestParameters} parameters
   * @returns
   */
  async function hook(request, route, parameters) {
    const token = await getToken();
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = `token ${token}`;
    try {
      // @ts-expect-error - request.endpoint.merge doesn't return correct type
      return await request(endpoint);
    } catch (error) {
      const err =
        /** @type {import('@octokit/types').RequestError & {response: {data: {message: string}}}} */ (
          error
        );
      if (err.status === 401 && err.response.data.message.toLowerCase() === 'bad credentials') {
        // refresh token and retry again
        await clearGitHubAuth();
        const newToken = await endToEndGhAuthGetToken();
        endpoint.headers.authorization = `token ${newToken}`;
        // @ts-expect-error - request.endpoint.merge doesn't return correct type
        return await request(endpoint);
      }
      throw error;
    }
  }

  return { hook };
}

/**
 * @param {Object} data
 * @param {string} data.url
 * @param {string} data.code
 * @param {Object} options
 * @param {boolean} [options.openInBrowser=true] - Whether to open the URL in the default browser
 * @param {boolean} [options.copyToCliboard=true] - Whether to copy the code to clipboard
 * @returns {Promise<void>}
 */
async function logAuthInformation(data, { openInBrowser = true, copyToCliboard = true } = {}) {
  if (copyToCliboard) {
    await clipboardy.write(data.code);
    console.warn(`Pasted authentication code ${data.code} to system clipboard...`);
  } else {
    console.warn(`To authenticate, paste "${data.code}" when prompted.`);
  }
  if (openInBrowser) {
    console.warn(`Press enter to open ${data.url} in default browser, or goto the link manually.`);
    await open(data.url);
  } else {
    console.warn(`Open ${data.url} in your browser to authenticate.`);
  }
}

/**
 * Checks if the stored access token is expired
 * @returns {Promise<boolean>}
 */
async function isTokenExpired() {
  try {
    const credentials = await getCredentialData();

    if (credentials.expiresAt) {
      return Date.now() > new Date(credentials.expiresAt).getTime();
    }

    if (credentials.refreshTokenExpiresAt) {
      return Date.now() > new Date(credentials.refreshTokenExpiresAt).getTime();
    }
    return false;
  } catch (error) {
    return true; // If we can't get expiry, assume expired
  }
}

/**
 *
 * @returns {Promise<GitHubAppAuthenticationWithRefreshToken>} Stored GitHub authentication tokens
 */
async function getCredentialData() {
  const data = await credentialManager.getPassword(GITHUB_APP_CREDENTIAL_KEY);
  if (!data) {
    return {
      token: '',
    };
  }
  return /** @type {GitHubAppAuthenticationWithRefreshToken} */ (JSON.parse(data));
}

/**
 * Stores GitHub authentication tokens securely
 * @param {{token: string, refreshToken?: string, expiresAt?: string; refreshTokenExpiresAt?: string}} tokens - Token response from openid-client
 * @returns {Promise<void>}
 */
async function storeGitHubTokens(tokens) {
  /**
   * @type {GitHubAppAuthenticationWithRefreshToken}
   */
  const newTokens = {
    token: tokens.token,
    expiresAt: tokens.expiresAt,
    refreshToken: tokens.refreshToken,
    refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
  };

  await credentialManager.setPassword(GITHUB_APP_CREDENTIAL_KEY, JSON.stringify(newTokens));
}

/**
 * @returns {Promise<string>} Refreshed GitHub access token
 */
async function refreshAccessToken() {
  const credentials = await getCredentialData();
  if (!credentials.refreshToken) {
    throw new Error(ERRORS.REFRESH_FAILED);
  }
  if (
    credentials.refreshTokenExpiresAt &&
    Date.now() > new Date(credentials.refreshTokenExpiresAt).getTime()
  ) {
    // Refresh token has also expired. Need to re-authenticate
    await clearGitHubAuth();
    throw new Error(ERRORS.AUTH_REQUIRED);
  }
  const { authentication } = await ghRefreshToken({
    clientId: GITHUB_APP_CLIENT_ID,
    refreshToken: credentials.refreshToken,
    clientType: 'github-app',
    clientSecret: '',
  });
  storeGitHubTokens(authentication);
  return authentication.token;
}

/**
 * @returns {Promise<{url: string, code: string; deviceCode: string}>} Device flow response with verification URI and user code
 */
async function getAuthInformation() {
  const { data } = await createDeviceCode({
    clientId: GITHUB_APP_CLIENT_ID,
    clientType: 'github-app',
  });
  return {
    url: data.verification_uri,
    code: data.user_code,
    deviceCode: data.device_code,
  };
}

/**
 * Retries exchanging device code for tokens until success or timeout.
 * Defaults to 12 retries with 5s delay (1 minute total).
 * Has initial delay to allow user to enter code in browser.
 *
 * @param {string} deviceCode
 * @param {{delay?: number, retries?: number}} [options]
 * @returns {Promise<import('@octokit/oauth-methods').GitHubAppAuthenticationWithRefreshToken>}
 */
async function exchangeDeviceCodeWithRetry(deviceCode, { delay = 5000, retries = 12 } = {}) {
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }
  try {
    const { authentication } = await exchangeDeviceCode({
      clientId: GITHUB_APP_CLIENT_ID,
      clientType: 'github-app',
      code: deviceCode,
    });
    return /** @type {import('@octokit/oauth-methods').GitHubAppAuthenticationWithRefreshToken} */ (
      authentication
    );
  } catch (/** @type {any} */ ex) {
    if (ex.response.data.error !== 'authorization_pending') {
      throw ex; // Some other error
    }
    if (retries > 0) {
      console.warn('Retrying device code exchange...');
      return exchangeDeviceCodeWithRetry(deviceCode, { delay, retries: retries - 1 });
    }
    throw new Error(ERRORS.TIMEOUT);
  }
}

/**
 * @returns {Promise<string>} Valid GitHub access token
 */
export async function endToEndGhAuthGetToken(log = false) {
  try {
    const credentials = await getCredentialData();
    if (!credentials.token) {
      throw new Error(ERRORS.AUTH_REQUIRED);
    }

    if (await isTokenExpired()) {
      throw new Error(ERRORS.TOKEN_EXPIRED);
    }

    return credentials.token;
  } catch (ex) {
    switch (/** @type {Error} */ (ex).message) {
      case ERRORS.AUTH_REQUIRED: {
        if (log) {
          console.warn("üîç GitHub token doesn't exist. Starting authentication flow...");
        }
        const data = await getAuthInformation();
        await logAuthInformation(data);
        const tokens = await exchangeDeviceCodeWithRetry(data.deviceCode);
        await storeGitHubTokens(tokens);

        return tokens.token;
      }
      case ERRORS.TOKEN_EXPIRED:
        if (log) {
          console.warn('GitHub token expired. Attempting to refresh...');
        }
        return refreshAccessToken();
      default:
        throw ex; // Some other error
    }
  }
}

/**
 * Clears stored GitHub authentication tokens
 * @returns {Promise<void>}
 */
export async function clearGitHubAuth() {
  return credentialManager.deleteKey(GITHUB_APP_CREDENTIAL_KEY);
}
