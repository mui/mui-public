/**
 * Core GitHub OAuth authentication utilities
 *
 * This utility provides core GitHub OAuth functionality using openid-client.
 * It handles token storage, refresh, and device flow initiation.
 * CLI-specific user interaction is handled in cli/cmdGithubAuth.mjs.
 *
 * @generated by Claude Code
 */

import {
  createDeviceCode,
  exchangeDeviceCode,
  refreshToken as ghRefreshToken,
} from '@octokit/oauth-methods';
import clipboardy from 'clipboardy';
import open from 'open';

import {
  getCredential,
  removeCredential,
  setCredential,
  ERRORS as CREDENTIAL_ERRORS,
} from './credentials.mjs';

const GITHUB_CLIENT_ID = 'Iv23lilHsGU3i1tIARsT'; // MUI Code Infra Oauth App
const KEY_ACCESS_TOKEN = 'github.access-token';
const KEY_ACCESS_TOKEN_EXPIRY = 'github.access-token-expiry';
const KEY_REFRESH_TOKEN = 'github.refresh-token';
const KEY_REFRESH_TOKEN_EXPIRY = 'github.refresh-token-expiry';

export const ERRORS = {
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  REFRESH_FAILED: 'REFRESH_FAILED',
  AUTH_REQUIRED: 'AUTH_REQUIRED',
  TIMEOUT: 'TIMEOUT',
};

/**
 * @param {Object} data
 * @param {string} data.url
 * @param {string} data.code
 * @param {Object} options
 * @param {boolean} [options.openInBrowser=true] - Whether to open the URL in the default browser
 * @param {boolean} [options.copyToCliboard=true] - Whether to copy the code to clipboard
 * @returns {Promise<void>}
 */
export async function logAuthInformation(
  data,
  { openInBrowser = true, copyToCliboard = true } = {},
) {
  if (copyToCliboard) {
    await clipboardy.write(data.code);
    console.warn(`Pasted authentication code ${data.code} to system clipboard...`);
  } else {
    console.warn(`To authenticate, paste "${data.code}" when prompted.`);
  }
  if (openInBrowser) {
    console.warn(`Opening ${data.url} in default browser...`);
    await open(data.url);
  } else {
    console.warn(`Open ${data.url} in your browser to authenticate.`);
  }
}

/**
 * Checks if the stored access token is expired
 * @returns {Promise<boolean>}
 */
async function isTokenExpired() {
  try {
    const expiryStr = await getCredential(KEY_ACCESS_TOKEN_EXPIRY);
    const expiry = parseInt(expiryStr, 10);
    const refreshExpiryStr = await getCredential(KEY_REFRESH_TOKEN_EXPIRY);
    if (refreshExpiryStr) {
      const refreshExpiry = parseInt(refreshExpiryStr, 10);
      if (Date.now() > refreshExpiry) {
        return true; // Refresh token expired
      }
    }
    return Date.now() > expiry;
  } catch (error) {
    return true; // If we can't get expiry, assume expired
  }
}

/**
 * Stores GitHub authentication tokens securely
 * @param {{token: string, refreshToken?: string, expiresAt?: string; refreshTokenExpiresAt?: string}} tokens - Token response from openid-client
 * @returns {Promise<void>}
 */
export async function storeGitHubTokens(tokens) {
  const expiryTime = tokens.expiresAt
    ? new Date(tokens.expiresAt).getTime()
    : Date.now() + 30 * 24 * 3600 * 1000; // Token doesn't expire, set arbitrary 30 days expiry

  // Store tokens using setCredential
  await setCredential(KEY_ACCESS_TOKEN, tokens.token);
  if (tokens.refreshToken) {
    await setCredential(KEY_REFRESH_TOKEN, tokens.refreshToken);
  }
  if (tokens.refreshTokenExpiresAt) {
    const refreshExpiryTime = new Date(tokens.refreshTokenExpiresAt).getTime();
    await setCredential(KEY_REFRESH_TOKEN_EXPIRY, refreshExpiryTime.toString());
  }
  await setCredential(KEY_ACCESS_TOKEN_EXPIRY, expiryTime.toString());
}

/**
 * Gets stored GitHub access token (if valid and not expired)
 * @returns {Promise<string>} Valid GitHub access token
 * @throws {Error} If no valid token exists
 */
export async function getStoredGitHubToken() {
  const existingToken = await getCredential(KEY_ACCESS_TOKEN);

  if (await isTokenExpired()) {
    throw new Error(ERRORS.TOKEN_EXPIRED);
  }

  return existingToken;
}

export async function refreshAccessToken() {
  const refreshToken = await getCredential(KEY_REFRESH_TOKEN);
  if (!refreshToken) {
    throw new Error(ERRORS.REFRESH_FAILED);
  }
  const refreshTokenExpiry = await getCredential(KEY_REFRESH_TOKEN_EXPIRY);
  if (refreshTokenExpiry && Date.now() > parseInt(refreshTokenExpiry, 10)) {
    // Refresh token has also expired. Need to re-authenticate
    await clearGitHubAuth();
    throw new Error(ERRORS.AUTH_REQUIRED);
  }
  const { authentication } = await ghRefreshToken({
    clientId: GITHUB_CLIENT_ID,
    refreshToken,
    clientType: 'github-app',
    clientSecret: '',
  });
  storeGitHubTokens(authentication);
  return authentication.token;
}

/**
 * @returns {Promise<{url: string, code: string; deviceCode: string}>} Device flow response with verification URI and user code
 */
export async function getAuthInformation() {
  const { data } = await createDeviceCode({
    clientId: GITHUB_CLIENT_ID,
    clientType: 'github-app',
  });
  return {
    url: data.verification_uri,
    code: data.user_code,
    deviceCode: data.device_code,
  };
}

/**
 * Retries exchanging device code for tokens until success or timeout.
 * Defaults to 12 retries with 5s delay (1 minute total).
 * Has initial delay to allow user to enter code in browser.
 *
 * @param {string} deviceCode
 * @param {{delay?: number, retries?: number}} [options]
 * @returns {Promise<import('@octokit/oauth-methods').GitHubAppAuthenticationWithRefreshToken>}
 */
async function exchangeDeviceCodeWithRetry(deviceCode, { delay = 5000, retries = 12 } = {}) {
  if (delay) {
    await new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }
  try {
    const { authentication } = await exchangeDeviceCode({
      clientId: GITHUB_CLIENT_ID,
      clientType: 'github-app',
      code: deviceCode,
    });
    return /** @type {import('@octokit/oauth-methods').GitHubAppAuthenticationWithRefreshToken} */ (
      authentication
    );
  } catch (/** @type {any} */ ex) {
    if (ex.response.data.error !== 'authorization_pending') {
      throw ex; // Some other error
    }
    if (retries > 0) {
      console.warn('Retrying device code exchange...');
      return exchangeDeviceCodeWithRetry(deviceCode, { delay, retries: retries - 1 });
    }
    throw new Error(ERRORS.TIMEOUT);
  }
}

/**
 * @returns {Promise<string>} Valid GitHub access token
 */
export async function endToEndGhAuthGetToken(log = false) {
  try {
    const res = await getStoredGitHubToken();
    if (log) {
      console.warn('Existing valid GitHub token found.');
    }
    return res;
  } catch (ex) {
    switch (/** @type {Error} */ (ex).message) {
      case CREDENTIAL_ERRORS.NOT_FOUND: {
        if (log) {
          console.warn('No existing GitHub token found. Starting authentication flow...');
        }
        const data = await getAuthInformation();

        await logAuthInformation(data);
        const tokens = await exchangeDeviceCodeWithRetry(data.deviceCode);

        await storeGitHubTokens(tokens);

        return tokens.token;
      }
      case ERRORS.TOKEN_EXPIRED:
        if (log) {
          console.warn('GitHub token expired. Attempting to refresh...');
        }
        return refreshAccessToken();
      default:
        throw ex; // Some other error
    }
  }
}

/**
 * Gets a valid GitHub access token for API usage (non-interactive)
 * This function is for use by other utilities like changelog.mjs
 * @returns {Promise<string>} Valid GitHub access token
 * @throws {Error} If no valid token exists and authentication is required
 */
export async function getGitHubToken() {
  try {
    // Try to get existing valid token
    return await getStoredGitHubToken();
  } catch (error) {
    // Try refresh if token is expired
    try {
      return await refreshAccessToken();
    } catch (refreshError) {
      throw new Error(ERRORS.AUTH_REQUIRED);
    }
  }
}

/**
 * Clears stored GitHub authentication tokens
 * @returns {Promise<void>}
 */
export async function clearGitHubAuth() {
  try {
    await removeCredential(
      KEY_ACCESS_TOKEN,
      KEY_REFRESH_TOKEN,
      KEY_ACCESS_TOKEN_EXPIRY,
      KEY_REFRESH_TOKEN_EXPIRY,
    );
  } catch (error) {
    // Ignore errors if credentials don't exist
  }
}
