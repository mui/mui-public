# Loader Utils

[//]: types.ts '<-- Autogenerated By (do not edit the following markdown directly)'

## API Reference

### DirectoryEntry

```typescript
type DirectoryEntry = { name: string; isFile: boolean; isDirectory: boolean };
```

### DirectoryReader

```typescript
type DirectoryReader = (path: string) => Promise<DirectoryEntry[]>;
```

### ExternalImport

Represents an import from an external package (node\_modules).

```typescript
type ExternalImport = {
  names: {
    name: string;
    alias?: string;
    type: 'default' | 'named' | 'namespace';
    isType?: boolean;
  }[];
  positions: { start: number; end: number }[];
};
```

### externalsToPackages

```typescript
(externals: string[]) => Record<string, true>;
```

### extractNameAndSlugFromUrl

Extracts and formats a name and slug from a URL path

```typescript
(url: string) => { name: string; slug: string };
```

### fileUrlToPortablePath

Converts a file:// URL to a portable path format that can be used with path-module (POSIX-only).

This function is designed to work with isomorphic code that uses path-module,
which only supports POSIX paths. The key insight is that by stripping the `file://`
prefix and normalizing backslashes to forward slashes, we get a path that:

- On Unix: `/home/user/file.ts` - works directly with path-module
- On Windows: `/C:/Users/file.ts` - also works with path-module because it starts with `/`

The resulting path is NOT a valid filesystem path on Windows, but it's a valid
POSIX-style path for path manipulation. Use `fileURLToPath` from the `url` module
when you need to access the actual filesystem.

```typescript
(fileUrl: string) => string;
```

### getFileNameFromUrl

Extracts the filename and extension from a URL or file path.
This function is isomorphic and works in both Node.js and browser environments.
It properly handles compound extensions like .module.css, .d.ts, .test.js, etc.

```typescript
(url: string) => { fileName: string; extension: string };
```

### getLanguageFromExtension

Gets the language name from a file extension.

```typescript
(extension: string) => string | undefined;
```

### ImportName

Represents a single import name with its properties.

```typescript
type ImportName = {
  name: string;
  alias?: string;
  type: 'default' | 'named' | 'namespace';
  isType?: boolean;
};
```

### ImportPathPosition

Represents the position of an import path in the source code.

```typescript
type ImportPathPosition = { start: number; end: number };
```

### ImportsAndComments

The result of parsing import statements from source code.

```typescript
type ImportsAndComments = {
  relative: Record<string, RelativeImport>;
  externals: Record<string, ExternalImport>;
  code?: string;
  comments?: Record<number, string[]>;
};
```

### isJavaScriptModule

Checks if a file path or import path represents a JavaScript/TypeScript module

```typescript
(path: string) => boolean;
```

### JAVASCRIPT\_MODULE\_EXTENSIONS

Default file extensions for JavaScript/TypeScript modules that can be resolved

```typescript
['.ts', '.tsx', '.js', '.jsx', '.mdx', '.d.ts'];
```

### languageAliasMap

Maps language aliases to canonical language names.
Used to normalize short language names (e.g., from className like 'language-js')
to their full names.

```typescript
Record<string, string>;
```

### languageMap

Maps file extensions to language names.
These are user-friendly names that can be used in the `language` prop.

```typescript
Record<string, string>;
```

### normalizeLanguage

Normalizes a language name to its canonical form.
This handles aliases like 'js' -> 'javascript', 'ts' -> 'typescript'.

```typescript
(language: string) => string;
```

### parseImportsAndComments

Parse import and export-from statements from JavaScript/TypeScript/CSS code.

This function analyzes source code to extract all import and export-from statements,
categorizing them as either relative imports (local files) or external imports (packages).
It supports JavaScript, TypeScript, CSS, and MDX files.

Comment processing (stripping/collecting) is performed during import parsing
for efficiency. Since we must already parse the entire file character-by-character
to correctly identify imports while avoiding false positives in strings, comments,
and template literals, it's most efficient to handle comment processing in this
same pass rather than requiring separate parsing steps.

The function accepts file:// URLs or file paths and converts them internally to a
portable path format that works cross-platform. Resolved import paths are returned
in the same portable format (forward slashes, starting with /).

```typescript
(
  code: string,
  fileUrl: string,
  options?: {
    removeCommentsWithPrefix?: string[];
    notableCommentsPrefix?: string[];
  },
) => Promise<ImportsAndComments>;
```

### portablePathToFileUrl

Converts a portable path back to a file:// URL.

This is the inverse of `fileUrlToPortablePath`. It takes a portable path
(which always starts with `/`) and converts it back to a proper file:// URL.

```typescript
(portablePath: string) => string;
```

### ProcessImportsResult

```typescript
type ProcessImportsResult = {
  processedSource: string;
  extraFiles: Record<string, string>;
};
```

### processRelativeImports

Processes imports based on the specified storage mode, automatically handling
source rewriting when needed (e.g., for 'flat' mode). Works for both JavaScript and simple file types.

```typescript
(
  source: string,
  importResult: Record<
    string,
    { url: string; names: string[]; positions?: { start: number; end: number }[] }
  >,
  storeAt: StoreAtMode,
  isJsFile?: boolean,
  resolvedPathsMap?: Map<string, string>,
) => { processedSource: string; extraFiles: Record<string, string> };
```

### RelativeImport

Represents an import from a relative path (starts with ./ or ../).

```typescript
type RelativeImport = {
  url: string;
  names: {
    name: string;
    alias?: string;
    type: 'default' | 'named' | 'namespace';
    isType?: boolean;
  }[];
  includeTypeDefs?: true;
  positions: { start: number; end: number }[];
};
```

### removeImports

Removes entire import statements for the specified import paths.
This removes the full import line, not just the path.

```typescript
(
  source: string,
  importPathsToRemove: Set<string>,
  importResult: Record<string, { positions: { start: number; end: number }[] }>,
) => string;
```

### resolveImportResult

Resolves import result by separating JavaScript modules from static assets,
only resolving JavaScript modules and returning a combined map.
This function uses the new type-aware resolveModulePath function internally.

```typescript
(
  importResult: Record<
    string,
    {
      url: string;
      names: string[];
      includeTypeDefs?: true;
      positions?: { start: number; end: number }[];
    }
  >,
  readDirectory: (path: string) => Promise<DirectoryEntry[]>,
  options?: { extensions?: string[] },
) => Promise<Map<string, string>>;
```

### resolveModulePath

Resolves a module path by reading directory contents to find matching files.
This is more efficient than checking each file individually with stat calls.

Given a path like `file:///Code/mui-public/packages/docs-infra/docs/app/components/code-highlighter/demos/code/BasicCode`,
this function will try to find the actual file by checking for:

- `BasicCode.ts`, `BasicCode.tsx`, `BasicCode.js`, `BasicCode.jsx`
- `BasicCode/index.ts`, `BasicCode/index.tsx`, `BasicCode/index.js`, `BasicCode/index.jsx`

```typescript
(
  moduleUrl: string,
  readDirectory: (path: string) => Promise<DirectoryEntry[]>,
  options?: { extensions?: string[] },
  includeTypeDefs?: boolean,
) => Promise<string | TypeAwareResolveResult>;
```

### ResolveModulePathOptions

```typescript
type ResolveModulePathOptions = { extensions?: string[] };
```

### resolveModulePaths

Resolves multiple module paths efficiently by grouping them by directory
and performing batch directory lookups.

```typescript
(
  modulePaths: string[],
  readDirectory: (path: string) => Promise<DirectoryEntry[]>,
  options?: { extensions?: string[] },
) => Promise<Map<string, string>>;
```

### resolveVariantPaths

Resolves variant paths from a variants object mapping variant names to their file paths.
This function extracts the paths, resolves them using resolveModulePaths, and returns
a map from variant name to resolved file URL.

```typescript
(
  variants: Record<string, string>,
  readDirectory: (path: string) => Promise<DirectoryEntry[]>,
  options?: { extensions?: string[] },
) => Promise<Map<string, string>>;
```

### rewriteImports

Efficiently rewrites import paths using position data.
This avoids regex parsing and uses precise position information for replacement.
Works for both JavaScript/TypeScript and CSS imports.

```typescript
(
  source: string,
  importPathMapping: Map<string, string>,
  importResult: Record<string, { positions: { start: number; end: number }[] }>,
) => string;
```

### rewriteImportsToNull

Converts import statements to const declarations set to null.
This preserves variable names while removing the actual imports.
Useful when precomputing data that makes the imports unnecessary.

```typescript
(
  source: string,
  importPathsToRewrite: Set<string>,
  importResult: Record<
    string,
    {
      positions: { start: number; end: number }[];
      names: { name: string; alias?: string; type: string }[];
    }
  >,
) => string;
```

### StoreAtMode

```typescript
type StoreAtMode = 'canonical' | 'import' | 'flat';
```

### TYPE\_IMPORT\_EXTENSIONS

Extension priority for type-only imports - prioritize .d.ts first

```typescript
['.d.ts', '.ts', '.tsx', '.js', '.jsx', '.mdx'];
```

### TypeAwareResolveResult

```typescript
type TypeAwareResolveResult = { import: string; typeImport?: string };
```

### VALUE\_IMPORT\_EXTENSIONS

Extension priority for value imports - standard priority with .d.ts last

```typescript
['.ts', '.tsx', '.js', '.jsx', '.mdx', '.d.ts'];
```
