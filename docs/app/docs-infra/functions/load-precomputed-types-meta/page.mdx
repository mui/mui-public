# Types Meta Loader

The types meta loader is a Webpack/Turbopack loader that automatically generates comprehensive type documentation for your TypeScript components at build time. Write your components in TypeScript, and the loader extracts props, methods, and type signatures—ready to display in your documentation.

---

## Overview

The loader processes `types.ts` files that use the `createTypesMeta` factory pattern, analyzing your TypeScript components and extracting detailed metadata about their APIs. The factory returns a React component that displays interactive type documentation alongside your component.

> [!NOTE]
> The loader works with any `create*` function that follows the types meta pattern, not just `createTypesMeta`. You could have custom factory functions like `createApiReference()` or `createTypeDocs()` that return documentation components.

## Features

- **Automatic type extraction**: Analyzes TypeScript components and generates comprehensive API documentation
- **Build-time processing**: Type analysis happens during compilation for zero runtime overhead
- **Fast incremental builds**: Process-based singleton ensures language service persists across all compilations
- **Hot reloading**: Tracks all dependencies and updates documentation when types change
- **Error detection**: Suggests missing global types with helpful error messages
- **Flexible configuration**: Support for custom global types and multiple components per file

---

## Configuration

### Recommended: Next.js Setup

Add the loader to your `next.config.mjs`:

> [!NOTE]
> The Turbopack loader requires Next.js version v15.5 or later ([depends on this fix](https://github.com/vercel/next.js/pull/82112))

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  turbopack: {
    rules: {
      './app/**/types.ts': {
        as: '*.ts',
        loaders: ['@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta'],
      },
    },
  },
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    config.module.rules.push({
      test: /\/types\.ts$/,
      use: [defaultLoaders.babel, '@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta'],
    });

    return config;
  },
};
```

### File Structure

The loader processes `types.ts` files that contain `createTypesMeta` factory functions:

```
app/
├── components/
│   ├── button/
│   │   ├── types.ts          # ← createTypesMeta() processed here
│   │   ├── page.tsx          # ← Next.js page that uses the types
│   │   ├── Button.tsx
│   │   └── demos/
│   │       └── basic/
│   │           └── index.ts
│   └── input/
│       ├── types.ts          # ← And here
│       ├── page.mdx          # ← Or MDX page that uses the types
│       ├── Input.tsx
│       ├── InputLabel.tsx
│       └── demos/
│           └── advanced/
│               └── index.ts
```

---

## Usage

### Basic Types Meta File

Create a `types.ts` file with the factory pattern using a descriptive named export:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import Component from './Component';

export const TypesComponent = createTypesMeta(import.meta.url, Component);
```

### Using Types in Pages

Your `page.tsx` or `page.mdx` files can then import and render the component returned by `createTypesMeta`:

```typescript
// page.tsx
import { TypesComponent } from './types';

export default function ComponentPage() {
  // The types factory returns a React component that wraps your original component
  // and displays the extracted type information
  return <TypesComponent />;
}
```

The `createTypesMeta` factory processes your component and returns a new React component that:

- Renders your original component
- Displays comprehensive type information (props, methods, exports)
- Shows interactive documentation generated from TypeScript analysis

### Multiple Components

The loader handles multiple component variants automatically:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import MainComponent from './MainComponent';
import HelperComponent from './HelperComponent';

// Returns a component that documents both MainComponent and HelperComponent
export const TypesInputGroup = createTypesMeta(import.meta.url, { MainComponent, HelperComponent });
```

### Global Types Configuration

Specify global types for proper TypeScript compilation:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import ReactComponent from './ReactComponent';

export const TypesReactComponent = createTypesMeta(import.meta.url, ReactComponent, {
  globalTypes: ['react', 'react-dom', 'node'],
});
```

### Advanced Options

You can pass additional options for customization:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import Component from './Component';

export const TypesAdvancedComponent = createTypesMeta(import.meta.url, Component, {
  name: 'Advanced Component API',
  globalTypes: ['react', 'dom'],
  skipPrecompute: false,
  customOption: 'value',
});
```

---

## Global Types

Global types ensure the TypeScript compiler has access to necessary type definitions during analysis.

### Common Global Types

```typescript
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  globalTypes: [
    'react', // React types (React, JSX, etc.)
    'react-dom', // React DOM types
    'node', // Node.js globals (process, Buffer, etc.)
    'dom', // Browser/DOM globals (window, document, etc.)
  ],
});
```

### Automatic Error Detection

The loader automatically detects missing global types and provides helpful suggestions:

```bash
Error: Missing global types detected. Consider adding these to globalTypes: ['react', 'dom']

To fix this, update your createTypesMeta call:
export const TypesYourComponent = createTypesMeta(import.meta.url, YourComponent, {
  globalTypes: ['react', 'dom'],
});

Common globalTypes values:
- 'react' for React components
- 'react-dom' for React DOM types
- 'node' for Node.js globals
- 'dom' for browser/DOM globals
```

### Custom Global Types

You can also specify custom global type packages:

```typescript
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  globalTypes: ['react', '@types/lodash', '@mui/types'],
});
```

---

## Options Reference

### Factory Function Options

```typescript
interface FactoryOptions {
  name?: string; // Display name for the types meta
  slug?: string; // URL slug override
  skipPrecompute?: boolean; // Skip build-time processing (useful for debugging)
  globalTypes?: string[]; // Global type packages to include (see Global Types section)
  [customOption: string]: any; // Additional custom options
}
```

---

## Output Structure

The loader extracts comprehensive type information using [`typescript-api-extractor`](https://github.com/michaldudak/typescript-api-extractor/blob/main/README.md#output-format) and structures it as:

```typescript
interface TypeMetadata {
  [variantName: string]: ModuleNode;
}

// From typescript-api-extractor
declare class ModuleNode {
  name: string;
  exports: ExportNode[];
  imports: string[] | undefined;
}

declare class ExportNode {
  name: string;
  type: AnyType;
  documentation: Documentation | undefined;
  isPublic(requireExplicitAnnotation?: boolean): boolean;
}

declare class Documentation {
  description: string | undefined;
  defaultValue: unknown | undefined;
  visibility: Visibility | undefined;
  tags: DocumentationTag[];
  hasTag(name: string): boolean;
  getTagValue(name: string): string | undefined;
}

interface DocumentationTag {
  name: string;
  value: string | undefined;
}

type Visibility = 'public' | 'private' | 'internal';

// Type system
interface TypeNode {
  readonly kind: string;
  typeName: TypeName | undefined;
}

type AnyType =
  | ArrayNode
  | ComponentNode
  | EnumNode
  | ExternalTypeNode
  | FunctionNode
  | IntersectionNode
  | IntrinsicNode
  | LiteralNode
  | ObjectNode
  | TupleNode
  | TypeParameterNode
  | UnionNode;

// Key type nodes
declare class ComponentNode implements TypeNode {
  readonly kind: 'component';
  typeName: TypeName | undefined;
  props: PropertyNode[];
}

declare class PropertyNode {
  name: string;
  type: AnyType;
  documentation: Documentation | undefined;
  optional: boolean;
}

declare class IntrinsicNode implements TypeNode {
  readonly kind: 'intrinsic';
  typeName: TypeName | undefined;
  intrinsic:
    | 'string'
    | 'number'
    | 'boolean'
    | 'bigint'
    | 'null'
    | 'undefined'
    | 'void'
    | 'any'
    | 'unknown'
    | 'function';
}

declare class ObjectNode implements TypeNode {
  readonly kind: 'object';
  typeName: TypeName | undefined;
  properties: PropertyNode[];
  documentation: Documentation | undefined;
}
```

### Example Output

For a simple React component, the extracted metadata looks like:

```json
{
  "Default": {
    "name": "MyComponent",
    "exports": [
      {
        "name": "MyComponent",
        "type": {
          "kind": "component",
          "typeName": { "name": "MyComponent" },
          "props": [
            {
              "name": "title",
              "type": {
                "kind": "intrinsic",
                "intrinsic": "string"
              },
              "optional": false,
              "documentation": {
                "description": "The title to display",
                "tags": []
              }
            },
            {
              "name": "disabled",
              "type": {
                "kind": "intrinsic",
                "intrinsic": "boolean"
              },
              "optional": true,
              "documentation": {
                "description": "Whether the component is disabled",
                "tags": []
              }
            }
          ]
        }
      }
    ]
  }
}
```

---

## Rich Documentation Support

The loader supports rich markdown content in JSDoc comments, which is automatically converted to appropriate formats in the generated documentation.

### Component and Hook Descriptions

You can add JSDoc comments to the component or hook itself to provide an overview:

````typescript
/**
 * A customizable button component with multiple variants and states.
 *
 * This component supports various styling options and can be used throughout
 * your application for consistent button styling.
 *
 * Example usage:
 * ```tsx
 * <Button variant="primary" onClick={handleClick}>
 *   Click me
 * </Button>
 * ```
 *
 * @see https://example.com/button-guidelines for design guidelines
 */
export function Button(props: ButtonProps) {
  // ...
}
````

For hooks:

````typescript
/**
 * A hook for managing form state with validation.
 *
 * This hook provides form state management with built-in validation
 * and error handling capabilities.
 *
 * Example usage:
 * ```tsx
 * const { values, errors, handleChange } = useForm({
 *   initialValues: { email: '', password: '' },
 *   validate: validateLoginForm,
 * });
 * ```
 */
export function useForm<T>(options: UseFormOptions<T>) {
  // ...
}
````

Component-level descriptions support full markdown formatting including:

- Code blocks (rendered as markdown code fences)
- Lists (rendered as markdown lists)
- Links and emphasis
- Multiple paragraphs

### Code Examples in Descriptions

You can include code examples in your JSDoc comments:

````typescript
interface ButtonProps {
  /**
   * Click handler for the button.
   *
   * Example usage:
   * ```tsx
   * <Button onClick={() => console.log('clicked')} />
   * ```
   */
  onClick?: () => void;
}
````

**In Component Descriptions**: Code blocks are rendered as full markdown code fences.

**In Table Cells** (props, parameters, return values): Code blocks are automatically converted to inline code (`` `code` ``) to fit within markdown table constraints.

### Lists in Descriptions

Lists are automatically converted based on context:

```typescript
interface ButtonProps {
  /**
   * The button variant.
   *
   * Supported values:
   * - `primary` - Primary call-to-action
   * - `secondary` - Secondary actions
   * - `tertiary` - Tertiary actions
   */
  variant?: string;
}
```

**In Component Descriptions**: Lists are rendered as markdown lists.

**In Table Cells**: Lists are converted to comma-separated inline content: `primary, secondary, tertiary`.

### Links and Rich Formatting

You can use links, bold, italic, and other inline markdown:

```typescript
interface ButtonProps {
  /**
   * Determines if the button is disabled.
   *
   * See the [accessibility guide](https://example.com/a11y) for best practices.
   */
  disabled?: boolean;
}
```

All inline markdown formatting is preserved in both component descriptions and table cells.

---

## Types

import { TypesLoadPrecomputedTypesMeta } from './types';

<TypesLoadPrecomputedTypesMeta />

---

## Error Handling

### Single Factory Function per File

Only one `createTypesMeta` function call is allowed per `types.ts` file:

```typescript
// [x] Multiple calls will cause a build error
export const Meta1 = createTypesMeta(/* ... */);
export const Meta2 = createTypesMeta(/* ... */); // Error!

// [✓] Use separate files instead
// button/types.ts
export const TypesButton = createTypesMeta(/* ... */);

// input/types.ts
export const TypesInput = createTypesMeta(/* ... */);
```

### Missing TypeScript Configuration

The loader requires a valid `tsconfig.json`:

```typescript
// Checks these locations in order:
// 1. {rootContext}/tsconfig.json
// 2. {process.cwd()}/tsconfig.json

// If not found, throws:
// "Unable to locate tsconfig.json. Looked in: ..."
```

### Component Resolution Errors

If a component cannot be analyzed, the loader provides detailed error information:

```typescript
// Failed to parse variant ComponentName (file://...):
// [Specific TypeScript compilation error details]
```

### Invalid Function Signature

Your `createTypesMeta` function must follow this pattern:

```typescript
createTypesMeta(
  import.meta.url, // Required: file URL
  component, // Required: component or variant object
  { options }, // Optional: options object
);
```

---

## Architecture

The loader processes TypeScript types efficiently using a worker-based architecture that keeps webpack's main thread responsive.

### Main Thread (Webpack Loader)

The webpack loader runs in the main thread and handles:

- Parsing `createTypesMeta` factory calls from source files
- Resolving variant paths and TypeScript configuration
- Sending type extraction requests to the worker
- Receiving raw TypeScript exports from the worker
- Initializing inline syntax highlighting
- Formatting exports into type metadata (HAST/markdown generation)
- Reconstructing performance logs for visibility
- Replacing source code with precomputed data
- Generating markdown documentation

### Worker Thread (Singleton)

A dedicated worker thread maintains a singleton TypeScript language service that:

- Creates and caches the optimized TypeScript program
- Loads and caches all source files in memory
- Performs TypeScript parsing and type extraction
- Tracks file changes and updates versions for incremental compilation
- Returns raw TypeScript exports (serializable data only)
- **Persists across all module contexts**: Uses Node.js `process` object to maintain true singleton across Turbopack/webpack compilations

### Multi-Process Socket Architecture

When Next.js runs with multiple processes, the loader uses a socket-based IPC system to share a single TypeScript language service across all processes:

- **Lock-based server election**: Uses `proper-lockfile` for atomic lock acquisition
- **Single server worker**: One process acquires the lock and starts a socket server
- **Multiple client workers**: All other processes connect as socket clients
- **Unix domain socket**: `/tmp/mui-types-meta-worker.sock` for inter-process communication
- **Stale lock detection**: 10-second timeout prevents permanent deadlocks from crashed servers
- **Automatic cleanup**: Locks released gracefully on process exit

This architecture ensures:

1. Only one TypeScript program is created (87-92% performance improvement)
2. All processes share the same file cache (512+ files cached in memory)
3. First request creates language service (~500-1200ms), subsequent requests reuse it (~100-140ms)
4. Automatic fallback to local processing if socket communication fails

### Benefits

1. **Non-blocking Builds**: Heavy TypeScript operations run in worker, keeping webpack responsive
2. **Separation of Concerns**: Worker handles CPU-intensive parsing, main thread handles I/O-intensive formatting
3. **True Singleton via Process Object**: Language service persists across all module contexts in both Turbopack and webpack
4. **Multi-Process Sharing**: Socket-based IPC enables sharing single language service across all Next.js worker processes
5. **Memory Isolation**: TypeScript Program and AST objects never cross thread boundaries
6. **Efficient Reuse**: First load ~500ms-1.2s, subsequent loads ~100-140ms (up to 10x faster)
7. **Scalable Performance**: 87-92% performance improvement in multi-CPU builds by avoiding duplicate language services
8. **Robust Locking**: Atomic lock acquisition with stale detection prevents race conditions and deadlocks
9. **Clean Architecture**: Worker = TypeScript parsing, Main = HAST/markdown formatting, Socket = IPC

### Performance Flow

**Single Process Mode:**

```
Webpack Loader (Main Thread)          Worker Thread (Singleton via process)
─────────────────────────────         ──────────────────────────────────────
                                      ┌─ Language Service Cache (Shared)
                                      │  ├─ TypeScript Program
                                      │  ├─ files Map (512+ cached)
                                      │  └─ Type Checker
                                      │
Component 1 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (loads 512 files: ~500-1200ms)
                                      │
Component 2 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (reuses cache: ~110-140ms)
                                      │
Component 3 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (reuses cache: ~110-140ms)
```

**Multi-Process Mode:**

```
Process 1 (Main)          Socket Server Worker          Language Service
────────────────          ────────────────────          ────────────────
                                                        ┌─ Singleton Cache
                                                        │  ├─ Program
                                                        │  ├─ 512+ files
                                                        │  └─ Checker
                                                        │
request ──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~1200ms first)
                                                        │
Process 2 (Worker)                                      │
────────────────                                        │
request ──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~120ms reuse)
                                                        │
Process 3-N (Workers)                                   │
──────────────────                                      │
requests──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~42-354ms)

[All N processes share 1 language service via socket]
```

> [!NOTE]
> The singleton uses Node.js `process` object (not `globalThis`) to ensure the worker manager persists across all Turbopack module contexts. This solves the issue where Turbopack creates separate `globalThis` objects for different compilations.

### What Crosses Thread Boundaries

**Main → Worker** (serializable):

- File paths (strings)
- Compiler options (plain objects)
- Configuration (globalTypes, etc.)

**Worker → Main** (serializable):

- Raw TypeScript exports (`ExportNode[]`)
- Export metadata (allTypes, namespaces, importedFrom)
- Dependencies (string arrays)
- Performance logs (timing data)

**Never Crosses** (stays in worker):

- TypeScript `Program` object
- TypeScript `TypeChecker` object
- AST nodes and source files
- Language service instance

**Never Crosses** (stays in main thread):

- Formatted type metadata (HAST nodes)
- Markdown documentation
- Inline syntax highlighting singleton

---

## Performance Tracking

The loader includes comprehensive performance tracking that works across thread boundaries.

### Unified Performance Logs

Performance measurements from both the main thread and worker thread are combined into a single timeline:

```typescript
// Worker tracks its operations
const tracker = new PerformanceTracker();
const start = tracker.mark('program creation start');
// ... TypeScript work ...
const end = tracker.mark('program creation end');
tracker.measure('program creation', start, end);

// Performance logs sent back to main thread
return {
  variantData,
  performanceLogs: tracker.getLogs(),
};
```

```typescript
// Main thread reconstructs timeline
const workerStartTime = performance.now();
const result = await workerManager.processTypes({
  /* ... */
});

// Adjust worker times to main thread timeline
reconstructPerformanceLogs(result.performanceLogs, workerStartTime);

// Now all measurements appear in unified performance timeline
```

### Performance Output Example

```bash
[Worker] program creation: 498.11ms
[Worker] variant Default parsing: 120.34ms
| worker processing: 680.25ms
highlighting initialization: 15.23ms
type formatting: 45.67ms
| highlighting and markdown generation: 78.09ms
precompute replacement: 2.15ms
```

### Debugging Performance

Enable performance logging in your webpack configuration:

```javascript
// next.config.mjs
module.exports = {
  webpack: (config) => {
    config.module.rules.push({
      test: /\/types\.ts$/,
      use: [
        defaultLoaders.babel,
        {
          loader: '@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta',
          options: {
            performance: {
              logging: true, // Enable performance logs
              notableMs: 100, // Only log operations >100ms
              showWrapperMeasures: false,
            },
          },
        },
      ],
    });
    return config;
  },
};
```

### What Gets Measured

**Worker Thread**:

- Program creation time
- Each variant's parsing time
- Total processing time per variant

**Main Thread**:

- Worker communication overhead
- Performance log reconstruction
- Inline highlighting initialization
- Type formatting (HAST/markdown generation)
- Source code replacement
- Markdown generation
- Total end-to-end time

---

## Processing Pipeline

The loader follows these steps to extract type metadata:

### 1. Parse Factory Call (Main Thread)

The webpack loader finds your `createTypesMeta` function call and extracts the components and options from the source code.

### 2. Resolve Paths (Main Thread)

Resolves all variant paths, loads TypeScript configuration, and prepares the request for the worker.

### 3. Send to Worker (Main Thread)

Sends a serializable request to the worker thread containing:

- Project path and compiler options
- All entrypoint file paths
- Global types configuration
- Variant mapping

### 4. Create Optimized Program (Worker Thread)

The worker creates or reuses an optimized TypeScript program that:

- Loads only necessary files (70%+ performance improvement)
- Includes specified global types
- Respects your project's `tsconfig.json` settings
- Caches files in memory for subsequent requests

### 5. Extract Type Information (Worker Thread)

For each component variant, the worker:

- Analyzes the TypeScript AST
- Extracts props, methods, and type signatures
- Resolves complex type relationships
- Returns raw exports as serializable data
- Tracks all dependencies

### 6. Return Results (Worker Thread → Main Thread)

Worker sends back serializable data:

- Raw TypeScript exports (`ExportNode[]`)
- Export metadata (allTypes, namespaces, importedFrom)
- List of all file dependencies
- Performance timing logs

### 7. Format Types (Main Thread)

The main thread formats the raw exports:

- Initializes inline syntax highlighting
- Calls `formatComponentData()` for components
- Calls `formatHookData()` for hooks
- Generates HAST nodes and markdown
- Parallelizes formatting using `Promise.all()`

### 8. Process Results (Main Thread)

The main thread:

- Receives and formats type metadata
- Reconstructs performance timeline
- Replaces factory function call with precomputed data
- Generates markdown documentation
- Adds dependencies to webpack watch list

### Data Flow

```typescript
// Main Thread: Prepare request
const request = {
  projectPath: config.projectPath,
  compilerOptions: config.options,
  allEntrypoints: ['Component.tsx', 'types.ts'],
  globalTypes: ['react', 'node'],
  resolvedVariantMap: [['Default', 'file:///.../Component.tsx']],
};

// Send to worker
const result = await workerManager.processTypes(request);

// Worker Thread: Process types
function processTypesInWorker(request) {
  const program = createOptimizedProgram(/* ... */);
  const checker = program.getTypeChecker();

  // Extract raw exports for each variant
  const exports = parseExports(program, entrypoint);

  return {
    success: true,
    variantData: {
      Default: {
        exports,           // Raw ExportNode[]
        allTypes,          // All type exports
        namespaces,        // Export namespaces
        importedFrom,      // Import source
      },
    },
    allDependencies: [...],
    performanceLogs: [...],
  };
}

// Main Thread: Format raw exports
await ensureStarryNightInitialized();

const formattedTypes = await Promise.all(
  rawExports.map(async (exportNode) => {
    if (isPublicComponent(exportNode)) {
      return formatComponentData(exportNode, allTypes, namespaces);
    }
    if (isPublicHook(exportNode)) {
      return formatHookData(exportNode, namespaces);
    }
    return exportNode;
  }),
);

const variantData = { Default: { types: formattedTypes } };
const modifiedSource = replacePrecomputeValue(source, variantData, typesMetaCall);
```

### Result Structure

```typescript
// Your source before processing
export const TypesComponent = createTypesMeta(import.meta.url, Component);

// After processing (simplified)
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  precompute: {
    Default: {
      types: {
        default: {
          props: {
            /* detailed prop types */
          },
          exports: {
            /* component exports */
          },
          // ... comprehensive type metadata
        },
      },
    },
  },
});

// The factory function returns a React component that:
// 1. Renders your original Component
// 2. Displays the extracted type information
// 3. Provides interactive documentation UI
```
