# Types Meta Loader

The types meta loader is a Webpack/Turbopack loader that automatically generates comprehensive type documentation for your TypeScript components at build time. Write your components in TypeScript, and the loader extracts props, methods, and type signatures—ready to display in your documentation.

---

## Overview

The loader processes `types.ts` files that use the `createTypesMeta` factory pattern, analyzing your TypeScript components and extracting detailed metadata about their APIs. The factory returns a React component that displays interactive type documentation alongside your component.

> [!NOTE]
> The loader works with any `create*` function that follows the types meta pattern, not just `createTypesMeta`. You could have custom factory functions like `createApiReference()` or `createTypeDocs()` that return documentation components.

## Features

- **Automatic type extraction**: Analyzes TypeScript components and generates comprehensive API documentation
- **Build-time processing**: Type analysis happens during compilation for zero runtime overhead
- **Fast incremental builds**: Process-based singleton ensures language service persists across all compilations
- **Hot reloading**: Tracks all dependencies and updates documentation when types change
- **Error detection**: Suggests missing global types with helpful error messages
- **Flexible configuration**: Support for custom global types and multiple components per file

---

## Configuration

### Recommended: Next.js Setup

Add the loader to your `next.config.mjs`:

> [!NOTE]
> The Turbopack loader requires Next.js version v15.5 or later ([depends on this fix](https://github.com/vercel/next.js/pull/82112))

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  turbopack: {
    rules: {
      './app/**/types.ts': {
        as: '*.ts',
        loaders: ['@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta'],
      },
    },
  },
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    config.module.rules.push({
      test: /\/types\.ts$/,
      use: [defaultLoaders.babel, '@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta'],
    });

    return config;
  },
};
```

### File Structure

The loader processes `types.ts` files that contain `createTypesMeta` factory functions:

```
app/
├── components/
│   ├── button/
│   │   ├── types.ts          # ← createTypesMeta() processed here
│   │   ├── page.tsx          # ← Next.js page that uses the types
│   │   ├── Button.tsx
│   │   └── demos/
│   │       └── basic/
│   │           └── index.ts
│   └── input/
│       ├── types.ts          # ← And here
│       ├── page.mdx          # ← Or MDX page that uses the types
│       ├── Input.tsx
│       ├── InputLabel.tsx
│       └── demos/
│           └── advanced/
│               └── index.ts
```

---

## Usage

### Basic Types Meta File

Create a `types.ts` file with the factory pattern using a descriptive named export:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import Component from './Component';

export const TypesComponent = createTypesMeta(import.meta.url, Component);
```

### Using Types in Pages

Your `page.tsx` or `page.mdx` files can then import and render the component returned by `createTypesMeta`:

```typescript
// page.tsx
import { TypesComponent } from './types';

export default function ComponentPage() {
  // The types factory returns a React component that wraps your original component
  // and displays the extracted type information
  return <TypesComponent />;
}
```

The `createTypesMeta` factory processes your component and returns a new React component that:

- Renders your original component
- Displays comprehensive type information (props, methods, exports)
- Shows interactive documentation generated from TypeScript analysis

### Multiple Components

The loader handles multiple component variants automatically:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import MainComponent from './MainComponent';
import HelperComponent from './HelperComponent';

// Returns a component that documents both MainComponent and HelperComponent
export const TypesInputGroup = createTypesMeta(import.meta.url, { MainComponent, HelperComponent });
```

### Global Types Configuration

Specify global types for proper TypeScript compilation:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import ReactComponent from './ReactComponent';

export const TypesReactComponent = createTypesMeta(import.meta.url, ReactComponent, {
  globalTypes: ['react', 'react-dom', 'node'],
});
```

### Advanced Options

You can pass additional options for customization:

```typescript
import { createTypesMeta } from '../createTypesMeta';
import Component from './Component';

export const TypesAdvancedComponent = createTypesMeta(import.meta.url, Component, {
  name: 'Advanced Component API',
  globalTypes: ['react', 'dom'],
  skipPrecompute: false,
  customOption: 'value',
});
```

---

## Global Types

Global types ensure the TypeScript compiler has access to necessary type definitions during analysis.

### Common Global Types

```typescript
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  globalTypes: [
    'react', // React types (React, JSX, etc.)
    'react-dom', // React DOM types
    'node', // Node.js globals (process, Buffer, etc.)
    'dom', // Browser/DOM globals (window, document, etc.)
  ],
});
```

### Automatic Error Detection

The loader automatically detects missing global types and provides helpful suggestions:

```bash
Error: Missing global types detected. Consider adding these to globalTypes: ['react', 'dom']

To fix this, update your createTypesMeta call:
export const TypesYourComponent = createTypesMeta(import.meta.url, YourComponent, {
  globalTypes: ['react', 'dom'],
});

Common globalTypes values:
- 'react' for React components
- 'react-dom' for React DOM types
- 'node' for Node.js globals
- 'dom' for browser/DOM globals
```

### Custom Global Types

You can also specify custom global type packages:

```typescript
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  globalTypes: ['react', '@types/lodash', '@mui/types'],
});
```

---

## Options Reference

### Factory Function Options

```typescript
interface FactoryOptions {
  name?: string; // Display name for the types meta
  slug?: string; // URL slug override
  skipPrecompute?: boolean; // Skip build-time processing (useful for debugging)
  globalTypes?: string[]; // Global type packages to include (see Global Types section)
  [customOption: string]: any; // Additional custom options
}
```

---

## Output Structure

The loader extracts comprehensive type information using [`typescript-api-extractor`](https://github.com/michaldudak/typescript-api-extractor/blob/main/README.md#output-format) and structures it as:

```typescript
interface TypeMetadata {
  [variantName: string]: ModuleNode;
}

// From typescript-api-extractor
declare class ModuleNode {
  name: string;
  exports: ExportNode[];
  imports: string[] | undefined;
}

declare class ExportNode {
  name: string;
  type: AnyType;
  documentation: Documentation | undefined;
  isPublic(requireExplicitAnnotation?: boolean): boolean;
}

declare class Documentation {
  description: string | undefined;
  defaultValue: unknown | undefined;
  visibility: Visibility | undefined;
  tags: DocumentationTag[];
  hasTag(name: string): boolean;
  getTagValue(name: string): string | undefined;
}

interface DocumentationTag {
  name: string;
  value: string | undefined;
}

type Visibility = 'public' | 'private' | 'internal';

// Type system
interface TypeNode {
  readonly kind: string;
  typeName: TypeName | undefined;
}

type AnyType =
  | ArrayNode
  | ComponentNode
  | EnumNode
  | ExternalTypeNode
  | FunctionNode
  | IntersectionNode
  | IntrinsicNode
  | LiteralNode
  | ObjectNode
  | TupleNode
  | TypeParameterNode
  | UnionNode;

// Key type nodes
declare class ComponentNode implements TypeNode {
  readonly kind: 'component';
  typeName: TypeName | undefined;
  props: PropertyNode[];
}

declare class PropertyNode {
  name: string;
  type: AnyType;
  documentation: Documentation | undefined;
  optional: boolean;
}

declare class IntrinsicNode implements TypeNode {
  readonly kind: 'intrinsic';
  typeName: TypeName | undefined;
  intrinsic:
    | 'string'
    | 'number'
    | 'boolean'
    | 'bigint'
    | 'null'
    | 'undefined'
    | 'void'
    | 'any'
    | 'unknown'
    | 'function';
}

declare class ObjectNode implements TypeNode {
  readonly kind: 'object';
  typeName: TypeName | undefined;
  properties: PropertyNode[];
  documentation: Documentation | undefined;
}
```

### Example Output

For a simple React component, the extracted metadata looks like:

```json
{
  "Default": {
    "name": "MyComponent",
    "exports": [
      {
        "name": "MyComponent",
        "type": {
          "kind": "component",
          "typeName": { "name": "MyComponent" },
          "props": [
            {
              "name": "title",
              "type": {
                "kind": "intrinsic",
                "intrinsic": "string"
              },
              "optional": false,
              "documentation": {
                "description": "The title to display",
                "tags": []
              }
            },
            {
              "name": "disabled",
              "type": {
                "kind": "intrinsic",
                "intrinsic": "boolean"
              },
              "optional": true,
              "documentation": {
                "description": "Whether the component is disabled",
                "tags": []
              }
            }
          ]
        }
      }
    ]
  }
}
```

---

## Types

import { TypesLoadPrecomputedTypesMeta } from './types';

<TypesLoadPrecomputedTypesMeta />

---

## Error Handling

### Single Factory Function per File

Only one `createTypesMeta` function call is allowed per `types.ts` file:

```typescript
// [x] Multiple calls will cause a build error
export const Meta1 = createTypesMeta(/* ... */);
export const Meta2 = createTypesMeta(/* ... */); // Error!

// [✓] Use separate files instead
// button/types.ts
export const TypesButton = createTypesMeta(/* ... */);

// input/types.ts
export const TypesInput = createTypesMeta(/* ... */);
```

### Missing TypeScript Configuration

The loader requires a valid `tsconfig.json`:

```typescript
// Checks these locations in order:
// 1. {rootContext}/tsconfig.json
// 2. {process.cwd()}/tsconfig.json

// If not found, throws:
// "Unable to locate tsconfig.json. Looked in: ..."
```

### Component Resolution Errors

If a component cannot be analyzed, the loader provides detailed error information:

```typescript
// Failed to parse variant ComponentName (file://...):
// [Specific TypeScript compilation error details]
```

### Invalid Function Signature

Your `createTypesMeta` function must follow this pattern:

```typescript
createTypesMeta(
  import.meta.url, // Required: file URL
  component, // Required: component or variant object
  { options }, // Optional: options object
);
```

---

## Architecture

The loader processes TypeScript types efficiently using a worker-based architecture that keeps webpack's main thread responsive.

### Main Thread (Webpack Loader)

The webpack loader runs in the main thread and handles:

- Parsing `createTypesMeta` factory calls from source files
- Resolving variant paths and TypeScript configuration
- Sending type extraction requests to the worker
- Receiving precomputed type metadata from the worker
- Reconstructing performance logs for visibility
- Replacing source code with precomputed data

### Worker Thread (Singleton)

A dedicated worker thread maintains a singleton TypeScript language service that:

- Creates and caches the optimized TypeScript program
- Loads and caches all source files in memory
- Performs all TypeScript operations (parsing, type checking, formatting)
- Tracks file changes and updates versions for incremental compilation
- Returns only serializable type metadata (no TypeScript objects)
- **Persists across all module contexts**: Uses Node.js `process` object to maintain true singleton across Turbopack/webpack compilations

### Multi-Process Socket Architecture

When Next.js runs with multiple processes, the loader uses a socket-based IPC system to share a single TypeScript language service across all processes:

- **Lock-based server election**: Uses `proper-lockfile` for atomic lock acquisition
- **Single server worker**: One process acquires the lock and starts a socket server
- **Multiple client workers**: All other processes connect as socket clients
- **Unix domain socket**: `/tmp/mui-types-meta-worker.sock` for inter-process communication
- **Stale lock detection**: 10-second timeout prevents permanent deadlocks from crashed servers
- **Automatic cleanup**: Locks released gracefully on process exit

This architecture ensures:

1. Only one TypeScript program is created (87-92% performance improvement)
2. All processes share the same file cache (512+ files cached in memory)
3. First request creates language service (~500-1200ms), subsequent requests reuse it (~100-140ms)
4. Automatic fallback to local processing if socket communication fails

### Benefits

1. **Non-blocking Builds**: Heavy TypeScript operations run in worker, keeping webpack responsive
2. **True Singleton via Process Object**: Language service persists across all module contexts in both Turbopack and webpack
3. **Multi-Process Sharing**: Socket-based IPC enables sharing single language service across all Next.js worker processes
4. **Memory Isolation**: TypeScript Program and AST objects never cross thread boundaries
5. **Efficient Reuse**: First load ~500ms-1.2s, subsequent loads ~100-140ms (up to 10x faster)
6. **Scalable Performance**: 87-92% performance improvement in multi-CPU builds by avoiding duplicate language services
7. **Robust Locking**: Atomic lock acquisition with stale detection prevents race conditions and deadlocks
8. **Clean Separation**: Main thread handles I/O and webpack, worker handles TypeScript, socket handles IPC

### Performance Flow

**Single Process Mode:**

```
Webpack Loader (Main Thread)          Worker Thread (Singleton via process)
─────────────────────────────         ──────────────────────────────────────
                                      ┌─ Language Service Cache (Shared)
                                      │  ├─ TypeScript Program
                                      │  ├─ files Map (512+ cached)
                                      │  └─ Type Checker
                                      │
Component 1 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (loads 512 files: ~500-1200ms)
                                      │
Component 2 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (reuses cache: ~110-140ms)
                                      │
Component 3 ──request(paths)──────────┤
            ◄──metadata──────────────┤  (reuses cache: ~110-140ms)
```

**Multi-Process Mode:**

```
Process 1 (Main)          Socket Server Worker          Language Service
────────────────          ────────────────────          ────────────────
                                                        ┌─ Singleton Cache
                                                        │  ├─ Program
                                                        │  ├─ 512+ files
                                                        │  └─ Checker
                                                        │
request ──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~1200ms first)
                                                        │
Process 2 (Worker)                                      │
────────────────                                        │
request ──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~120ms reuse)
                                                        │
Process 3-N (Workers)                                   │
──────────────────                                      │
requests──socket────────► process ─────────────────────┤
        ◄────────────────metadata◄─────────────────────┤  (~42-354ms)

[All N processes share 1 language service via socket]
```

> [!NOTE]
> The singleton uses Node.js `process` object (not `globalThis`) to ensure the worker manager persists across all Turbopack module contexts. This solves the issue where Turbopack creates separate `globalThis` objects for different compilations.

### What Crosses Thread Boundaries

**Main → Worker** (serializable):

- File paths (strings)
- Compiler options (plain objects)
- Configuration (globalTypes, etc.)

**Worker → Main** (serializable):

- Type metadata (plain objects/arrays)
- Dependencies (string arrays)
- Performance logs (timing data)

**Never Crosses** (stays in worker):

- TypeScript `Program` object
- TypeScript `TypeChecker` object
- AST nodes and source files
- Language service instance

---

## Performance Tracking

The loader includes comprehensive performance tracking that works across thread boundaries.

### Unified Performance Logs

Performance measurements from both the main thread and worker thread are combined into a single timeline:

```typescript
// Worker tracks its operations
const tracker = new PerformanceTracker();
const start = tracker.mark('program creation start');
// ... TypeScript work ...
const end = tracker.mark('program creation end');
tracker.measure('program creation', start, end);

// Performance logs sent back to main thread
return {
  variantData,
  performanceLogs: tracker.getLogs(),
};
```

```typescript
// Main thread reconstructs timeline
const workerStartTime = performance.now();
const result = await workerManager.processTypes({
  /* ... */
});

// Adjust worker times to main thread timeline
reconstructPerformanceLogs(result.performanceLogs, workerStartTime);

// Now all measurements appear in unified performance timeline
```

### Performance Output Example

```bash
[Worker] program creation: 498.11ms
[Worker] variant Default parsing: 120.34ms
[Worker] variant Default formatting: 45.67ms
worker processing (with overhead): 680.25ms
precompute replacement: 2.15ms
types.md generation: 15.42ms
```

### Debugging Performance

Enable performance logging in your webpack configuration:

```javascript
// next.config.mjs
module.exports = {
  webpack: (config) => {
    config.module.rules.push({
      test: /\/types\.ts$/,
      use: [
        defaultLoaders.babel,
        {
          loader: '@mui/internal-docs-infra/pipeline/loadPrecomputedTypesMeta',
          options: {
            performance: {
              logging: true, // Enable performance logs
              notableMs: 100, // Only log operations >100ms
              showWrapperMeasures: false,
            },
          },
        },
      ],
    });
    return config;
  },
};
```

### What Gets Measured

**Worker Thread**:

- Program creation time
- Each variant's parsing time
- Each variant's formatting time
- Total processing time per variant

**Main Thread**:

- Worker communication overhead
- Performance log reconstruction
- Source code replacement
- Markdown generation
- Total end-to-end time

---

## Processing Pipeline

The loader follows these steps to extract type metadata:

### 1. Parse Factory Call (Main Thread)

The webpack loader finds your `createTypesMeta` function call and extracts the components and options from the source code.

### 2. Resolve Paths (Main Thread)

Resolves all variant paths, loads TypeScript configuration, and prepares the request for the worker.

### 3. Send to Worker (Main Thread)

Sends a serializable request to the worker thread containing:

- Project path and compiler options
- All entrypoint file paths
- Global types configuration
- Variant mapping

### 4. Create Optimized Program (Worker Thread)

The worker creates or reuses an optimized TypeScript program that:

- Loads only necessary files (70%+ performance improvement)
- Includes specified global types
- Respects your project's `tsconfig.json` settings
- Caches files in memory for subsequent requests

### 5. Extract Type Information (Worker Thread)

For each component variant, the worker:

- Analyzes the TypeScript AST
- Extracts props, methods, and type signatures
- Resolves complex type relationships
- Formats the data into serializable objects
- Tracks all dependencies

### 6. Return Results (Worker Thread → Main Thread)

Worker sends back serializable data:

- Extracted type metadata for all variants
- List of all file dependencies
- Performance timing logs

### 7. Process Results (Main Thread)

The main thread:

- Receives type metadata from worker
- Reconstructs performance timeline
- Replaces factory function call with precomputed data
- Generates markdown documentation
- Adds dependencies to webpack watch list

### Data Flow

```typescript
// Main Thread: Prepare request
const request = {
  projectPath: config.projectPath,
  compilerOptions: config.options,
  allEntrypoints: ['Component.tsx', 'types.ts'],
  globalTypes: ['react', 'node'],
  resolvedVariantMap: [['Default', 'file:///.../Component.tsx']],
};

// Send to worker
const result = await workerManager.processTypes(request);

// Worker Thread: Process types
function processTypesInWorker(request) {
  const program = createOptimizedProgram(/* ... */);
  const checker = program.getTypeChecker();

  // Extract types for each variant
  const types = exports.map(exportNode => {
    if (isPublicComponent(exportNode)) {
      return formatComponentData(exportNode, allTypes, namespaces);
    }
    // ...
  });

  return {
    success: true,
    variantData: { Default: { types } },
    allDependencies: [...],
    performanceLogs: [...],
  };
}

// Main Thread: Use results
const modifiedSource = replacePrecomputeValue(source, result.variantData, typesMetaCall);
```

### Result Structure

```typescript
// Your source before processing
export const TypesComponent = createTypesMeta(import.meta.url, Component);

// After processing (simplified)
export const TypesComponent = createTypesMeta(import.meta.url, Component, {
  precompute: {
    Default: {
      types: {
        default: {
          props: {
            /* detailed prop types */
          },
          exports: {
            /* component exports */
          },
          // ... comprehensive type metadata
        },
      },
    },
  },
});

// The factory function returns a React component that:
// 1. Renders your original Component
// 2. Displays the extracted type information
// 3. Provides interactive documentation UI
```
