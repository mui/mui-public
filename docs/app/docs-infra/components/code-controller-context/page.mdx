# Code Controller Context

The `CodeControllerContext` provides a React context for managing controlled code state in interactive code editing and demo scenarios. It enables real-time code editing with syntax highlighting and live component previews.

## Features

- **Interactive code editing** - Edit source code with real-time updates
- **Live component previews** - See component changes rendered instantly
- **Context-based state** - Shared state across multiple components
- **Simple integration** - Works with existing [`CodeHighlighter`](../code-highlighter/page.mdx) and demo components

## Examples

import { DemoCodeControllerCodeEditor } from './demos/code-editor';

<DemoCodeControllerCodeEditor.Title />

<DemoCodeControllerCodeEditor />

[See Demo](./demos/code-editor/)

---

import { DemoCodeControllerDemoLive } from './demos/demo-live';

<DemoCodeControllerDemoLive.Title />

<DemoCodeControllerDemoLive />

[See Demo](./demos/demo-live/)

---

import { DemoCodeControllerMultiFile } from './demos/multi-file';

<DemoCodeControllerMultiFile.Title />

<DemoCodeControllerMultiFile />

[See Demo](./demos/multi-file/)

## Basic Usage

The Code Controller provides a simple React context for managing controlled code state. It works with two main patterns:

### Pattern 1: Code Editor

For interactive code editing with syntax highlighting:

```tsx
'use client';

import * as React from 'react';
import { CodeProvider } from '@mui/internal-docs-infra/CodeProvider';
import { CodeControllerContext } from '@mui/internal-docs-infra/CodeControllerContext';
import { CodeHighlighter } from '@mui/internal-docs-infra/CodeHighlighter';

// Simple controller implementation
function CodeController({ children }: { children: React.ReactNode }) {
  const [code, setCode] = React.useState();
  const contextValue = React.useMemo(() => ({ code, setCode }), [code, setCode]);

  return (
    <CodeControllerContext.Provider value={contextValue}>{children}</CodeControllerContext.Provider>
  );
}

// Usage
function CodeEditor() {
  const initialCode = {
    Default: {
      url: 'file://example.js',
      fileName: 'example.js',
      source: `function greet(name) {
  return \`Hello, \${name}!\`;
}`,
    },
  };

  return (
    <CodeProvider>
      <CodeController>
        <CodeHighlighter
          url={initialCode.Default.url}
          code={initialCode}
          controlled
          Content={YourEditorContent}
        />
      </CodeController>
    </CodeProvider>
  );
}
```

### Pattern 2: Live Demo Controller

For live component previews with editable source code:

```tsx
'use client';

import * as React from 'react';
import { useRunner } from 'react-runner';
import { CodeControllerContext } from '@mui/internal-docs-infra/CodeControllerContext';

function DemoController({ children }: { children: React.ReactNode }) {
  const [code, setCode] = React.useState();

  // Create live component instances from code
  const components = React.useMemo(() => {
    if (!code) return undefined;

    return Object.keys(code).reduce((acc, variant) => {
      const source = code[variant]?.source;
      if (source) {
        acc[variant] = <Runner code={source} />;
      }
      return acc;
    }, {});
  }, [code]);

  const contextValue = React.useMemo(
    () => ({ code, setCode, components }),
    [code, setCode, components],
  );

  return (
    <CodeControllerContext.Provider value={contextValue}>{children}</CodeControllerContext.Provider>
  );
}
```

## Working with useCode Hook

The [`useCode`](../../hooks/use-code/page.mdx) hook automatically integrates with the CodeController context when the `controlled` prop is true:

```tsx
'use client';

import { useEditable } from 'use-editable';
import { useCode } from '@mui/internal-docs-infra/useCode';

function EditorContent(props) {
  const preRef = React.useRef<HTMLPreElement | null>(null);
  const code = useCode(props, { preRef });

  // code.setSource updates the controller automatically
  const onInput = React.useCallback(
    (text: string) => {
      code.setSource?.(text);
    },
    [code],
  );

  useEditable(preRef, onInput, { indentation: 2 });

  return (
    <div>
      <h4>{code.selectedFileName}</h4>
      {code.selectedFile}
    </div>
  );
}
```

## Working with useDemo Hook

The [`useDemo`](../../hooks/use-demo/page.mdx) hook provides additional functionality for live component demos:

```tsx
'use client';

import { useDemo } from '@mui/internal-docs-infra/useDemo';

function DemoContent(props) {
  const demo = useDemo(props);

  const onInput = React.useCallback(
    (text: string) => {
      demo.setSource?.(text);
    },
    [demo],
  );

  return (
    <div>
      {/* Live component preview */}
      <div>{demo.component}</div>

      {/* Editable source code */}
      <div>
        <select value={demo.selectedVariant} onChange={(e) => demo.selectVariant(e.target.value)}>
          {demo.variants.map((variant) => (
            <option key={variant} value={variant}>
              {variant}
            </option>
          ))}
        </select>

        <textarea value={demo.selectedFile} onChange={(e) => onInput(e.target.value)} />
      </div>
    </div>
  );
}
```

## Data Flow

The CodeController provides a simple state management pattern:

1. **Initial State**: Controller starts with empty state (`code: undefined`)
2. **Code Loading**: [`CodeHighlighter`](../code-highlighter/page.mdx) loads initial code from file or props
3. **User Interaction**: When users edit code, `setSource` calls `controlledSetCode`
4. **State Update**: Controller state updates and all connected components re-render
5. **Live Preview**: For demo controllers, components are regenerated from updated code

```tsx
// Flow: User Edit → setSource → controlledSetCode → Context Update → Re-render

function EditorContent(props) {
  const code = useCode(props); // Connects to controller context

  const onEdit = (newSource) => {
    code.setSource(newSource); // This updates the controller context
  };

  // code.selectedFile reflects the current controller state
  return <textarea value={code.selectedFile} onChange={onEdit} />;
}
```

## Integration with createDemo

The [`createDemo`](../../factories/abstract-create-demo/page.mdx) and `createLiveDemo` functions automatically handle controller integration:

```tsx
// demos/my-demo/index.ts
import { createDemo } from '@mui/internal-docs-infra/functions/createDemo';
import { MyComponent } from './MyComponent';

export const DemoMyComponent = createDemo(import.meta.url, MyComponent, {
  name: 'My Component Demo',
  slug: 'my-component-demo',
});
```

When used with a controller, the demo automatically:

- Loads source code from the filesystem
- Provides editing capabilities through [`useCode`](../../hooks/use-code/page.mdx) or [`useDemo`](../../hooks/use-demo/page.mdx)
- Updates the controller state when code changes
- Re-renders connected components

## Client Dependencies for Live Demos

For live demos that need to run code dynamically (like the Live Demo example), you must provide a `ClientProvider` to ensure dependencies are properly bundled:

### Using createDemoClient

> [!NOTE]
> Before you can use `createDemoClient` in your demos, you must first create this file in your repo using the abstract factory.
> See the [`abstractCreateDemoClient`](../../factories/abstract-create-demo-client/page.mdx#implementation) docs for details.

Once you've created your own `createDemoClient` file, you can use it in your demos as shown below:

```tsx filename=client.ts
// demos/my-live-demo/client.ts
'use client';

import { createDemoClient } from '../createDemoClient';

const ClientProvider = createDemoClient(import.meta.url);

export default ClientProvider;
```

### Creating a Custom createDemoClient

You can also create your own `createDemoClient` using the abstract factory:

```tsx filename=createDemoClient.ts
'use client';

import { createDemoClientFactory } from '@mui/internal-docs-infra/abstractCreateDemoClient';

/**
 * Creates a demo client copying dependencies in the client bundle for live editing.
 * @param url Depends on `import.meta.url` to determine the source file location.
 * @param meta Additional meta and modules for the demo client.
 */
export const createDemoClient = createDemoClientFactory({
  live: true,
});
```

### Integration with createLiveDemo

Then use the `ClientProvider` in your demo configuration:

```tsx filename=index.ts
// demos/my-live-demo/index.ts
import { createLiveDemo } from '../createLiveDemo';
import ClientProvider from './client';
import MyComponent from './MyComponent';

export const DemoMyLiveComponent = createLiveDemo(import.meta.url, MyComponent, {
  name: 'My Live Component',
  slug: 'my-live-component',
  ClientProvider, // Required for dependency hoisting
});
```

The `ClientProvider` ensures that:

- Component dependencies are hoisted into the client bundle
- External libraries are available for the `useRunner` hook through `CodeExternalsContext`
- Live code execution has access to all required modules via precomputed externals

This is only needed for demos that render live components from editable code, not for simple code editor scenarios.

## Best Practices

1. **Use with [`CodeProvider`](../code-provider/page.mdx)** - Always wrap CodeController with [`CodeProvider`](../code-provider/page.mdx) for client-side highlighting
2. **Keep controllers simple** - Controllers should only manage state, not complex logic
3. **Let hooks handle integration** - Use [`useCode`](../../hooks/use-code/page.mdx) and [`useDemo`](../../hooks/use-demo/page.mdx) hooks rather than manual context access
4. **Start with empty state** - Let the initial code load through the normal [`CodeHighlighter`](../code-highlighter/page.mdx) flow
5. **Use controlled prop** - Set `controlled={true}` on [`CodeHighlighter`](../code-highlighter/page.mdx) components

## Context API

### CodeControllerContext

The context provides the following interface:

```typescript
interface CodeControllerContext {
  // Current controlled code state
  code?: ControlledCode;

  // Current selection (variant, file, transform)
  selection?: Selection;

  // Function to update code state
  setCode?: React.Dispatch<React.SetStateAction<ControlledCode | undefined>>;

  // Function to update selection state
  setSelection?: React.Dispatch<React.SetStateAction<Selection>>;

  // Override components for live previews
  components?: Record<string, React.ReactNode>;
}
```

### useControlledCode Hook

Access the context values:

```tsx
import { useControlledCode } from '@mui/internal-docs-infra/CodeControllerContext';

function MyComponent() {
  const {
    controlledCode,
    controlledSelection,
    controlledSetCode,
    controlledSetSelection,
    controlledComponents,
  } = useControlledCode();

  // Use the values...
}
```

### Types

import { TypesCodeControllerContext } from './types';

<TypesCodeControllerContext />

[See Types](./types.md#CodeControllerContext)

## Requirements

- **[`CodeProvider`](../code-provider/page.mdx)**: Required for client-side code highlighting and processing
- **Client component**: CodeController must be a client component (`'use client'`)
- **Controlled prop**: [`CodeHighlighter`](../code-highlighter/page.mdx) components must have `controlled={true}`
- **ClientProvider**: Required for live demos that execute code dynamically (use `createDemoClient` to create one)

## Related Components

- **[CodeHighlighter](../code-highlighter/page.mdx)** - Displays and highlights source code
- **[CodeProvider](../code-provider/page.mdx)** - Provides client-side code processing functions
- **[`useCode`](../../hooks/use-code/page.mdx) Hook** - Integrates [`CodeHighlighter`](../code-highlighter/page.mdx) with controller state
- **[`useDemo`](../../hooks/use-demo/page.mdx) Hook** - Extends [`useCode`](../../hooks/use-code/page.mdx) with live component preview capabilities

## Purpose

The CodeControllerContext is specifically designed for **interactive code editing scenarios** where you need:

- Real-time code editing with syntax highlighting
- Live component previews that update as code changes
- Shared state between multiple code-related components
- TypeScript/JavaScript transformation toggle

Use this component when building interactive documentation, code playgrounds, tutorials, or any scenario where users need to edit and see live updates to source code.
