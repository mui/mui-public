# Props Context Layering

**Purpose**: Enable isomorphic components to work seamlessly with React Server Components while maintaining a single, ergonomic API.

**Core Strategy**: Render early with initial props, then progressively enhance via context when additional data/functions become available on the client.

This pattern solves a fundamental challenge: components need to render before the server-client boundary is crossed, but the complete data they need might only be available after client-side processing.

## Server-Client Boundary Constraints

A key driver for this pattern is React Server Components' serialization limitations:

**❌ Cannot pass across server-client boundary:**
- Functions (event handlers, utilities, transformers)
- Class instances (complex objects, parsed data structures)
- Non-serializable values (Date objects, Map/Set, symbols)

**✅ Can pass across server-client boundary:**
- Primitive values (strings, numbers, booleans)
- Plain objects and arrays
- **React Nodes** (pre-rendered JSX elements)

**Example of the constraint:**
```tsx
// ❌ This won't work - functions can't serialize
<ClientComponent 
  onSubmit={(data) => console.log(data)}
  parser={parseComplexData}
/>

// ✅ This works - React Nodes can serialize
<ClientComponent>
  <PreRenderedButton onClick={...} />
  <ParsedDataDisplay data={processedData} />
</ClientComponent>
```

**Why Props Context Layering helps:**
- **Props**: Carry serializable data and pre-rendered React Nodes from server
- **Context**: Provide functions and complex objects on the client side
- **Result**: Same API works in both environments without serialization issues

---

## 1. Early rendering with fallback values

Components must render on the server before crossing the client boundary. When users pass components as props to server components, those child components are immediately rendered—often before all ideal props are available.

**The challenge**: You need to display something useful immediately while waiting for enhanced data.

**The solution**: Accept whatever props are available initially, then seamlessly upgrade via context without changing the component's API.

**Implementation pattern**: Create a custom hook that merges props (immediate) with context (enhanced) values.

## 2. Conditional async operations

**The problem**: The same component may run in either server or client environments. Async server components will throw errors when executed on the client.

**The solution**: Guard async operations behind conditions: only execute them when the data is actually needed and the environment supports it.

**When to defer async work**:
- Props already contain the required data → skip async fetching
- Heavy functions are missing → assume they'll be provided later via context
- `forceClient` flag is set → defer to `useEffect` instead of server async

**Example scenarios**:
```tsx
// ✅ Conditional async component with explicit control
async function MaybeLoadData({ data, url, forceClient = false }) {
  // Only fetch if data is missing, we have a URL, and we're not forced to client-side
  if (!data && url && !forceClient) {
    const response = await fetch(url);
    return response.json();
  }
  return data; // Use provided data or defer to client
}

// ✅ Client-side equivalent for when forceClient=true
function LoadDataOnClient({ data, url, forceClient = false }) {
  const [loadedData, setLoadedData] = useState(data);
  
  useEffect(() => {
    // Only load if we're in client mode and missing data
    if (!data && url && forceClient) {
      fetch(url).then(r => r.json()).then(setLoadedData);
    }
  }, [data, url, forceClient]);
  
  return loadedData;
}

// Usage allows explicit control over async behavior
<DataComponent 
  data={serverData} 
  url="/api/fallback"
  forceClient={isClientOnlyContext} 
/>
```

Heavy functions can be provided either as props (server-side) or context (client-side). When using the [Built Factories pattern](../built-factories/page.mdx), expensive operations can even run at build time with caching.

## 3. Props-first, context-enhanced hooks

**The pattern**: Create hooks that accept props and automatically layer context updates on top. This hides the complexity from consumers while enabling progressive enhancement.

**Real-world example** from this codebase:

```ts
// useErrors hook - implements Props → Context Layering
function useErrors(props?: { errors?: Error[] }) {
  const context = useErrorsContext();
  
  // Context errors override props errors (latest wins)
  const errors = context?.errors || props?.errors;
  
  return { errors };
}

// Usage in components
function ErrorHandler({ errors }: { errors?: Error[] }) {
  const { errors: effectiveErrors } = useErrors({ errors });
  
  if (!effectiveErrors?.length) return null;
  return <ErrorDisplay errors={effectiveErrors} />;
}
```

**Another example** - the `useCode` hook:

```ts
function useCode(contentProps, opts) {
  const context = useCodeHighlighterContextOptional();
  
  // Context code overrides contentProps code when available
  const effectiveCode = context?.code || contentProps.code || {};
  
  // Context URL overrides contentProps URL
  const effectiveUrl = context?.url || contentProps.url;
  
  // ... rest of implementation
}
```

**Benefits**:
- **Server components** can pass data via props normally
- **Client components** get enhanced data via context automatically  
- **Same API** works in both environments
- **No mental overhead** for consumers—they just pass props

**Component flexibility**: The same component can perform their async task as either a server or client component:

```ts
// ✅ Server component version (no client code needed)
function ObjectHandler({ object }: { object: any }) {
  return <SomeComponent object={object} />;
}

// ✅ Client component version (with context enhancement)
'use client';
function ObjectHandler({ object }: { object: any }) {
  const { object: effectiveObject } = useObject({ object });
  return <SomeComponent object={effectiveObject} />;
}
```

Both preserve the same API shape and timing semantics.

## 4. Lazy-load heavy functions

**The goal**: Avoid shipping expensive functions to the client unless actually needed.

**The strategy**: 
- Heavy functions are **imported conditionally**—if not imported, they're not bundled
- Provide them via props (server-side) or context (client-side) only when needed
- Keep the core component logic lightweight

**Example**:
```tsx
// ❌ Heavy functions always bundled
import { expensiveParser, complexTransformer } from './heavyUtils';

// ✅ Heavy functions conditionally imported
function MyProvider({ children }: { children: React.ReactNode }) {
  const [heavyFunctions, setHeavyFunctions] = useState();
  
  const loadHeavyFunctions = useCallback(async () => {
    if (!heavyFunctions) {
      const { expensiveParser, complexTransformer } = await import('./heavyUtils');
      setHeavyFunctions({ expensiveParser, complexTransformer });
    }
  }, [heavyFunctions]);
  
  return (
    <HeavyFunctionsContext.Provider value={heavyFunctions}>
      {children}
    </HeavyFunctionsContext.Provider>
  );
}
```

**Outcome**: Minimal initial bundle, rich functionality loads on-demand.

---

## Implementation Checklist

When implementing Props → Context Layering:

- **✅ Create a merging hook** that accepts props and checks context
- **✅ Context values override props** (latest data wins)
- **✅ Handle undefined context gracefully** (server/client compatibility) 
- **✅ Guard async operations** behind conditions
- **✅ Heavy functions via dynamic imports** + context providers
- **✅ Same component API** works in server and client environments
- **✅ Progressive enhancement** without breaking changes

## Real-World Usage

This pattern is used throughout the docs-infra system:

- **[`useErrors`](../../hooks/use-errors/page.mdx)**: Server-side syntax errors → client-side runtime errors
- **[`useCode`](../../hooks/use-code/page.mdx)**: Static code props → dynamic context code  
- **[`useDemo`](../../hooks/use-demo/page.mdx)**: Build-time demos → interactive client demos
- **[`CodeHighlighter`](../../components/code-highlighter/page.mdx)**: Server highlighting → client enhancement
