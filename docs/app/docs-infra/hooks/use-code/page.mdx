# useCode Hook

The `useCode` hook provides programmatic access to code display, editing, and transformation functionality within `CodeHighlighter` components. It's designed for scenarios where you need fine-grained control over code behavior or want to build custom code interfaces that focus purely on code management, without component rendering.

The hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) to work seamlessly across server and client boundaries, automatically merging initial props with enhanced context values.

## Overview

The `useCode` hook orchestrates multiple specialized sub-hooks to provide a complete code management solution. It automatically integrates with `CodeHighlighterContext` when available, making it perfect for custom code interfaces that need to interact with the broader code highlighting system.

Key features include:

- **URL-aware file navigation** with automatic hash management
- **Automatic name and slug generation** from URLs when not provided
- **Multi-file code management** with seamless file switching
- **Transform support** for code modifications (e.g., JS â†” TS conversion)
- **Clipboard integration** with copy functionality
- **Source editing capabilities** for interactive code editing

## Architecture

The hook is built using a modular architecture with six specialized sub-hooks:

- **useVariantSelection**: Manages code variant selection and related data
- **useTransformManagement**: Handles code transforms and their application
- **useFileNavigation**: Manages file selection within code variants
- **useUIState**: Controls UI state like expansion
- **useCopyFunctionality**: Handles clipboard operations
- **useSourceEditing**: Manages source code editing capabilities

## Basic Usage

```tsx
import { useCode } from '@mui/internal-docs-infra';
import type { ContentProps } from '@mui/internal-docs-infra/CodeHighlighter/types';

function CodeContent(props: ContentProps<{}>) {
  const code = useCode(props, {
    defaultOpen: true,
    initialVariant: 'TypeScript',
  });

  return (
    <div>
      <h3>{code.userProps.name}</h3>
      <div>
        Current: {code.selectedVariant}
        <select value={code.selectedVariant} onChange={(e) => code.selectVariant(e.target.value)}>
          {code.variants.map((variant) => (
            <option key={variant} value={variant}>
              {variant}
            </option>
          ))}
        </select>
      </div>

      {/* File navigation with URL hash support */}
      {code.files.length > 1 && (
        <div>
          {code.files.map((file) => (
            <button
              key={file.name}
              onClick={() => code.selectFileName(file.name)}
              className={code.selectedFileName === file.name ? 'active' : ''}
            >
              {file.name}
            </button>
          ))}
        </div>
      )}

      <pre>{code.selectedFile}</pre>

      <button onClick={code.copy}>Copy Code</button>
    </div>
  );
}
```

## API Reference

### Parameters

#### `contentProps: ContentProps<T>`

The content properties from your `CodeHighlighter` component - typically passed directly from props.

#### `opts?: UseCodeOpts`

Optional configuration object for customizing hook behavior.

```tsx
interface UseCodeOpts {
  defaultOpen?: boolean; // Whether to start expanded
  copy?: any; // Copy functionality options
  githubUrlPrefix?: string; // GitHub URL prefix for links
  codeSandboxUrlPrefix?: string; // CodeSandbox URL prefix
  stackBlitzPrefix?: string; // StackBlitz URL prefix
  initialVariant?: string; // Initially selected variant
  initialTransform?: string; // Initially selected transform
}
```

### Return Value

The hook returns a `code` object with the following properties:

#### Variant Management

- **`variants: string[]`** - Array of available variant keys
- **`selectedVariant: string`** - Currently selected variant key
- **`selectVariant: React.Dispatch<React.SetStateAction<string>>`** - Function to change variant

#### File Navigation

- **`files: Array<{ name: string; slug?: string; component: React.ReactNode }>`** - Available files in current variant with optional URL slugs
- **`selectedFile: React.ReactNode`** - Currently selected file component
- **`selectedFileName: string | undefined`** - Name of currently selected file
- **`selectFileName: (fileName: string) => void`** - Function to select a file (automatically updates URL hash)

#### UI State

- **`expanded: boolean`** - Whether the code view is expanded
- **`expand: () => void`** - Function to expand the code view
- **`setExpanded: React.Dispatch<React.SetStateAction<boolean>>`** - Function to set expansion state

#### Copy Functionality

- **`copy: (event: React.MouseEvent<HTMLButtonElement>) => Promise<void>`** - Function to copy code to clipboard

#### Transform Management

- **`availableTransforms: string[]`** - Array of available transform keys
- **`selectedTransform: string | null | undefined`** - Currently selected transform
- **`selectTransform: (transformName: string | null) => void`** - Function to select a transform

#### Source Editing

- **`setSource?: (source: string) => void`** - Function to update source code (when available)

#### User Properties

- **`userProps: UserProps<T>`** - Generated user properties including name, slug, and custom props

## Advanced Usage

### URL Management and File Navigation

The `useCode` hook automatically manages URL hashes to reflect the currently selected file. This provides deep-linking capabilities and preserves navigation state across page reloads.

```tsx
function CodeViewer(props) {
  const code = useCode(props, {
    initialVariant: 'TypeScript',
  });

  // File selection automatically updates URL hash without polluting browser history
  // URLs follow pattern: #mainSlug:fileName or #mainSlug:variant:fileName

  return (
    <div>
      {code.files.map((file) => (
        <button
          key={file.name}
          onClick={() => code.selectFileName(file.name)}
          className={code.selectedFileName === file.name ? 'active' : ''}
        >
          {file.name}
        </button>
      ))}

      {/* File slug can be used for sharing or bookmarking */}
      <span>
        Current file URL: #{code.files.find((f) => f.name === code.selectedFileName)?.slug}
      </span>

      <pre>{code.selectedFile}</pre>
    </div>
  );
}
```

### Automatic Name and Slug Generation

When `name` or `slug` properties are not provided, the hook automatically generates them from the `url` property (or context URL). This is particularly useful when working with file-based demos or dynamic content.

```tsx
// Component with explicit name and slug
<CodeHighlighter
  name="Custom Button"
  slug="custom-button"
  Content={MyCodeContent}
>
  {/* code */}
</CodeHighlighter>

// Component with automatic generation from URL
<CodeHighlighter
  url="file:///app/components/demos/advanced-table/index.ts"
  Content={MyCodeContent}
>
  {/*
    Automatically generates:
    - name: "Advanced Table"
    - slug: "advanced-table"
  */}
</CodeHighlighter>

function MyCodeContent(props) {
  const code = useCode(props);

  // Access generated user properties
  console.log(code.userProps.name); // "Advanced Table"
  console.log(code.userProps.slug); // "advanced-table"

  return <div>{/* render code */}</div>;
}
```

### Accessing Transform Functionality

```tsx
function TransformSelector(props) {
  const code = useCode(props, {
    initialTransform: 'typescript',
  });

  return (
    <div>
      {code.availableTransforms.length > 0 && (
        <select
          value={code.selectedTransform || ''}
          onChange={(e) => code.selectTransform(e.target.value || null)}
        >
          <option value="">No Transform</option>
          {code.availableTransforms.map((transform) => (
            <option key={transform} value={transform}>
              {transform}
            </option>
          ))}
        </select>
      )}
      <pre>{code.selectedFile}</pre>
    </div>
  );
}
```

### Context Integration

The hook automatically integrates with `CodeHighlighterContext` when used as a Content component:

```tsx
// Simple wrapper component using CodeHighlighter directly
export function Code({ children, fileName }: { children: string; fileName?: string }) {
  return (
    <CodeHighlighter
      fileName={fileName}
      Content={CodeContent} // Your custom content component using useCode
      sourceParser={createParseSource()}
    >
      {children}
    </CodeHighlighter>
  );
}

// Your custom content component using useCode
function CodeContent(props: ContentProps<{}>) {
  // Automatically receives code from CodeHighlighter context
  const code = useCode(props);

  return (
    <div>
      <pre>{code.selectedFile}</pre>
      <button onClick={code.copy}>Copy</button>
    </div>
  );
}

// Usage - simple and direct
<Code fileName="example.ts">
  {`function hello() {
  console.log('Hello, world!');
}`}
</Code>;
```

## File Navigation

When your code has multiple files, you should provide navigation between them. The recommended approach is to use conditional display - only show tabs when multiple files exist, otherwise show just the filename:

> [!NOTE]
> If you're creating demos that combine component previews with multi-file code examples, consider using [`useDemo`](../use-demo/page.mdx) instead, which handles both component rendering and file navigation.

```tsx
function CodeWithTabs(props) {
  const code = useCode(props);

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        {code.files.length > 1 ? (
          <div className={styles.tabContainer}>
            {code.files.map((file) => (
              <button
                key={file.name}
                onClick={() => code.selectFileName(file.name)}
                className={`${styles.tab} ${
                  code.selectedFileName === file.name ? styles.active : ''
                }`}
              >
                {file.name}
              </button>
            ))}
          </div>
        ) : (
          <span className={styles.fileName}>{code.selectedFileName}</span>
        )}
      </div>

      <div className={styles.codeContent}>
        <pre className={styles.codeBlock}>{code.selectedFile}</pre>
      </div>
    </div>
  );
}
```

This pattern ensures a clean user experience by avoiding unnecessary tab UI when only one file exists.

## URL Hash Patterns

The hook generates URL hashes for file navigation following these patterns:

### Initial/Default Variant

```
#mainSlug:fileName
# Examples:
#button-demo:button.tsx
#data-table:index.ts
#advanced-form:styles.css
```

### Non-Initial Variants

```
#mainSlug:variantName:fileName
# Examples:
#button-demo:tailwind:button.tsx
#data-table:typescript:index.ts
#advanced-form:styled-components:styles.css
```

### File Naming Conventions

- File names are converted to kebab-case while preserving extensions
- Complex names like `ButtonWithTooltip.tsx` become `button-with-tooltip.tsx`
- Special characters are replaced with dashes
- Multiple consecutive dashes are collapsed to single dashes

### URL Management Behavior

- **Initial Load**: If URL contains a hash matching a file slug, that file is automatically selected
- **File Selection**: Selecting a file updates the URL hash without adding to browser history (uses `replaceState`)
- **Variant Changes**: When variants change, URL is updated to reflect the new variant for the current file
- **No Auto-Hash**: URLs are only set when user explicitly selects files or when URL hash is already present

## Sub-hooks Architecture

The `useCode` hook is composed of several specialized sub-hooks that can be used independently:

### useVariantSelection

Manages variant selection logic and provides variant-related data.

### useTransformManagement

Handles code transforms, including delta validation and transform application.

### useFileNavigation

Manages file selection and navigation within code variants. Features URL hash management for deep-linking and automatic slug generation for each file.

### useUIState

Controls UI-related state like expansion management.

### useCopyFunctionality

Handles clipboard operations and copy state management.

### useSourceEditing

Manages source code editing capabilities when available.

## Best Practices

### 1. Leverage Automatic URL Generation

```tsx
// Recommended: Let the hook generate name/slug from URL
<CodeHighlighter
  url="file:///components/demos/advanced-search/index.ts"
  Content={CodeContent}
>
  {/* Automatically gets name: "Advanced Search", slug: "advanced-search" */}
</CodeHighlighter>

// Override only when needed
<CodeHighlighter
  url="file:///components/demos/search/index.ts"
  name="Custom Search Component" // Override auto-generated name
  Content={CodeContent}
>
  {/* Uses custom name, but auto-generated slug: "search" */}
</CodeHighlighter>
```

### 2. Handle Deep-Linking and URL States

```tsx
function CodeViewer(props) {
  const code = useCode(props, {
    initialVariant: 'TypeScript', // Fallback if no URL hash
  });

  // URL hash automatically handled - no manual intervention needed
  // Users can bookmark specific files and return to them

  return (
    <div>
      {code.files.map((file) => (
        <button
          key={file.name}
          onClick={() => code.selectFileName(file.name)}
          data-slug={file.slug} // Available for analytics or debugging
        >
          {file.name}
        </button>
      ))}
      <pre>{code.selectedFile}</pre>
    </div>
  );
}
```

### 3. Focus on Code Management

```tsx
// Recommended: Use for code-specific functionality
function CodeSelector(props) {
  const code = useCode(props);

  return (
    <div>
      <VariantSelector
        variants={code.variants}
        selected={code.selectedVariant}
        onSelect={code.selectVariant}
      />
      <pre>{code.selectedFile}</pre>
    </div>
  );
}
```

### 4. Handle Loading States

```tsx
function SafeCodeInterface(props) {
  const code = useCode(props);

  if (!code.selectedFile) {
    return <div>Loading code...</div>;
  }

  return (
    <div>
      <pre>{code.selectedFile}</pre>
    </div>
  );
}
```

### 5. Leverage Options for Initial State

```tsx
const code = useCode(props, {
  defaultOpen: true, // Start expanded
  initialVariant: 'TypeScript', // Pre-select variant
  initialTransform: 'js', // Pre-apply transform
});
```

## Performance Considerations

- The hook uses extensive memoization to prevent unnecessary re-renders
- Transform computations are cached and only recalculated when necessary
- File navigation state is optimized for quick switching between files
- Copy functionality includes debouncing to prevent excessive clipboard operations

## Error Handling

The hook includes built-in error handling for:

- Invalid code structures
- Missing transforms
- File navigation errors
- Copy operation failures

Errors are logged to the console and the hook gracefully degrades functionality when errors occur.

## Related

- **[useDemo](../use-demo/page.mdx)**: For managing component rendering alongside code display - use this when you need both code and component functionality
- **[CodeHighlighter](../../components/code-highlighter/page.mdx)**: The main component this hook is designed to work with

## Troubleshooting

### Transforms Not Available

Transforms are only shown when they have meaningful changes. Empty transforms are automatically filtered out.

### Context Not Working

Ensure your component is used within a `CodeHighlighter` component that provides the necessary context.

### URL Hash Not Working

- Ensure your component is running in a browser environment (not SSR)
- Check that file names in your code match the expected slug patterns
- Verify that the URL hash matches the generated file slugs exactly
- Use browser dev tools to inspect `code.files[].slug` values for debugging

### Name/Slug Not Generated

- Ensure a valid `url` property is provided to `CodeHighlighter` or available in context
- Check that the URL follows a recognizable pattern (file paths or simple strings)
- If URL parsing fails, provide explicit `name` and `slug` properties as fallbacks

### File Navigation Issues

- Ensure file names are unique within each variant
- Check that `extraFiles` and main files don't have conflicting names
- Verify transforms don't create duplicate file names
