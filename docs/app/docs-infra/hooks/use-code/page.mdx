# useCode Hook

The `useCode` hook provides programmatic access to code display, editing, and transformation functionality within `CodeHighlighter` components. It's designed for scenarios where you need fine-grained control over code behavior or want to build custom code interfaces that focus purely on code management, without component rendering.

The hook implements the [Props Context Layering pattern](../../patterns/props-context-layering/page.mdx) to work seamlessly across server and client boundaries, automatically merging initial props with enhanced context values.

## Overview

The `useCode` hook orchestrates multiple specialized sub-hooks to provide a complete code management solution. It automatically integrates with `CodeHighlighterContext` when available, making it perfect for custom code interfaces that need to interact with the broader code highlighting system.

Key features include:

- **URL-aware file navigation** with automatic hash management
- **Automatic name and slug generation** from URLs when not provided
- **Multi-file code management** with seamless file switching
- **Transform support** for code modifications (e.g., JS ↔ TS conversion)
- **Clipboard integration** with copy functionality
- **Source editing capabilities** for interactive code editing

## Architecture

The hook is built using a modular architecture with six specialized sub-hooks:

- **useVariantSelection**: Manages code variant selection and related data
- **useTransformManagement**: Handles code transforms and their application
- **useFileNavigation**: Manages file selection within code variants
- **useUIState**: Controls UI state like expansion
- **useCopyFunctionality**: Handles clipboard operations
- **useSourceEditing**: Manages source code editing capabilities

## Basic Usage

```tsx
import { useCode } from '@mui/internal-docs-infra';
import type { ContentProps } from '@mui/internal-docs-infra/CodeHighlighter/types';

function CodeContent(props: ContentProps<{}>) {
  const code = useCode(props, {
    defaultOpen: true,
    initialVariant: 'TypeScript',
  });

  return (
    <div>
      <h3>{code.userProps.name}</h3>
      <div>
        Current: {code.selectedVariant}
        <select value={code.selectedVariant} onChange={(e) => code.selectVariant(e.target.value)}>
          {code.variants.map((variant) => (
            <option key={variant} value={variant}>
              {variant}
            </option>
          ))}
        </select>
      </div>

      {/* File navigation with URL hash support */}
      {code.files.length > 1 && (
        <div>
          {code.files.map((file) => (
            <button
              key={file.name}
              onClick={() => code.selectFileName(file.name)}
              className={code.selectedFileName === file.name ? 'active' : ''}
            >
              {file.name}
            </button>
          ))}
        </div>
      )}

      {code.selectedFile}

      <button onClick={code.copy}>Copy Code</button>
    </div>
  );
}
```

## API Reference

### Parameters

#### `contentProps: ContentProps<T>`

The content properties from your `CodeHighlighter` component - typically passed directly from props.

#### `opts?: UseCodeOpts`

Optional configuration object for customizing hook behavior.

```tsx
interface UseCodeOpts {
  defaultOpen?: boolean; // Whether to start expanded
  copy?: any; // Copy functionality options
  githubUrlPrefix?: string; // GitHub URL prefix for links
  codeSandboxUrlPrefix?: string; // CodeSandbox URL prefix
  stackBlitzPrefix?: string; // StackBlitz URL prefix
  initialVariant?: string; // Initially selected variant
  initialTransform?: string; // Initially selected transform
  fileHashMode?: 'full' | 'clean' | 'remove' | 'remove-after-interaction'; // Controls URL hash management
}
```

### Return Value

The hook returns a `code` object with the following properties:

#### Variant Management

- **`variants: string[]`** - Array of available variant keys
- **`selectedVariant: string`** - Currently selected variant key
- **`selectVariant: React.Dispatch<React.SetStateAction<string>>`** - Function to change variant

#### File Navigation

- **`files: Array<{ name: string; slug?: string; component: React.ReactNode }>`** - Available files in current variant with optional URL slugs
- **`selectedFile: React.ReactNode`** - Currently selected file component
- **`selectedFileName: string | undefined`** - Name of currently selected file
- **`selectFileName: (fileName: string) => void`** - Function to select a file (automatically updates URL hash)
  - **Progressive Enhancement**: Attach to `<a>` tags with `href={"#" + file.slug}` for no-JS support
  - The function will call `e.preventDefault()` after hydration
  - Use CSS `:target` and `:has()` selectors to show/hide tabs before JS loads

#### UI State

- **`expanded: boolean`** - Whether the code view is expanded
- **`expand: () => void`** - Function to expand the code view
- **`setExpanded: React.Dispatch<React.SetStateAction<boolean>>`** - Function to set expansion state

#### Copy Functionality

- **`copy: (event: React.MouseEvent<HTMLButtonElement>) => Promise<void>`** - Function to copy code to clipboard

#### Transform Management

- **`availableTransforms: string[]`** - Array of available transform keys
- **`selectedTransform: string | null | undefined`** - Currently selected transform
- **`selectTransform: (transformName: string | null) => void`** - Function to select a transform

#### Source Editing

- **`setSource?: (source: string) => void`** - Function to update source code (when available)

#### User Properties

- **`userProps: UserProps<T>`** - Generated user properties including name, slug, and custom props

## Advanced Usage

### URL Management and File Navigation

The `useCode` hook automatically manages URL hashes to reflect the currently selected file. This provides deep-linking capabilities and preserves navigation state across page reloads.

```tsx
function CodeViewer(props) {
  const code = useCode(props, {
    initialVariant: 'TypeScript',
  });

  // File selection automatically updates URL hash without polluting browser history
  // URLs follow pattern: #mainSlug:fileName or #mainSlug:variant:fileName

  return (
    <div>
      {code.files.map((file) => (
        <button
          key={file.name}
          onClick={() => code.selectFileName(file.name)}
          className={code.selectedFileName === file.name ? 'active' : ''}
        >
          {file.name}
        </button>
      ))}

      {/* File slug can be used for sharing or bookmarking */}
      <span>
        Current file URL: #{code.files.find((f) => f.name === code.selectedFileName)?.slug}
      </span>

      {code.selectedFile}
    </div>
  );
}
```

### Controlling URL Hash Behavior

The hook provides fine-grained control over URL hash management through the `fileHashMode` option, which offers four modes to suit different use cases:

#### fileHashMode

Controls how the hook interacts with URL hashes for file navigation. This single option provides complete control over hash reading, writing, and cleanup behavior.

**Options:**

- **`'full'` (default)**: Full bidirectional hash synchronization
  - Reads URL hash on mount to select the correct file/variant
  - Updates URL hash when users select different files or variants
  - Preserves complete file context in shareable links
  - **Use case**: Standard documentation where users want shareable deep links to specific files

- **`'clean'`**: Read-once with cleanup
  - Reads URL hash on mount to select the initial file/variant
  - Cleans hash to just the demo slug after applying state (e.g., `#demo:file.tsx` → `#demo`)
  - Does not update hash when users interact with files
  - **Use case**: Embedded code viewers that respect initial state but keep URLs clean

- **`'remove'`**: Read-once, then remove
  - Reads URL hash on mount to select the initial file/variant
  - Completely removes the hash after applying state (e.g., `#demo:file.tsx` → empty)
  - Does not update hash for any user interactions
  - **Use case**: Isolated code displays where URL pollution should be completely avoided

- **`'remove-after-interaction'`**: Preserve on load, remove on interaction
  - Reads URL hash on mount to select the initial file/variant
  - Keeps hash unchanged during automatic effects (variant changes, etc.)
  - Removes hash only when user explicitly clicks a file tab
  - Does not add hash back after removal
  - **Use case**: Demos that support deep linking but clean up URLs after user engagement

#### Examples

**Full mode (default) - Shareable deep links:**

```tsx
function StandardCodeViewer(props) {
  const code = useCode(props, {
    fileHashMode: 'full', // Can be omitted as it's the default
  });

  // URL updates as user navigates: #demo:styles.css
  // Perfect for documentation where users share specific file links
}
```

**Clean mode - Clean URLs for embedded viewers:**

```tsx
function EmbeddedCodeViewer(props) {
  const code = useCode(props, {
    fileHashMode: 'clean',
  });

  // If URL is #demo:variant:styles.css, that file is selected on mount
  // Hash is then cleaned to #demo (file selection is preserved in state)
  // User can select different files without changing the URL
  // Perfect for embedded scenarios that respect initial state
}
```

**Remove mode - Complete isolation:**

```tsx
function IsolatedCodeViewer(props) {
  const code = useCode(props, {
    fileHashMode: 'remove',
  });

  // If URL is #demo:file.tsx, that file is selected on mount
  // Hash is then completely removed (file selection is preserved in state)
  // No subsequent hash changes occur
  // Perfect for clean, self-contained code displays
}
```

**Remove-after-interaction mode - Deep linking with cleanup:**

```tsx
function DeepLinkCodeViewer(props) {
  const code = useCode(props, {
    fileHashMode: 'remove-after-interaction',
  });

  // If URL is #demo:variant:file.tsx, that file is selected on mount
  // Hash remains unchanged during automatic effects (variant changes, etc.)
  // When user clicks a file tab, hash is removed
  // Perfect for demos that support shareable links but clean up after user engagement
}
```

### Automatic Name and Slug Generation

When `name` or `slug` properties are not provided, the hook automatically generates them from the `url` property (or context URL). This is particularly useful when working with file-based demos or dynamic content.

```tsx
// Component with explicit name and slug
<CodeHighlighter
  name="Custom Button"
  slug="custom-button"
  Content={MyCodeContent}
>
  {/* code */}
</CodeHighlighter>

// Component with automatic generation from URL
<CodeHighlighter
  url="file:///app/components/demos/advanced-table/index.ts"
  Content={MyCodeContent}
>
  {/*
    Automatically generates:
    - name: "Advanced Table"
    - slug: "advanced-table"
  */}
</CodeHighlighter>

function MyCodeContent(props) {
  const code = useCode(props);

  // Access generated user properties
  console.log(code.userProps.name); // "Advanced Table"
  console.log(code.userProps.slug); // "advanced-table"

  return <div>{/* render code */}</div>;
}
```

### Accessing Transform Functionality

```tsx
function TransformSelector(props) {
  const code = useCode(props, {
    initialTransform: 'typescript',
  });

  return (
    <div>
      {code.availableTransforms.length > 0 && (
        <select
          value={code.selectedTransform || ''}
          onChange={(e) => code.selectTransform(e.target.value || null)}
        >
          <option value="">No Transform</option>
          {code.availableTransforms.map((transform) => (
            <option key={transform} value={transform}>
              {transform}
            </option>
          ))}
        </select>
      )}
      {code.selectedFile}
    </div>
  );
}
```

### Context Integration

The hook automatically integrates with `CodeHighlighterContext` when used as a Content component:

```tsx
// Simple wrapper component using CodeHighlighter directly
export function Code({ children, fileName }: { children: string; fileName?: string }) {
  return (
    <CodeHighlighter
      fileName={fileName}
      Content={CodeContent} // Your custom content component using useCode
      sourceParser={createParseSource()}
    >
      {children}
    </CodeHighlighter>
  );
}

// Your custom content component using useCode
function CodeContent(props: ContentProps<{}>) {
  // Automatically receives code from CodeHighlighter context
  const code = useCode(props);

  return (
    <div>
      {code.selectedFile}
      <button onClick={code.copy}>Copy</button>
    </div>
  );
}

// Usage - simple and direct
<Code fileName="example.ts">
  {`function hello() {
  console.log('Hello, world!');
}`}
</Code>;
```

## File Navigation

When your code has multiple files, you should provide navigation between them. The recommended approach is to use conditional display - only show tabs when multiple files exist, otherwise show just the filename:

> [!NOTE]
> If you're creating demos that combine component previews with multi-file code examples, consider using [`useDemo`](../use-demo/page.mdx) instead, which handles both component rendering and file navigation.

> [!TIP]
> **Progressive Enhancement**: Use `<a>` tags with `href` attributes for file tabs to enable navigation before JavaScript loads. The `selectFileName` function will prevent default navigation after hydration, while CSS `:target` and `:has()` selectors can show/hide content based on the URL hash.
>
> If a user clicks a tab before JavaScript loads, the browser navigates to the hash URL. When the page hydrates, the hook reads this hash and updates the React state accordingly - **no clicks are lost** during the transition from CSS-only to JavaScript-controlled navigation.

```tsx
function CodeWithTabs(props) {
  const code = useCode(props, { preClassName: styles.codeBlock });

  return (
    <div className={styles.container}>
      <div className={styles.header}>
        {code.files.length > 1 ? (
          <div className={styles.tabContainer}>
            {code.files.map((file) => (
              <a
                key={file.name}
                href={`#${file.slug}`}
                onClick={(e) => {
                  e.preventDefault();
                  code.selectFileName(file.name);
                }}
                className={`${styles.tab} ${
                  code.selectedFileName === file.name ? styles.active : ''
                }`}
              >
                {file.name}
              </a>
            ))}
          </div>
        ) : (
          <span className={styles.fileName}>{code.selectedFileName}</span>
        )}
      </div>

      <div className={styles.codeContent}>
        {code.files.map((file) => (
          <div
            key={file.name}
            id={file.slug}
            className={`${styles.codeFile} ${
              code.selectedFileName === file.name ? styles.selected : ''
            }`}
          >
            {file.component}
          </div>
        ))}
      </div>
    </div>
  );
}
```

**CSS for Progressive Enhancement:**

```css
/* Hide all files by default */
.codeFile {
  display: none;
}

/* Show first file when no hash target exists */
.codeContent:not(:has(.codeFile:target)) .codeFile:first-of-type {
  display: block;
}

/* Show targeted file when hash exists */
.codeFile:target {
  display: block;
}

/* After JS loads, let React control visibility */
.container:has(.tab.active) .codeFile {
  display: none; /* Disable CSS-based visibility when JS is active */
}

.container:has(.tab.active) .codeFile.selected {
  display: block; /* React-controlled selection */
}
```

This pattern ensures a clean user experience by avoiding unnecessary tab UI when only one file exists.

## URL Hash Patterns

The hook generates URL hashes for file navigation following these patterns:

### Initial/Default Variant

```
#mainSlug:fileName
# Examples:
#button-demo:button.tsx
#data-table:index.ts
#advanced-form:styles.css
```

### Non-Initial Variants

```
#mainSlug:variantName:fileName
# Examples:
#button-demo:tailwind:button.tsx
#data-table:typescript:index.ts
#advanced-form:styled-components:styles.css
```

### File Naming Conventions

- File names are converted to kebab-case while preserving extensions
- Complex names like `ButtonWithTooltip.tsx` become `button-with-tooltip.tsx`
- Special characters are replaced with dashes
- Multiple consecutive dashes are collapsed to single dashes

### URL Management Behavior

- **Initial Load**: If URL contains a hash matching a file slug, that file is automatically selected
- **File Selection**: By default (`fileHashMode: 'full'`), selecting a file updates the URL hash without adding to browser history (uses `replaceState`)
- **Variant Changes**: When variants change and a hash exists for this demo, URL is updated to reflect the new variant for the current file
- **No Auto-Hash**: URLs are only set when user explicitly selects files or when URL hash is already present
- **Controlled Behavior**: Use `fileHashMode: 'clean'`, `'remove'`, or `'remove-after-interaction'` to prevent hash updates while still reading initial state

## Sub-hooks Architecture

The `useCode` hook is composed of several specialized sub-hooks that can be used independently:

### useVariantSelection

Manages variant selection logic and provides variant-related data.

### useTransformManagement

Handles code transforms, including delta validation and transform application.

### useFileNavigation

Manages file selection and navigation within code variants. Features URL hash management for deep-linking and automatic slug generation for each file.

### useFileHashNavigation

A dedicated sub-hook that handles all URL hash management for file navigation. Controlled through the `fileHashMode` option with four distinct modes: `'full'` (default bidirectional sync), `'clean'` (read-once with cleanup), `'remove'` (read-once then remove), and `'remove-after-interaction'` (preserve on load, remove on interaction).

**All modes read the URL hash on mount** to determine initial file and variant selection. The difference is in what happens to the hash after that initial read and whether the hook continues to update it during user interactions.

This hook encapsulates the complex logic for:

- Reading and parsing URL hashes to determine initial file selection (all modes)
- Updating hashes when users select files (in `'full'` mode only)
- Cleaning hashes after initial read: keeps demo slug in `'clean'` mode, removes completely in `'remove'` mode
- Removing hashes on user interaction only in `'remove-after-interaction'` mode
- Handling variant changes and cross-variant file navigation
- Preventing infinite loops and managing navigation state

### useUIState

Controls UI-related state like expansion management.

### useCopyFunctionality

Handles clipboard operations and copy state management.

### useSourceEditing

Manages source code editing capabilities when available.

## Best Practices

### 1. Leverage Automatic URL Generation

```tsx
// Recommended: Let the hook generate name/slug from URL
<CodeHighlighter
  url="file:///components/demos/advanced-search/index.ts"
  Content={CodeContent}
>
  {/* Automatically gets name: "Advanced Search", slug: "advanced-search" */}
</CodeHighlighter>

// Override only when needed
<CodeHighlighter
  url="file:///components/demos/search/index.ts"
  name="Custom Search Component" // Override auto-generated name
  Content={CodeContent}
>
  {/* Uses custom name, but auto-generated slug: "search" */}
</CodeHighlighter>
```

### 2. Handle Deep-Linking and URL States

```tsx
function CodeViewer(props) {
  const code = useCode(props, {
    initialVariant: 'TypeScript', // Fallback if no URL hash
  });

  // URL hash automatically handled - no manual intervention needed
  // Users can bookmark specific files and return to them

  return (
    <div>
      {code.files.map((file) => (
        <button
          key={file.name}
          onClick={() => code.selectFileName(file.name)}
          data-slug={file.slug} // Available for analytics or debugging
        >
          {file.name}
        </button>
      ))}
      {code.selectedFile}
    </div>
  );
}
```

### 3. Focus on Code Management

```tsx
// Recommended: Use for code-specific functionality
function CodeSelector(props) {
  const code = useCode(props);

  return (
    <div>
      <VariantSelector
        variants={code.variants}
        selected={code.selectedVariant}
        onSelect={code.selectVariant}
      />
      {code.selectedFile}
    </div>
  );
}
```

### 4. Handle Loading States

```tsx
function SafeCodeInterface(props) {
  const code = useCode(props);

  if (!code.selectedFile) {
    return <div>Loading code...</div>;
  }

  return <div>{code.selectedFile}</div>;
}
```

### 5. Leverage Options for Initial State

```tsx
const code = useCode(props, {
  defaultOpen: true, // Start expanded
  initialVariant: 'TypeScript', // Pre-select variant
  initialTransform: 'js', // Pre-apply transform
});
```

## Performance Considerations

- The hook uses extensive memoization to prevent unnecessary re-renders
- Transform computations are cached and only recalculated when necessary
- File navigation state is optimized for quick switching between files
- Copy functionality includes debouncing to prevent excessive clipboard operations

## Error Handling

The hook includes built-in error handling for:

- Invalid code structures
- Missing transforms
- File navigation errors
- Copy operation failures

Errors are logged to the console and the hook gracefully degrades functionality when errors occur.

## Related

- **[useDemo](../use-demo/page.mdx)**: For managing component rendering alongside code display - use this when you need both code and component functionality
- **[CodeHighlighter](../../components/code-highlighter/page.mdx)**: The main component this hook is designed to work with

## Troubleshooting

### Transforms Not Available

Transforms are only shown when they have meaningful changes. Empty transforms are automatically filtered out.

### Context Not Working

Ensure your component is used within a `CodeHighlighter` component that provides the necessary context.

### URL Hash Not Working

- Ensure your component is running in a browser environment (not SSR)
- Check that file names in your code match the expected slug patterns
- Verify that the URL hash matches the generated file slugs exactly
- Use browser dev tools to inspect `code.files[].slug` values for debugging

### Name/Slug Not Generated

- Ensure a valid `url` property is provided to `CodeHighlighter` or available in context
- Check that the URL follows a recognizable pattern (file paths or simple strings)
- If URL parsing fails, provide explicit `name` and `slug` properties as fallbacks

### File Navigation Issues

- Ensure file names are unique within each variant
- Check that `extraFiles` and main files don't have conflicting names
- Verify transforms don't create duplicate file names

### Hash Behavior Not Working as Expected

- **Hash not being cleaned**: Ensure `fileHashMode` is set to `'clean'` or `'remove'` or `'remove-after-interaction'` and the hash belongs to the current demo
- **Hash still updating on clicks**: Verify `fileHashMode` is set to `'clean'`, `'remove'`, or `'remove-after-interaction'` (default is `'full'` which updates hashes)
- **Initial file not selected**: Check that the hash format matches the generated slugs (`mainSlug:fileName` or `mainSlug:variant:fileName`)
- **Hash removed unexpectedly**: If using `fileHashMode: 'remove'`, the hash will be removed on mount - this is expected behavior. For `'remove-after-interaction'`, hash is only removed on user clicks
- **Hash persisting after navigation**: With `fileHashMode: 'clean'`, the simplified demo hash is preserved; use `'remove'` if you want complete removal
- **Hash removed before user interaction**: If using `fileHashMode: 'remove-after-interaction'`, hash should persist until user clicks a tab. Check that variant changes aren't triggering removal (they shouldn't)
