# usePreference

The `usePreference` hook provides specialized preference management for code demo variants and transformations. It builds on `useLocalStorageState` with intelligent storage key generation, prefix support, and automatic optimization for single-option scenarios.

## Features

- **Specialized for demos** - Designed for variant and transform preferences
- **Intelligent storage** - Only persists when there are multiple options to choose from
- **Automatic key generation** - Creates storage keys from variant/transform names
- **Prefix support** - Configurable prefixes via PreferencesProvider
- **localStorage persistence** - Built on useLocalStorageState for cross-tab sync
- **Smart optimization** - Skips storage for single-option scenarios

## API

```typescript
const [preference, setPreference] = usePreference(type, name, initializer);
```

### Parameters

| Parameter     | Type                                       | Description                                             |
| ------------- | ------------------------------------------ | ------------------------------------------------------- |
| `type`        | `'variant' \| 'transform'`                 | Type of preference (affects storage prefix)             |
| `name`        | `string \| string[]`                       | Variant/transform name(s). Array gets sorted and joined |
| `initializer` | `string \| null \| (() => string \| null)` | Initial value or function                               |

### Returns

| Property        | Type                                                   | Description                   |
| --------------- | ------------------------------------------------------ | ----------------------------- |
| `preference`    | `string \| null`                                       | Current preference value      |
| `setPreference` | `React.Dispatch<React.SetStateAction<string \| null>>` | Function to update preference |

## Usage Examples

### Variant Preferences

```tsx
import { usePreference } from '@mui/internal-docs-infra/usePreference';

function ButtonVariantSelector() {
  // For multiple variants - will persist to localStorage
  const [variant, setVariant] = usePreference(
    'variant',
    ['contained', 'outlined', 'text'], // Multiple options
    () => 'contained',
  );

  return (
    <div>
      <p>Current variant: {variant}</p>
      {['contained', 'outlined', 'text'].map((option) => (
        <button
          key={option}
          onClick={() => setVariant(option)}
          style={{
            fontWeight: variant === option ? 'bold' : 'normal',
          }}
        >
          {option}
        </button>
      ))}
    </div>
  );
}
```

### Transform Preferences

```tsx
import { usePreference } from '@mui/internal-docs-infra/usePreference';

function CodeLanguageSelector() {
  const [language, setLanguage] = usePreference(
    'transform',
    ['typescript', 'javascript'], // Multiple languages available
    () => 'typescript',
  );

  return (
    <div>
      <label>
        <input
          type="radio"
          checked={language === 'typescript'}
          onChange={() => setLanguage('typescript')}
        />
        TypeScript
      </label>
      <label>
        <input
          type="radio"
          checked={language === 'javascript'}
          onChange={() => setLanguage('javascript')}
        />
        JavaScript
      </label>
    </div>
  );
}
```

### Single Option (No Persistence)

```tsx
import { usePreference } from '@mui/internal-docs-infra/usePreference';

function SingleVariantDemo() {
  // Only one variant - no localStorage persistence (key will be null)
  const [variant, setVariant] = usePreference(
    'variant',
    ['contained'], // Single option
    () => 'contained',
  );

  // This behaves like useState since there's no choice to remember
  return <p>Only variant available: {variant}</p>;
}
```

### With Custom Prefix

```tsx
import { usePreference, PreferencesProvider } from '@mui/internal-docs-infra/usePreference';

function CustomPrefixDemo() {
  return (
    <PreferencesProvider value={{ prefix: 'my-app' }}>
      <ComponentWithPreferences />
    </PreferencesProvider>
  );
}

function ComponentWithPreferences() {
  // Storage key will be: "my-app_variant:contained:outlined:text"
  const [variant, setVariant] = usePreference(
    'variant',
    ['contained', 'outlined', 'text'],
    () => 'contained',
  );

  return (
    <select value={variant || 'contained'} onChange={(e) => setVariant(e.target.value)}>
      <option value="contained">Contained</option>
      <option value="outlined">Outlined</option>
      <option value="text">Text</option>
    </select>
  );
}
```

### Demo Configuration Panel

```tsx
import { usePreference } from '@mui/internal-docs-infra/usePreference';

function DemoConfigPanel() {
  const [size, setSize] = usePreference('variant', ['small', 'medium', 'large'], () => 'medium');

  const [color, setColor] = usePreference(
    'variant',
    ['primary', 'secondary', 'error'],
    () => 'primary',
  );

  const [format, setFormat] = usePreference(
    'transform',
    ['typescript', 'javascript'],
    () => 'typescript',
  );

  return (
    <div className="demo-config">
      <h4>Demo Configuration</h4>

      <label>
        Size:
        <select value={size || 'medium'} onChange={(e) => setSize(e.target.value)}>
          <option value="small">Small</option>
          <option value="medium">Medium</option>
          <option value="large">Large</option>
        </select>
      </label>

      <label>
        Color:
        <select value={color || 'primary'} onChange={(e) => setColor(e.target.value)}>
          <option value="primary">Primary</option>
          <option value="secondary">Secondary</option>
          <option value="error">Error</option>
        </select>
      </label>

      <label>
        Code Format:
        <select value={format || 'typescript'} onChange={(e) => setFormat(e.target.value)}>
          <option value="typescript">TypeScript</option>
          <option value="javascript">JavaScript</option>
        </select>
      </label>
    </div>
  );
}
```

## How It Works

### Storage Key Generation

The hook generates localStorage keys based on the type and name parameters:

```typescript
// For variant preferences
// Single string name
usePreference('variant', 'contained');
// → Storage key: "_docs_variant_pref:contained"

// Array of names (sorted and joined)
usePreference('variant', ['outlined', 'contained', 'text']);
// → Storage key: "_docs_variant_pref:contained:outlined:text"

// For transform preferences
usePreference('transform', ['typescript', 'javascript']);
// → Storage key: "_docs_transform_pref:javascript:typescript"
```

### Intelligent Optimization

```typescript
const key = React.useMemo(() => {
  if (!Array.isArray(name)) {
    return name; // Single string always persists
  }

  if (name.length <= 1) {
    return null; // Single option - no need to persist choice
  }

  return [...name].sort().join(':'); // Multiple options - create stable key
}, [name]);
```

### Prefix System

```typescript
// Default prefixes
const defaultPrefixes = {
  variant: '_docs_variant_pref',
  transform: '_docs_transform_pref',
};

// With custom prefix from context
// usePreference('variant', ['a', 'b']) with prefix "my-app"
// → Storage key: "my-app_variant:a:b"
```

### Context Integration

```tsx
export interface PreferencesContext {
  prefix?: string;
}

// Usage
<PreferencesProvider value={{ prefix: 'my-docs-site' }}>
  <App />
</PreferencesProvider>;
```

## Storage Key Examples

| Type                | Name                    | Generated Key                      |
| ------------------- | ----------------------- | ---------------------------------- |
| `variant`           | `'contained'`           | `_docs_variant_pref:contained`     |
| `variant`           | `['text', 'outlined']`  | `_docs_variant_pref:outlined:text` |
| `variant`           | `['single']`            | `null` (no persistence)            |
| `transform`         | `['ts', 'js']`          | `_docs_transform_pref:js:ts`       |
| With prefix `'app'` | `variant`, `['a', 'b']` | `app_variant:a:b`                  |

## Integration with CodeHighlighter

```tsx
import { usePreference } from '@mui/internal-docs-infra/usePreference';
import { CodeHighlighter } from '@mui/internal-docs-infra/CodeHighlighter';

function CodeDemo({ availableVariants, availableTransforms }) {
  const [selectedVariant, setSelectedVariant] = usePreference(
    'variant',
    availableVariants,
    () => availableVariants[0],
  );

  const [selectedTransform, setSelectedTransform] = usePreference(
    'transform',
    availableTransforms,
    () => availableTransforms[0],
  );

  return (
    <div>
      {/* Variant selector only shows if multiple variants */}
      {availableVariants.length > 1 && (
        <VariantSelector
          variants={availableVariants}
          selected={selectedVariant}
          onChange={setSelectedVariant}
        />
      )}

      {/* Transform selector only shows if multiple transforms */}
      {availableTransforms.length > 1 && (
        <TransformSelector
          transforms={availableTransforms}
          selected={selectedTransform}
          onChange={setSelectedTransform}
        />
      )}

      <CodeHighlighter
        variant={selectedVariant}
        transform={selectedTransform}
        // ... other props
      />
    </div>
  );
}
```

## Performance Optimizations

1. **Memoized key generation** - Storage key only recalculated when name changes
2. **Conditional persistence** - Single options skip localStorage entirely
3. **Stable array keys** - Sorted arrays ensure consistent storage keys
4. **Built on useLocalStorageState** - Inherits cross-tab sync and SSR safety

## When to Use

- **Demo variant selection** - When users can choose between component variants
- **Code transform preferences** - TypeScript/JavaScript, different syntax styles
- **Multi-option scenarios** - Any case where users choose from multiple options
- **Persistent UI state** - Remember user choices across sessions

## When NOT to Use

- **Single options** - Hook automatically optimizes this case
- **Non-demo preferences** - Use `useLocalStorageState` directly for general preferences
- **Complex objects** - This hook is designed for string preferences

## TypeScript Support

```typescript
// Hook signature
function usePreference(
  type: 'variant' | 'transform',
  name: string | string[],
  initializer?: string | null | (() => string | null),
): [string | null, React.Dispatch<React.SetStateAction<string | null>>];

// Context types
interface PreferencesContext {
  prefix?: string;
}
```

## Related

- [`useLocalStorageState`](../use-local-storage-state/page.mdx) - Underlying persistence mechanism
- [`PreferencesProvider`](../../components/preferences-provider/page.mdx) - Context provider for custom prefixes
- [`CodeHighlighter`](../../components/code-highlighter/page.mdx) - Common use case for variant preferences
